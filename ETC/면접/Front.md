# 🚩 Front-end

프론트엔드 전반적인 내용, 리액트, 자바스크립트에 관한 면접을 베이스로 면접 내용을 진행하자.

# 🏷 렉시컬 스코프

함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 방식을 말핣니다. 자바스크립트를 비롯한 대부분의 언어는 렉시컬 스코프를 따릅니다.

# 🏷 브라우저의 렌더링 원리

참조 : [링크](https://patrick-f.tistory.com/9)

브라우저가 화면에 나타나는 요소를 렌더링 할 때에는 사파리나 크롬은 `웹킷(Webkit)`, 파이어폭스는 `게코(Gecko)`등과 같은 `렌더링 엔진`을 사용합니다.

렌더링 엔진이 HTML, CSS, JavaScript등으로 이뤄진 개발자가 작성한 문서를 브라우저에 렌더링할 때 다음의 단계가 이뤄집니다.

1. 브라우저 주소창에 특정 주소를 입력합니다.

2. 해당 주소의 서버를 찾아가고 DNS가 실제 서버가 있는 곳으로 연결을 해줍니다.

3. 서버의 기본 설정이 대부분 index.html로 되어있으므로 이 파일을 서버에 요청, 응답으로 클라이언트 쪽으로 보내줍니다.

4. HTML 파일을 파싱 후, DOM(Document Object Model) 트리 구축 (Parsing)

5. html 파서는 파싱을 하다가 script tag를 만나면 JS 코드를 실행하기 위해서 파싱을 중단하고 제어 권한을 JS Engine에 넘기고 JS 코드와 파일을 로드하여 파싱하고 실행합니다.

6. CSS 파일 파싱 후, CSSOM(CSS Object Model) 트리 구축 (Parsing)

    이 과정에서 Link tag등을 만나면 요청, 응답을 거쳐 Css 재 파싱

7. DOM과 CSSOM을 조합하여 렌더링 트리(Rendering Tree) 구축 (Style)

    ! 주의 사항 : `visibility: hidden`은 요소가 공간을 차지하고, 보이지만 않기 때문에 Render Tree에 포함이 되지만, `display: none` 의 경우 Render Tree에서 제외된다.

8. 렌더링 트리(Rendering Tree)에서 각 노드의 위치와 크기를 계산한다.(Layout)

9. 계산된 값을 이용하여 각 노드를 화면상의 실제 픽셀로 변환, 레이어를 만든다.(Paint)

## 🏷 파싱

문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다.

파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 부른다.

예를 들면 2+3-1과 같은 표현식은 다음과 같은 트리가 된다.

<img src="https://d2.naver.com/content/images/2015/06/helloworld-59361-5.png">

---

# 🏷 동기와 비동기

`동기(Syncronous)`는 요청 후 응답을 받아야 다음 동작을 실행하는 방식을 말하며

`비동기(Asynchronous)`는 요청을 보낸 후 응답과 관계없이 다음 동작을 실행하는 방식입니다.

자바스크립트는 단일 스레드 프로그래밍 언어이기 떄문에 단일 호출 스택이 있어 한 번에 하나의 일 밖에 처리하지 못합니다. 그러므로 자바스크립트는 기본적으로 `동기` 방식으로 진행됩니다.

그렇기 때문에 데이터의 로딩등이 오래걸리는 문제등이 생겨 비동기적으로 처리해야 합니다.

# 🏷 비동기적으로 실행이 되는 것을 동기적으로 코딩하는 방법에는 무엇이 있는가?

## 🔖 비동기 - callback

콜백 함수란 다른 함수의 인자로 이용되는 함수를 의미하며, 이벤트에 의해 호출되는 함수입니다.

그![](https://i2.ruliweb.com/img/22/04/13/1801ebd9c2811a1ea.jpeg)러나 자바스크립트 엔진만으로는 비동기적으로 구현할 수 없기 때문에 자바스크립트 실행 환경(Runtime)은 브라우저에서 제공하는 Web api를 사용하여 비동기를 구현하게 됩니다.

DOM 이벤트, setTimeout과 같은 비동기 함수는 web API를 호출하여 콜백 함수를 콜백 큐에 넣습니다. 이러한 콜백 함수들이 담긴 큐를 특정 시점에서 콜백을 실행시키는 방식입니다.

그러나 비동기 구현을 위한 첫 번째 방법인만큼 큰 문제가 있습니다. 콜백 함수가 콜백 함수를 부르고, 그 콜백 함수가 또 다른 콜백함수를 부르는 이른바 콜백 지옥이 발생할 수 있습니다.

## 🔖 비동기 - 프로미스(Promise)

프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다. 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다.

new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

-   Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태

-   Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태

    이행 상태가 되면 then()을 이용하여 처리 결과 값을 받을 수 있습니다.

-   Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

    실패 상태가 되면 catch()를 이용하여 실패한 이유를 받을 수 있습니다.

## 🔖 비동기 - Async && await

기존의 promise와 다른 것이 크게 없는, 문법적 설탕(Syntactic sugar)의 일종입니다. 상황에 따라서 promise를 더 깔끔하게 사용할 수 있습니다.

달라진 점은 `async 키워드`가 function 앞에 붙었다는 것과 Promise를 리턴하는 모든 비동기 함수 호출부 앞에는 `await 키워드`가 추가되었습니다.

`await 키워드`는 `async 키워드가 붙어있는 함수 내부에서만` 사용할 수 있으며 비동기 함수가 리턴하는 Promise로 부터 결과값을 추출해줍니다.

await 키워드를 사용하면 일반 비동기 처리처럼 바로 실행이 다음 라인으로 넘어가는 것이 아니라 결과값을 얻을 수 있을 때까지 기다려줍니다.

또한 동기/비동기 구분없이 `try/catch`로 일관되게 예외 처리를 할 수 있습니다.

---

# 🏷 CSR && SSR

CSR(Client Side Rendering)과 SSR(Server Side Rendering)은 대척 관계에 있는 방식인만큼 장단점이 서로 엇갈려 있다.

-   SSR 단계
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdGCZHY%2FbtrcOfdcohI%2FDKF2Cr2HHW5X8vNSaexEpK%2Fimg.png">

-   CSR 단계
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbkJ0my%2FbtrcOM9GT1V%2FaKDCRhm77MfHF8ushplGi0%2Fimg.png">

## 차이점

-   웹페이지의 로딩 시간은 크게 2개로 나눌 수 있다.
    -   웹페이지 로딩은 크게 첫 페이지를 로딩하는 것.
    -   나머지를 로딩하는 것

`CSR`의 경우 HTML, CSS, 모든 스크립트를 한번에 불러온다. 반면 `SSR`은 필요한 부분의 HTML과 스크립트만 불러온다. 고로 평균적인 속도는 `SSR`이 더 빠르다.

그러나 나머지 로딩 시간(즉, 첫 페이지를 로딩한 후의 로딩 시간)의 경우에는 CSR은 이미 첫 페이지 로딩시 나머지 부분을 구성하는 코드를 전부 가져오기 때문에 빠르다.

반면, SSR은 첫페이지를 로딩한 과정을 정확하게 다시 실행하기 때문에 비교적 더 느리다.

## 사용 권장 예시

-   SSR의 경우

1. 네트워크가 느릴 경우에 사용
2. SEO(Search Engine Optimization : 검색 엔진 최적화)가 필요할 경우
3. 최초 로딩이 빨라야하는 사이트를 개발 하는 경우
4. 메인 스크립트가 크고 로딩이 매우 느릴 때
5. 웹 사이트가 상호작용이 별로 없을 때

-   CSR 사용의 경우

1. 네트워크가 빠를 때
2. 서버의 성능이 좋지 않을 때
3. 사용자에게 보여줘야 하는 데이터의 양이 많을 때(로딩 창 사용 쌉가능)
4. 메인 스크립트가 가벼울 때
5. SEO 를 고려하지 않을 때
6. 웹 어플리케이션과 사용자와 상호작용이 많을 때

---

# 쿠키(Cookie)

쿠키는 웹사이트 접속시 접속자의 개인장치에 다운로드 되고 브라우저에 저장되는 작은 텍스트 파일입니다. 웹사이트는 쿠키를 통해 접속자의 장치를 인식하고, 접속자의 설정과 과거 이용내역에 대한 일부 데이터를 저장합니다.

# 🏷 Web Storage

키/값 쌍으로 데이터를 저장하고 키를 기반으로 데이터를 조회하는 패턴입니다.

동시에 영구저장소인 `로컬 스토리지(Local Storage)`와 임시저장소인 `세션 스토리지(Session Storage)`를 따로 두어 데이터의 지속성을 구분할 수 있습니다.

Web Storage는 기존 웹 환경의 `쿠키(Cookie)`와 매우 유사한 개념인데 쿠키의 단점을 극복하는 개선점들이 포함되어 있다. 또한 쿠키와 마찬가지로 데이터의 보안 측면에서 사이트의 도메인 단위로 접근이 제한됩니다.

또한 저장된 데이터의 임의 수정이 가능하다.

## 🔖 쿠키와의 차이점

-   쿠키는 매번 서버로 전송된다

    웹 사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송됩니다. 반면 Web Storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송은 이루어지지 않아 네트워크 트래픽 비용이 절감됩니다.

-   단순 문자열을 넘어(스크립트) 객체정보를 저장할 수 있다

    객체를 저장할 수 있어 개발 편의성을 크게 올릴 수 있습니다.

-   용량의 제한이 없다

    쿠키는 개수와 용량에 있어 제한이 있습니다. 하나의 사이트에 최대 20개, 최대 크기는 4KB로 제한되어 있습니다.
    반면 Web Storage에는 이러한 제한이 없습니다.

## 🔖 로컬 스토리지(Local Storage)

저장한 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능합니다. 도메인마다 별도로 로컬 스토로지가 생성됩니다.

## 🔖 세션 스토리지(Session Storage)

데이터의 지속성과 액세스 범위에 특수한 제한이 존재합니다. 또한 데이터가 지속적으로 보관되지 않습니다.

세션의 경우 도메인이 같아도 브라우저가 다르면 서로 다른 영역이 된다.(로컬은 아님)

# 📚 프레임워크 vs 라이브러리

프레임워크와 라이브러리는 애플리케이션을 개발하는데 있어 쉽고 빠른 생산성을 위해 사용한다는 공통점을 지닌다.

둘의 가장 큰 차이점은 흐름을 누가 가지고 있느냐에 있다.

`프레임워크`는 스스로 흐름을 가지고 있어 사용자로 하여금 코드를 연결할 공간을 강제하지만 `라이브러리`를 사용할 때에는 사용자에게 흐름을 직접 제어하게한다.

한마디로 `프레임워크`를 집이라는 건물에 비유한다면 `라이브러리`는 집 안에 포함되는 가구들에 비유할 수 있다.

`프레임워크`는 가져다가 사용한다는 것보다는 프레임워크라는 특정 공간에 사용한다느 느낌이 더 강하고, `라이브러리`는 도구마냥 라이브러리 자체를 가져다가 사용하고 호출하는 용도로 사용한다고 생각하면 쉽다.

## 📗 프레임워크(Framework)

단어 그대로 프레임워크는 뼈대나 기반구조를 뜻하며

프로그래밍을 진행할 때 필수적인 코드, 알고리즘 등과 같이 어느 정도의 구조를 제공해주기 때문에 프레임워크를 사용하는 프로그래머는 이 프레임워크의 뼈대 위에서 코드를 작성하여 프로그램을 개발한다.

프레임워크는 완성된 제품이 아닌 완성된 제품을 만들기 위해서 개발자를 도와주는 또는 기반이 되는 역할을 한다.

소프트웨어적으로 다시 정의하면 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합이다.

### 📝 프레임워크 예시

-   Java 개발자라면 Spring

-   Python 개발자라면 Django

-   JavaScript 개발자라면 Node.js

-   PHP 개발자라면 Laravel

등이 있다.

### 💡 프레임워크 특징

-   특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되어 있다.
-   추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
-   컴포넌트들은 재사용이 가능하다.
-   높은 수준에서 패턴들을 조작화 할 수 있다.

## 📗 라이브러리(Library)

라이브러리는 단순 활용가능한 도구들의 집합이다.

프로그래머가 어떠한 기능을 수행하기 위해서 도움을 주는 또는 필요한 것을 제공해주는 역할을 수행한다.

즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 의미한다.

### 📝 라이브러리 예시

-   자바스크립트에서 가장 유명한 `jQuery`는 대표적인 라이브러리이다.
-   `그래픽 사용자 인터페이스(Graphical user interface , GUI)`에서 재사용하기 쉽게 버튼, 테이블 같은 구성 요소를 호출해서 쓸수 있도록 분리해두었다면 라이브러리이다.
-   Windows에서 간혹 보았을 dll 확장자는 `동적 링크 라이브러리(dynamic-link library, DLL)`의 약자로 라이브러리라고 할 수 있다.
-   `객체지향 프로그래밍(object-oriented programming, OOP)`은 기본적으로 각 기능마다 함수화하는 것으로 클래스 라이브러리라고 할수도 있다.

# 🏷 ES6란?

ES6란 ECMAScript 2015로도 알려져 있는 ECMAScript 6는 ECMAScript 표준의 가장 최신 버전이다.

ES6는 새로운 언어 기능이 포함된 주요 업데이트이며, 2009년도에 표준화된 ES5 이후로 언어 기능에 대한 첫 업데이트이다.

## 주요 문법들

-   const , let
-   Arrow function(화살표 함수)
-   Template Literals(템플릿 리터럴)
-   Default parameters(기본 매개 변수)
-   Array and object destructing(배열 및 객체 비구조화)
-   Import and export (가져오기 및 내보내기)
-   Promise(프로미스)
-   Rest Parameter and Spread Operator(나머지 매개 변수 및 확산 연산자)
-   Classses(클래스)

등이 존재한다. 각 함수에 대한 기능은 면접 문서가 아닌 별도의 문서에서 다룰 예정.

# SPA(Single Page Application) 이란?

## 배경

SPA를 설명하려면 과거의 웹 사이트에 대해 설명할 필요가 있다.

과거 웹사이트는 지금보다 문서 하나에 전달되는 파일의 용량이 적었다. 어떤 요소를 한번 클릭하면 완전히 새로운 페이지를 서버에서 전송해 주곤 했다.

그러나 현대에 이르러 한 페이지에 해당하는 페이지 용량이 커졌고, 매번 새로운 페이지를 전달하는게 버거워졌다.

## 그래서 `SPA`란?

이러한 문제를 해결하기 위해 등장한 것이 SPA. 어떤 웹사이트의 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현하는 것이 SAP이다.

뭔가를 클릭하거나 스크롤하면, 상호작용하기 위한 최소한의 요소만 변경이 일어난다.

'페이지 변경이 일어난다고 보여지는 것' 또한 최초 로드된 자바스크립트를 통해 미리 브라우저에 올라간 템플릿만 교체되는 것이다.

## SPA 프레임워크가 하는 일

SPA 프레임워크로 유명한 Angular, React, Vue가 하는 일은 세부적인 구현 개념은 전부 다르지만, 그 목적은 모두 SPA를 쉽고 확장성 있게 구현하는 것을 목표로 Virtual DOM이라는 개념을 사용해 SPA를 구현한다.

SPA의 문제점은 자바스크립트로 인한 DOM 조작이 빈번하게 일어나 브라우저의 성능을 저하신킨다는 것이다.

Virtual DOM을 사용하는 프레임워크들은 실제 DOM 트리를 흉내 낸 가상의 객체 트리로 html 정보를 저장하고 있다가, 이 트리에 변경이 발생하면 모든 변화를 모아 단 한번 브라우저를 호출해 화면을 갱신하는 방법을 사용한다. 이렇게 하면 브라우저와의 불필요한 상호작용을 최소화하면서 인터렉티브한 웹 사이트를 만드는 것이 가능하다.

# 🚩 JavaScript

# 🏷 JavaScript란?

자바스크립트는 인터프리터 언어이며 단일 스레드 언어입니다.

예로 동적으로 UI를 변경하는 작업이 있을 시에는 UI 스레드라는 공간에서 큐방식으로 처리 순서를 담아 놓습니다.

## 🔖 실제 사용시 멀티스레드 처럼 사용하는데 어떠한 방법으로 사용하는가?

HTML 페이지에서 스크립트를 실행하면 그 페이지는 스크립트가 완료될때 까지 응답하지 않습니다. 이를 해결 하기 위해 `Web worker`를 사용합니다.

`Web worker`는 페이지의 퍼포먼스에 영향을 주지 않고 다른 스크립트와 독립적으로 백그라운드에서 실행되는 Javascript입니다. 쓰레드의 개념과도 같다고 볼 수 있습니다.

```js
if (window.Worker) {
    //웹 워커 사용 가능
} else {
    //웹 워커 사용 불가능
}
```

## 🏷 자바스크립트(JavaScript)의 동작원리에 대해서

Javascript의 동작원리를 간단하게 설명하면 다음과 같이 설명할 수 있습니다.

1. 싱글스레드 기반으로 동작하는 자바스크립트
2. 이벤트 루프를 기반으로 하는 싱글 스레드 Node.js

## 🏷 자바스크립트 엔진(Javascript Engine) 이란?

자바스크립트(JavaScript)를 해석하는 `자바스크립트 엔진(JavaScript Engine)`과 웹 브라우저에 화면을 그리는 `렌더링 엔진(Rendering Engine)`은 서로 다릅니다.

`렌더링 엔진(Rendering Engine)`은 HTML, CSS로 작성된 마크업 관련된 코드들을 콘텐츠로서 웹 페이지에 말그대로 `렌더링(rendering)`하는 역할을 합니다.

`자바스크립트 엔진(JavaScript Engine)`은 JavaScript로 작성한 코드를 해석하고 실행하는 인터프리터에 해당합니다.

> 🔍 인터프리터 && 컴파일러

    `인터프리터(interpreter)`는 프로그래밍 언어의 소스 코드를 바로 실행하는 환경을 말합니다.

    `컴파일러(compiler)`는 특정 프로그래밍 언어로 쓰여있는 문서를 다른 프로그래밍 언어로 옮기는 언어 변역 프로그램을 말합니다. ( 주로 고급 언어 -> 저급 언어인 어셈블리어로 변환)

때문에 구글에서 개발한 V8을 비롯한 대부분의 자바스크립트 엔진은 크게 세 영역으로 나뉩니다.

Call Stack, Task Queue(=Event Queue), Heap

그리고 추가적으로 'Event loop'라는 녀석이 존재하여 Task queue에 들어가는 task를 관리하게 됩니다.

<img src="https://t1.daumcdn.net/cfile/tistory/225AF03B58E4956C26">

## 🏷 Event loop를 통한 런타임 모델

JavaScript의 런타임 모델은 코드의 실행, 이벤트의 수집과 처리, 큐에 대기중인 하위 작업을 처리하는 이벤트 루프에 기반하고 있다. 이는 C, Java 등의 컴파일 언어 모델과는 매우 다르다.

-   🧐 시각적 표현

<img src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg">

## 🏷 처리 과정

### 🔖 스택(Stack)

함수의 호출들은 '프레임' 스택을 형성합니다.

```js
// 예제 코드
function foo(b) {
    let a = 10;
    return a + b + 11;
}

function bar(x) {
    let y = 3;
    return foo(x * y);
}

const baz = bar(7); // 42를 baz에 할당
```

위 예제 코드의 실행 순서는 다음과 같습니다.

1. `bar`를 호출할 때, `bar`의 인수와 지역 변수를 포함하는 첫 번째 프레임이 생성됩니다.
2. `bar`가 `foo`를 호출할 때, `foo`의 인수와 지역 변수를 포함하는 두 번째 프레임이 생성되어 첫 번째 프레임 위로 푸시(push)됩니다.
3. `foo`가 반환되면, 맨 위의 프레임 요소를 스택 밖으로 꺼냅니다. (`foo`를 꺼내므로 `bar` 호출 프레임만 남게 됩니다.)
4. `bar`마저 반환하면, 스택이 비게됩니다.

인수와 지역 변수는 스택 바깥에 저장되므로 바깥 함수가 반환한 후에도 계속 존재할 수 있습니다. 중첩 함수에서 지역 변수에 접근할 수 있는 이유이기도 합니다.

### 힙(Heap)

객체는 힙(Heap)에 할당된다. 여기서 힙은 단순히 메모리의 큰 영역을 지칭하는 용어로 사용된다.

### 큐(Queue)

Javascript 런타임은 큐(Queue)라는 처리할 메시지의 대기열을 사용한다. 각각의 메시지에는 메시지를 처리하기 위한 함수가 연결되어있다.

이벤트 루프(Event loop)의 임의 시점에, 런타임은 대기열에서 가장 오래된 메시지부터 큐에서 꺼내어 처리하기 시작한다. 이를 위해 런타임은 꺼낸 메시지를 매개변수로, 메시지에 연결된 함수를 호출한다. 다른 함수와 마찬가지로, 이 호출로 인한 새로운 스택 프레임도 생성된다.

함수 처리는 스택이 다시 텅 빌때까지 계속된다. 그 후, 큐에 메시지가 남아있으면 같은 방식으로 처리를 계속 진행한다.

### 🏷 이벤트 루프(Event Loop)

`이벤트 루프(Event Loop)`는 위의 큐에 쌓인 태스크 처리 기능을 구현할 때 보통 사용하는 방식에서 그 이름을 얻었으며, 자바스크립트 엔진이 아닌, 구동하는 환경(브라우저, 노드)에서 가지고 있는 장치입니다.

콜 스택과 `태스크 큐`(= 콜백 큐), `마이크로태스크 큐` (Micro task queue)를 감시하며, 콜 스택이 비어있을 경우에 두개의 큐에서 태스크를 가져와 콜 스택에 넣어 실행시키는 기능을 합니다.

```js
// 이벤트 루프 동작 함수화
while (queue.waitForMessage()) {
    queue.processNextMessage();
}
```

### 🏷 태스크 큐 vs 마이크로태스크 큐

2개의 큐 모두 콜백함수가 들어간다는 점에서 동일하지만 어떤 함수를 실행하느냐에 따라 어디로 들어가는지가 달라집니다.

또한 명칭은 큐 (Queue) 이지만 실제 우리가 아는 자료구조의 큐와는 다른 우선순위 큐(Priority Queue) 라고 할 수 있는데, 이벤트 루프가 2개의 큐에서 태스크를 꺼내는 조건이 “제일 오래된 태스크” 이기 때문입니다.

-   콜백함수를 `태스크 큐`에 넣는 함수들

    setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI 렌더링

-   콜백함수를 `마이크로태스크 큐`에 넣는 함수들

    process.nextTick, Promise, Object.observe, MutationObserver

태스크의 처리는 마이크로태스크 큐의처리가 우선으로 처리됩니다.

```js
console.log("콜 스택!");
setTimeout(() => console.log("태스크 큐!"), 0);
Promise.resolve().then(() => console.log("마이크로태스크 큐!"));

// 실행되는 결과
콜 스택!
마이크로태스크 큐!
태스크 큐!
```

## 기타 특징들

### "Run-to-completion"

각 메시지의 처리는 다른 메시지의 처리를 시작하기 전에 완전히 끝난다.

이 특징은 프로그램의 동작을 추론하는데 있어 매우 유용한 특성을 제공한다. 실행한 함수가 다른 작업에 의해 선점될 일이 없고, 다른 모드 코드의 실행보다 우선해서 값을 변경할 수 있으며, 중단되는 일 없이 완전히 끝나기 때문이다.

반면 C언어에서는 쓰레드에서 실행 중인 함수를 런타임 시스템이 임의로 멈추고 다른 스레드의 다른 코드를 먼저 실행할 수 있다.

이 모델의 단점은, 만약 메시지를 처리할 때 너무 오래 걸리면 웹 애플리케이션이 클릭이나 스크롤과 같은 사용자 상호작용을 처리할 수 없다는 점이다. 브라우저는 "스크립트 응답 없음" 대화상자를 표시해서 이 문제를 완화한다. 개발자로서 사용할 수 있는 좋은 방법으로는 메시지 처리를 가볍게 유지하고, 가능하다면 하나의 메시지를 여러 개로 나누는 것이 있다.

### 메시지 추가하기

웹 브라우저에서는 수신기가 부착된 이벤트가 발생하면 새로운 메시지가 추가된다. 수신기가 없으면 메시지는 유실된다. 클릭 이벤트 처리기가 붙은 요소를 클릭하면 메시지가 새로 추가되는 방식이다.

---

# 🏷 호이스팅(Hoisting)이란?

hoist(단어의 사전적 정의 : 끌어올리기). 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다.

한마디로 호이스트란 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되어 선언만 코드의 최상단으로 옮기는 것을 의미한다.

`var` keyword로 선언한 모든 변수는 호이스팅되어 undefined로 변수가 초기화됩니다. 반면 `let`, `const`로 선언한 변수는 초기화가 이뤄지지 않습니다.

즉 변수가 함수 내에서 정의된 경우, 선언이 함수의 최상단으로, 함수 바깥에서 정의된 경우에는 전역 컨텍스트의 최상위로 변경됩니다.

`할당`은 그 다음 런타임 과정에서 이뤄지기 때문에 할당 구문은 호이스팅 되지 않습니다.

-   여기서 중요한 점

## 🔖 함수 표현식(Funtion Expression)

`var 변수이름 = function 함수이름(매개변수) {로직}`의 형태는 데이터 구조로 할당되기 때문에 런타임 과정에서 처리되어 호이스팅이 불가능합니다.

함수 리터럴에 의한 표현이 이에 해당됩니다.

---

# 🏷 클로저(Closure)란?

[원리 설명 링크](https://hyunseob.github.io/2016/08/30/javascript-closure/)

클로저(Closure)의 정의는 `외부 함수에 접근할 수 있는 내부 함수 혹은 이러한 원리`를 의미합니다. 단어의 의미는 '폐쇄, 마감'등의 의미합니다.

즉 내부함수가 외부함수의 변수등에 접근할 수 있는 것을 말합니다. 그러나 그 반대는 실현이 불가능하다는 개념입니다.

또한 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’. 여기서 `환경`이라 함은 클로저가 생성될 때 그 `범위`에 있던 여러 지역 변수들이 포함된 context를 의미한다.

이 클로저를 통해서 자바스크립트에는 없는 비공개(private) 속성,메소드를 만드는 은닉화를 할 수 있으며, 콜백 함수등을 사용할 때 발생할 수 있는 에러를 해결하는데도 유용하다.

# 🏷 this에 대해서

자바스크립트에서 모든 함수는 호출될 때, 매개 변수로 전달되는 인자 외에 arguments라는 유사 배열 객체와 함께 this라는 객체를 함수 내부로 암묵적으로 전달됩니다.

자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정됩니다.

다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정됩니다.

# 🏷 화살표 함수의 this

일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되지 않고, 동적으로 되지만

화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정됩니다. 화살표 함수의 this는 언제나 상위 스코프의 this를 가리키게 됩니다.

# 🏷 이벤트 버블링 - Event Bubbling

이벤트 버를링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성을 의미합니다.

<img src="https://joshua1988.github.io/images/posts/web/javascript/event/event-bubble.png">

-   상위의 화면 요소란?

    HTML 요소는 기본적으로 트리 구조를 갖는다. 여기서는 트리 구조상 한단꼐 위의 요소를 상위 요소라 한다. body 태그는 최상위 요소라고 부릅니다.

## 이벤트 버를링을 막는 방법

`stopPropagation()` 웹 API를 사용하면 이벤트 버블링을 방지할 수 있습니다.

```Js
function logEvent(event) {
	event.stopPropagation();
}
```

# 이벤트 캡쳐 - Event Capture

이벤트 캡쳐는 버블링과 반대 방향으로 진행되는 이벤트 전파 방식이다.

<img src="https://joshua1988.github.io/images/posts/web/javascript/event/event-capture.png">

코드로 구현하면 다음과 같게 된다.

```html
<body>
    <div class="one">
        <div class="two">
            <div class="three"></div>
        </div>
    </div>
</body>
```

```js
var divs = document.querySelectorAll("div");
divs.forEach(function (div) {
    div.addEventListener("click", logEvent, {
        capture: true, // default 값은 false입니다.
    });
});

function logEvent(event) {
    console.log(event.currentTarget.className);
}
```

---

# 🚩 React

React는 Facebook에서 만든 JavaScript 라이브러리이다.

# React의 사용 이유

배우기가 쉽다. 구문이 간편하고 바닐라 자바스크립트에 비해 동적인 웹 애플리케이션 구현이 쉬웠음.

높은 수준의 유연성과 응답성, 하위 데이터 바인딩등이 굉장히 간단했다.

# 상태 관리 라이브러리란 ?

리액트는 단방향 바인딩을 지원하기 때문에 부모에서 자식으로만 state를 props로 전달할 수 있고, 자식의 props를 부모에게 직접 전달할 수는 없다.

자식에서 부모의 상태를 바꾸려면 해당 상태를 컨트롤하는 함수를 props로 넘겨주어야 한다.

하지만 이것이 반복되다 보면 엄청난 `props drilling`이 발생하게 된다는 문제가 있다. 프로젝트의 규모가 커질수록 props의 뎁스가 증가하게 되고, 이는 불필요한 리렌더링을 유발할 수도 있다.

리덕스가 나오기 이전, 리액트를 포함한 대부분의 프로젝트는 `MVC 아키텍쳐(Model-View-Controller)`가 많이 사용되었다. 컨트롤러가 여러 모델을 제어하고, 모델과 뷰가 서로 바라보는 구조로, 모델가 뷰가 양방향으로 영향을 미쳐 프로젝트 규모가 커질 수록 상태관리가 복잡하고 어렵다.

<img src="https://media.vlpt.us/images/danmin20/post/9b658196-ee2e-466f-9d45-2bcb943b7614/image.png">

이러한 문제를 해결하기 위해 페이스북이 내놓은 새로운 아키텍쳐가 `Flux 아키텍쳐`이다.

데이터의 흐름이 단방향으로 흐르는 구조이다.

<img src="https://media.vlpt.us/images/danmin20/post/28783b5d-fe8c-4a5f-9834-358ffea74922/image.png">

# Redux가 무엇인가?

페이스북이 개발한 Flux 아키텍쳐의 대표적인 라이브러리이다.

## 장점

-   Redux는 오직 하나의 스토어만을 가지며, 하나의 객체 트리를 가지기 때문에 개발 확장성 및 디버깅에 강점이 있다.
-   스토어 내부의 상태는 action 객체에 의해서만 변경될 수 있다. 모든 상태 변화들이 하나의 store에 집중되어 있고, 단방향성이 기 때문에 항상 예측 가능한 결과를 낳게 된다.

## 단점

-   보수적인 접근 방식으로 인해 높은 러닝 커브를 지니고 있다.(배우기 어려움)
-   큰 보일러 플레이트를 가진다.(보일러 플레이트 코드의 사용이 좀더 어렵다로 이해하면 될듯.)

# Recoil

페이스북에서 내놓은 새로운 상태관리 라이브러리.

리코일은 아톰과 셀렉터로 이루어져 있ㄹ다.
아톰은 상태의 단위로, 유니크한 키값으로 구분된다. 해당 아톰을 구독하고 있으면 해당 컴포넌트들만 선택적으로 리렌더링된다.

다만 아직 버전이 낮아 안정성 측면에서 낮고, DevTool이 미흡하다고 한다.

# Context API

리액트가 자체적으로 가지고 있다. 정적인 데이터 위주로 처리하거나 업데이트가 빈번하지 않을 떄 적합하다.

Provider-Consumer의 구조로 상태를 주고 받는데, Provider 하위의 모든 Consumer는 Provider의 속성이 변경될 때마다 리렌더링 된다는 단점이 존재한다.

useMemo나 useReducer와 함께 사용하면 좋은 코드 작성이 가능할 것 같다.

---

# 🚩 CSS

# 🏷 margin && padding

margin은 테두리 외부 요소에 공간을 만드는데 사용되고

padding은 테두리 내부 요소에 공간을 만드는데 사용됩니다.

# 🏷 position

position 속성은 문서 상에 요소를 배치하는 방법으로 여러 키워드 값을 가집니다.

-   static : 요소를 문서의 흐름에 따라 배치합니다.
-   relative : 자기 자신을 기준으로 Offset 을 적용합니다.
-   absolute : 요소를 일반적 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 가장 가까운 조상요소에 대해 상대적으로 배치합니다.

# TypeScript에 대해서 사용해봤는가? 어떻게 생각하는가?

정적 타이핑과 동적 타이핑의 관점에서 다소 의견이 분분하고 나또한 사용하진 않은 입장으로써 뭐가 더 나은지는 감히 말하기 힘들다.

허나 정적 타입을 지원함으로써 코드 안정성이 올라가는 측면은 짧은 소견으로도 동의하는 바.

---

비전공자로서의 선입견등이 존재.

CS기초에 대해서 얼마나 아는지

전공자로서 더 뛰어나다는걸 보여줘야된다.

나만의 메리트가 확실해야함.->나만의무기로는 부족함
