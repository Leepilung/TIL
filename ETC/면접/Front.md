# 목차

[- 프론트 엔드](#🚩-front-end)
[- 자바스크립트](#🚩-javascript)
[- 리액트](#🚩-react)
[- 뷰](#🚩-vue)

# 🚩 Front-end

<style>
    h1 {
        border-bottom : none;
    }
</style>

프론트엔드 전반적인 내용, 리액트, 자바스크립트에 관한 면접을 베이스로 면접 내용을 진행하자.

---

# 🏷 브라우저의 렌더링 과정(브라우저 동작 원리)

참조 : [링크](https://patrick-f.tistory.com/9)

브라우저가 화면에 나타나는 요소를 렌더링 할 때에는 사파리나 크롬은 `웹킷(Webkit)`, 파이어폭스는 `게코(Gecko)`등과 같은 `렌더링 엔진`을 사용합니다.

렌더링 엔진이 HTML, CSS, JavaScript등으로 이뤄진 개발자가 작성한 문서를 브라우저에 렌더링할 때 다음의 단계가 이뤄집니다.

1. 브라우저 주소창에 특정 주소(url)를 입력합니다.

2. DNS가 입력한 url을 ip주소로 변환해줍니다.

3. 홈페이지에 해당하는 파일(ex : index. html)을 서버에 요청, 서버는 응답으로 해당 파일을 클라이언트 쪽으로 보내줍니다.

4. 해당 파일을 받아오면 우선 HTML 파일을 파싱 후, DOM(Document Object Model) 트리 구축 (Parsing)

5. html 파서는 파싱을 하다가 script tag를 만나면 JS 코드를 실행하기 위해서 파싱을 중단하고 제어 권한을 JS Engine에 넘기고 JS 코드와 파일을 로드하여 파싱하고 실행합니다.

6. CSS 파일 파싱 후, CSSOM(CSS Object Model) 트리 구축 (Parsing)

   이 과정에서 Link tag등을 만나면 요청, 응답을 거쳐 Css 재 파싱

7. DOM 트리와 CSSOM 트리를 조합하여 렌더링 트리(Rendering Tree) 구축 (Style)

   ! 주의 사항 : `visibility: hidden`은 요소가 공간을 차지하고, 보이지만 않기 때문에 Render Tree에 포함이 되지만, `display: none` 의 경우 Render Tree에서 제외된다.

8. 렌더링 트리(Rendering Tree)에서 각 노드의 위치와 크기를 계산한다.(Layout)

9. 계산된 값을 이용하여 각 노드를 화면상의 실제 픽셀로 변환, 레이어를 만든다.(Paint)

# 🏷 리플로우(Reflow) && 리페인트(Repaint)

브라우저는 고정되있지 않기 때문에 크기가 조절되거나 스타일이 다시 계산되기도 하는데 이런 경우에 발생하는 것이 `리플로우(Reflow)`와 `리페인트(Repaint)입니다`.

만약 스타일이나 DOM 내부를 변경하는 DOM API가사용됐다면, 우리의 DOM은

1. 뭔가 변경됐음을 감지하고,
2. 브라우저의 렌더링 과정을 반복
3. 리렌더링을 진행

위의 3단계를 반복하면서 리플로우와 리페인트가 발생됩니다.

정확한 원인들을 나열하자면 수도없이 많지만

## 🔖 리플로우의 원인들

- 윈도우 리사이징 (뷰포트 변화는 Global Layout에 영향)
- 폰트의 변화 (height계산에 영향을 주므로 Global Layout에 영향)
- 스타일 추가 또는 제거
- 내용 변화 (인풋박스에 텍스트 입력 등..)
- :hover와 같은 CSS Pseudo Class
- 클래스 Attribute의 동적 변화
- JS를 통한 DOM 동적 변화
- 엘리먼트에 대한 offsetWidth / offsetHeight (화면에서 보여지는 좌표) 계산시
- 스타일 Attribute 동적변화

## 🔖 최대한 방지하는 방법

- 최대한 DOM 구조 상 말단 노드에만 클래스를 사용

  (최대한 리플로우의 영향을 최소화하여 수행 비용을 줄여준다)

- 인라인 스타일 자제

  (인라인 스타일이 주어지면 리플로우가 수차례 발생하게 된다. 클래스를 사용하는 것이 좋다)

- 애니메이션은 positon을 absolute와 fixed로 사용

  (주변 레이아웃 영향이 없게끔 해야한다)

- 퀄리티와 퍼포먼스를 타협

  (애니메이션 계산, 페이지 Reflow에 대한 CPU 퍼포먼스 비용을 고려해야 한다)

- 테이블로 구성된 레이아웃 자제

  (작은 변화도 테이블 전체 노드의 리플로우를 발생시킨다)

- CSS에서의 JS표현식 자제

  (문서중 일부가 Reflow될 때마다 표현식이 다시 계산되기 때문이다)

- JS를 통한 스타일 변화는 최대한 그룹화 하여 처리

- CSS 하위 선택자는 필요한 만큼만 사용

  (CSS Recalculation할 때, CSS Rule에 따라 오른쪽 -> 좌쪽으로 매치시킬 Rule이 없거나 잘못된 Rule이 튀어나올 때까지 계속 매칭하기 때문)

- 일부 속성과 메서드는 자주 사용할 때 캐싱한다

  (사용한다는 이유만으로도 리플로우가 발생하는 속성과 메서드가 있기 때문)

- position: relative; 주의!
  - 일반적인 경우: Box model → Normal flow
  - position:absolute or fixed: Box model → Out of flow(Positioning)
  - position:relative: Box model → Normal flow → Positioning

## 🏷 파싱

문서 `파싱`은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다.

파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 부른다.

예를 들면 2+3-1과 같은 표현식은 다음과 같은 트리가 된다.

<img src="https://d2.naver.com/content/images/2015/06/helloworld-59361-5.png">

---

# 🏷 브라우저의 이벤트 처리 과정

브라우저에서 이벤트에는 키보드,마우스,문서,CSS 이벤트 등 다양한 이벤트가 존재합니다.

1. 우선 이러한 이벤트가 발생했을 때 이벤트 핸들러를 코드로 구현합니다.

   ex) 마우스 클릭이면 클릭 이벤트 핸들러 구현

2. 함수에서 this를 이용하거나 핸들러로인해 브라우저에서 생성된 이벤트 객체를 활용하여 이벤트 요소의 정보를 핸들러를 통해 인수 형태로 전달합니다.

3. 이벤트 위임으로 코드의 반복성을 줄이되 Event.target 활용하기

---

# 🏷 이벤트 버블링 - Event Bubbling

이벤트 버를링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 `더 상위의 화면 요소들로 전달되어 가는 특성`을 의미합니다.

<img src="https://joshua1988.github.io/images/posts/web/javascript/event/event-bubble.png">

- 상위의 화면 요소란?

  HTML 요소는 기본적으로 트리 구조를 갖는다. 여기서는 트리 구조상 한단꼐 위의 요소를 상위 요소라 한다. body 태그는 최상위 요소라고 부릅니다.

## 이벤트 버를링을 막는 방법

`stopPropagation()` 웹 API를 사용하면 이벤트 버블링을 방지할 수 있습니다.

```Js
function logEvent(event) {
	event.stopPropagation();
}
```

## 버블링을 막음으로 인해 생길 수 있는 문제점

꼭 필요한 경우가 아니니 이상 버블링은 막지 않는 것이 좋습니다. 특정 영역의 event가 데드존이 될 수도 있기 때문입니다. 또한 확장 가능성에 매우 악영향을 끼치기도 합니다.

# 이벤트 캡쳐링 - Event Capture

이벤트 캡쳐링은 버블링과 반대 방향으로 진행되는 이벤트 전파 방식이다.

그러나 실제 코드에선 잘 이용되는 경우가 거의 없다.

<img src="https://joshua1988.github.io/images/posts/web/javascript/event/event-capture.png">

코드로 구현하면 다음과 같게 된다.

```html
<body>
  <div class="one">
    <div class="two">
      <div class="three"></div>
    </div>
  </div>
</body>
```

```js
var divs = document.querySelectorAll('div');
divs.forEach(function (div) {
  div.addEventListener('click', logEvent, {
    capture: true, // default 값은 false입니다. capture를 true로 함으로써 구현 가능합니다.
  });
});

function logEvent(event) {
  console.log(event.currentTarget.className);
}
```

---

# async && defer

브라우저 파싱 과정에서 스크립트 태그에 다는 속성 태그들입니다.

공통점으로 스크립트를 다운로드 하는 동안에도 HTML 파싱이 중단되지 않는다는 점

차이점은
async는 스크립트가 다운로드됐을 때 곧바로 평가를 실행하고 Defer는 문서를 다 읽은 후에 실행합니다.

async는 먼저 다운로드된 순서대로 실행하는 반면 defer는 선언된 순서대로 실행됩니다.

---

# 🏷 브라우저의 속도 최적화 방법

1. HTTP 요청 최소화
2. CSS 스프라이트 기법
3. 헤더에 만료 날짜 추가

   헤더에 만료 날짜를 추가하는 이유는 이미지,스타일시트 파일, JS파일 등을 사용자 컴퓨터의 캐시에 저장하여 재사용하기 위함이다.

4. 자바스크립트 파일 통합

   네이버 메일의 사례로 파일 개수를 최소화하여 로딩속도를 개선했다고 함.

5. 파일 크기 최소화

   Gzip 압축을 이용하여 파일(JS && 스타일시트) 크기를 최소화 하는 방법

6. 쿠키 크기 최소화 방법

7. 레너링 성능 향상 방법

   7-1. 스타일시트 파일을 최상단, JS 파일을 최하단에 배치
   7-2. 마크업 최적화 (영역별로 렌더되게 끔)

---

# 🆚 CSR && SSR

CSR(Client Side Rendering)과 SSR(Server Side Rendering)은 대척 관계에 있는 방식인만큼 장단점이 서로 엇갈려 있다.

- SSR 단계

  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdGCZHY%2FbtrcOfdcohI%2FDKF2Cr2HHW5X8vNSaexEpK%2Fimg.png">

- CSR 단계

  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbkJ0my%2FbtrcOM9GT1V%2FaKDCRhm77MfHF8ushplGi0%2Fimg.png">

## 차이점

- 웹페이지의 로딩 시간은 크게 2개로 나눌 수 있다.
  - 웹페이지 로딩은 크게 첫 페이지를 로딩하는 것.
  - 나머지를 로딩하는 것

`CSR`의 경우 HTML, CSS, 모든 스크립트를 한번에 불러온다.

반면 `SSR`은 필요한 부분의 HTML과 스크립트만 불러온다. 고로 평균적인 속도는 `SSR`이 더 빠르다.

그러나 나머지 로딩 시간(즉, 첫 페이지를 로딩한 후의 로딩 시간)의 경우에는 CSR은 이미 첫 페이지 로딩시 나머지 부분을 구성하는 코드를 전부 가져오기 때문에 빠르다.

반면, SSR은 첫페이지를 로딩한 과정을 정확하게 다시 실행하기 때문에 비교적 더 느리다.

## 사용 권장 예시

- SSR의 경우

1. 네트워크가 느릴 경우에 사용
2. SEO(Search Engine Optimization : 검색 엔진 최적화)가 필요할 경우
3. 최초 로딩이 빨라야하는 사이트를 개발 하는 경우
4. 메인 스크립트가 크고 로딩이 매우 느릴 때
5. 웹 사이트가 상호작용이 별로 없을 때

- CSR 사용의 경우

1. 네트워크가 빠를 때
2. 서버의 성능이 좋지 않을 때
3. 사용자에게 보여줘야 하는 데이터의 양이 많을 때(로딩 창 사용 쌉가능)
4. 메인 스크립트가 가벼울 때
5. SEO 를 고려하지 않을 때
6. 웹 어플리케이션과 사용자와 상호작용이 많을 때

---

# 🏷 Web Storage

`키/값(딕셔너리)`으로 데이터를 저장하고 `키`를 기반으로` 데이터를 조회하는 패턴`입니다.

동시에 영구저장소인 `로컬 스토리지(Local Storage)`와 임시저장소인 `세션 스토리지(Session Storage)`를 따로 두어 데이터의 지속성을 구분할 수 있습니다.

Web Storage는 기존 웹 환경의 `쿠키(Cookie)`와 매우 유사한 개념인데 쿠키의 단점을 극복하는 `개선점`들이 포함되어 있다. 또한 쿠키와 마찬가지로 데이터의 보안 측면에서 사이트의 `도메인 단위로 접근이 제한`됩니다.

또한 `저장된 데이터의 임의 수정이 가능`하다.

## 🔖 쿠키와의 차이점

- 쿠키는 매번 서버로 전송된다

  웹 사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송됩니다. 반면 Web Storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송은 이루어지지 않아 네트워크 트래픽 비용이 절감됩니다.

- 단순 문자열을 넘어 `객체정보를 저장`할 수 있다

  객체를 저장할 수 있어 개발 편의성을 크게 올릴 수 있습니다.

- 용량의 제한이 없다

  쿠키는 개수와 용량에 있어 제한이 있습니다. 하나의 사이트에 최대 20개, 최대 크기는 4KB로 제한되어 있습니다.
  반면 Web Storage에는 이러한 제한이 없습니다.

## 🔖 로컬 스토리지(Local Storage)

저장한 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능합니다. 도메인마다 별도로 로컬 스토로지가 생성됩니다.

## 🔖 세션 스토리지(Session Storage)

데이터의 지속성과 액세스 범위에 특수한 제한이 존재합니다. 또한 데이터가 지속적으로 보관되지 않습니다.

세션의 경우 도메인이 같아도 브라우저가 다르면 서로 다른 영역이 된다.(로컬은 아님)

---

# 🏷 웹 표준

기종, 플랫폼이 달라도 구현되는 기술을 동일하게 함으로써 장애인, 노약자 같은 정보 접근이 어려운 사람들도 동일한 웹사이트를 볼 수 있게끔 하는 웹 표준기술에 대한 규약, 기법 등에 대한 표준안

w3c 사이트등을 통해 표준 검사도를 검사할 수 있다.

## 👍 장점

1. 수정 관리 용이
2. 접근성 향상
3. 검색엔진 최적화
4. 파일 크기 단축 가능
5. 효율적 마크업
6. 우수한 호환성

---

# 🏷 웹 호환성

표준 웹 기술을 사용하여 어떠한 OS, 브라우저를 사용하던 동일한 결과가 나오도록 하게끔 하는 개념

국내는 IE기반의 비표준 기술이 주로 사용되고 있음.

---

# 🏷 웹사이트 성능 최적화 방법

<img src="https://velog.io/@hsecode/%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-5%EB%B6%84-%EC%99%84%EC%84%B1">

성능 최적화란 렌더링 최적화 + 로딩 최적화를 엮은 종합적인 의미이다.

- style은 상단, JS는 하단에서 불러온다.
- 웹팩의 사용
- html에서 불필요한 div 제거
- css 최적화(리플로우, 리페인팅 방지, 셀렉터 단순화)
- 애니메이션은 CSS위주로
- SEO(검색엔진최적화)
- 이미지 최적화(picture 태그, 레이지로딩, 스프라이트 이미지)

---

# 🚩 JavaScript

# 🏷 JavaScript란?

자바스크립트는 `인터프리터 언어`이며 단일 스레드 언어입니다. 동시에 `동적 언어`라고도 합니다.

## 🔖 동적 언어란?

`런타임에 타입이 결정되는 언어`를 말하며 타입(type)이 실행 시에 결정됩니다.

동시에 매번 타입을 써줄 필요가 없어 빠르게 작성이 가능합니다.

## 🔖 실제 사용시 멀티스레드 처럼 사용하는데 어떠한 방법으로 사용하는가?

HTML 페이지에서 스크립트를 실행하면 그 페이지는 스크립트가 완료될때 까지 응답하지 않습니다. 이를 해결 하기 위해 `Web worker`를 사용합니다.

`Web worker`는 페이지의 퍼포먼스에 영향을 주지 않고 다른 스크립트와 독립적으로 백그라운드에서 실행되는 Javascript입니다. 쓰레드의 개념과도 같다고 볼 수 있습니다.

```js
if (window.Worker) {
  //웹 워커 사용 가능
} else {
  //웹 워커 사용 불가능
}
```

## 🏷 자바스크립트(JavaScript)의 동작원리에 대해서

Javascript의 동작원리를 간단하게 설명하면 다음과 같이 설명할 수 있습니다.

1. 싱글스레드 기반으로 동작하는 자바스크립트
2. 이벤트 루프를 기반으로 하는 싱글 스레드 Node.js

## 🏷 자바스크립트 엔진(Javascript Engine) 이란?

자바스크립트(JavaScript)를 해석하는 `자바스크립트 엔진(JavaScript Engine)`과 웹 브라우저에 화면을 그리는 `렌더링 엔진(Rendering Engine)`은 서로 다릅니다.

`렌더링 엔진(Rendering Engine)`은 HTML, CSS로 작성된 마크업 관련된 코드들을 콘텐츠로서 웹 페이지에 말그대로 `렌더링(rendering)`하는 역할을 합니다.

`자바스크립트 엔진(JavaScript Engine)`은 JavaScript로 작성한 코드를 해석하고 실행하는 인터프리터에 해당합니다.

---

## 🔍 인터프리터 && 컴파일러

`인터프리터(interpreter)`는 프로그래밍 언어의 소스 코드를 바로 실행하는 환경을 말합니다.

`컴파일러(compiler)`는 특정 프로그래밍 언어로 쓰여있는 문서를 다른 프로그래밍 언어로 옮기는 언어 변역 프로그램을 말합니다. ( 주로 고급 언어 -> 저급 언어인 어셈블리어로 변환)

때문에 구글에서 개발한 V8을 비롯한 대부분의 자바스크립트 엔진은 크게 세 영역으로 나뉩니다.

---

Call Stack, Task Queue(=Event Queue), Heap

그리고 추가적으로 'Event loop'라는 녀석이 존재하여 Task queue에 들어가는 task를 관리하게 됩니다.

<img src="https://t1.daumcdn.net/cfile/tistory/225AF03B58E4956C26">

## 🏷 Event loop를 통한 런타임 모델

JavaScript의 런타임 모델은 코드의 실행, 이벤트의 수집과 처리, 큐에 대기중인 하위 작업을 처리하는 이벤트 루프에 기반하고 있다. 이는 C, Java 등의 컴파일 언어 모델과는 매우 다르다.

> 🧐 시각적 표현

<img src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg">

## 🏷 처리 과정

### 🔖 스택(Stack)

함수의 호출들은 '프레임' 스택을 형성합니다.

```js
// 예제 코드
function foo(b) {
  let a = 10;
  return a + b + 11;
}

function bar(x) {
  let y = 3;
  return foo(x * y);
}

const baz = bar(7); // 42를 baz에 할당
```

위 예제 코드의 실행 순서는 다음과 같습니다.

1. `bar`를 호출할 때, `bar`의 인수와 지역 변수를 포함하는 첫 번째 프레임이 생성됩니다.
2. `bar`가 `foo`를 호출할 때, `foo`의 인수와 지역 변수를 포함하는 두 번째 프레임이 생성되어 첫 번째 프레임 위로 푸시(push)됩니다.
3. `foo`가 반환되면, 맨 위의 프레임 요소를 스택 밖으로 꺼냅니다. (`foo`를 꺼내므로 `bar` 호출 프레임만 남게 됩니다.)
4. `bar`마저 반환하면, 스택이 비게됩니다.

인수와 지역 변수는 스택 바깥에 저장되므로 바깥 함수가 반환한 후에도 계속 존재할 수 있습니다. 중첩 함수에서 지역 변수에 접근할 수 있는 이유이기도 합니다.

### 🔖 힙(Heap)

객체는 `힙(Heap)`에 할당된다. 여기서 힙은 단순히 메모리의 큰 영역을 지칭하는 용어로 사용된다.

### 🔖 큐(Queue)

Javascript 런타임은 `큐(Queue)`라는 처리할 메시지의 대기열을 사용한다. 각각의 메시지에는 메시지를 처리하기 위한 함수가 연결되어있다.

이벤트 루프(Event loop)의 임의 시점에, 런타임은 대기열에서 가장 오래된 메시지부터 큐에서 꺼내어 처리하기 시작한다. 이를 위해 런타임은 꺼낸 메시지를 매개변수로, 메시지에 연결된 함수를 호출한다. 다른 함수와 마찬가지로, 이 호출로 인한 새로운 스택 프레임도 생성된다.

함수 처리는 스택이 다시 텅 빌때까지 계속된다. 그 후, 큐에 메시지가 남아있으면 같은 방식으로 처리를 계속 진행한다.

---

### 🏷 이벤트 루프(Event Loop)

`이벤트 루프(Event Loop)`는 위의 큐에 쌓인 태스크들의 처리 기능을 구현할 때 보통 사용하는 방식에서 그 이름을 얻었으며, 자바스크립트 엔진이 아닌, `구동하는 환경(브라우저, 노드)`에서 가지고 있는 장치입니다.

콜 스택과 `매크로태스크 큐`(= 콜백 큐), `마이크로태스크 큐` (Micro task queue)를 감시하며, 콜 스택이 비어있을 경우에 두개의 큐에서 태스크를 가져와 콜 스택에 넣어 실행시키는 기능을 합니다.

```js
// 이벤트 루프 동작 함수화
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

---

### 🆚 매크로태스크 큐 vs 마이크로태스크 큐

2개의 큐 모두 작업(task)가 들어간다는 점에서 동일하지만 어떤 함수를 실행하느냐에 따라 어디로 들어가는지가 달라집니다.

또한 명칭은 큐 (Queue) 이지만 실제 우리가 아는 자료구조의 큐와는 다른 우선순위 큐(Priority Queue) 라고 할 수 있는데, 이벤트 루프가 2개의 큐에서 태스크를 꺼내는 조건이 “제일 오래된 태스크” 이기 때문입니다.

- 콜백함수를 `매크로태스크 큐`에 넣는 함수들 ( 함수 실행시 함수 하나 )

  - 해당 컨텍스트 안의 함수들의 처리 순서(최상단의 함수)

  setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI 렌더링

- 콜백함수를 `마이크로태스크 큐`에 넣는 함수들 ( 프로미스 들 )

  -

  process.nextTick, Promise, Object.observe, MutationObserver

태스크의 처리는 마이크로태스크 큐의처리가 우선으로 처리됩니다.

```js
console.log("콜 스택!");
setTimeout(() => console.log("태스크 큐!"), 0);
Promise.resolve().then(() => console.log("마이크로태스크 큐!"));

// 실행되는 결과
콜 스택!
마이크로태스크 큐!
태스크 큐!
```

---

## 🏷 기타 특징들

### 🔖 "Run-to-completion"

`각 메시지의 처리는 다른 메시지의 처리를 시작하기 전에 완전히 끝난다.`

이 특징은 프로그램의 동작을 추론하는데 있어 매우 유용한 특성을 제공한다. 실행한 함수가 다른 작업에 의해 선점될 일이 없고, 다른 모드 코드의 실행보다 우선해서 값을 변경할 수 있으며, 중단되는 일 없이 완전히 끝나기 때문이다.

반면 C언어에서는 쓰레드에서 실행 중인 함수를 런타임 시스템이 임의로 멈추고 다른 스레드의 다른 코드를 먼저 실행할 수 있다.

이 모델의 단점은, 만약 메시지를 처리할 때 너무 오래 걸리면 웹 애플리케이션이 클릭이나 스크롤과 같은 사용자 상호작용을 처리할 수 없다는 점이다.

브라우저는 "스크립트 응답 없음" 대화상자를 표시해서 이 문제를 완화한다. 개발자로서 사용할 수 있는 좋은 방법으로는 메시지 처리를 가볍게 유지하고, 가능하다면 하나의 메시지를 여러 개로 나누는 것이 있다.

---

# 🏷 실행 컨텍스트(Excution Context)란?

`실행 컨텍스트`란 `실행 가능한 코드`가 `실행되기 위해 필요한 환경`을 말한다.

자바스크립트 엔진은 코드를 실행 하기 위해 다음과 같은 정보들을 알아야 한다.

- 변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티
- 함수 선언
- 변수의 유효범위(scope)
- this

이러한 정보를 형상화하고 구분하기 위해 JS엔진은 실행 컨텍스트를 `물리적 객체의 형태로 관리`한다.

코드를 실행하면 실행 컨텍스트 `스택(stack)이 생성하고 소멸`한다.

## 🔖 실행 컨텍스트의 3가지 객체

실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적 개념이다.

그러나 물리적으로는 객체의 형태를 지니며 아래의 3가지 프로퍼티를 소유한다.

<img src="https://poiemaweb.com/img/excute_context_structure.png">

### 🔖 Variable Object(VO / 변수객체)

실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보를 담는 객체인 `변수 객체(Variable Object / VO)`를 생성한다.

오직 코드가 실행될 때 엔진에 의해서만 참조되며 코드에서는 접근이 불가능한 객체이다.

- 변수
- 매개변수(parameter), 인수정보(argument)
- 함수 선언(함수 표현식 제외)

VO는 프로퍼티이기 때문에 결국 다른 객체를 가리킨다. 그러나 전역 컨텍스트의 경우와 함수 컨텍스트의 경우 가리키는 객체가 달라진다.

> 전역 컨텍스트의 경우

Variable Object는 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 `전역 객체(Global Object / GO)`를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다.

<img src="https://poiemaweb.com/img/ec-vo-global.png">

> 함수 컨텍스트의 경우

Variable Object는 Activation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다.

<img src="https://poiemaweb.com/img/ec-vo-foo.png">

### Scope Chain (SC)

스코프 체인(Scope Chain)은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있다.

스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 전역 객체(GO) 또는 활성 객체(AO)의 리스트를 가리킨다.

---

# 🏷 프로토타입(Prototype)이란?

JavaScript는 흔히 `프로토 타입 기반 언어(prototype-basd language)`라 불립니다. 동시에 함수 객체에는 `프로토타입`이라는 `특수한 유형의 객체 프로퍼티(속성)`가 존재합니다.

자바스크립트의 `모든 객체`는 자신의 `부모 역할을 담당하는 객체와 연결`되어 있습니다.

그리고 이것은 마치 객체 지향에서 `상속 개념`과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 합니다.

이러한 `부모 객체`를 `Prototype(프로토타입) 객체` 또는 줄여서 `Prototype(프로토타입)`이라 부릅니다.

---

# 🏷 렉시컬 스코프

함수를 `어디서 선언하였는지`에 따라 `상위 스코프를 결정하는 방식`을 말핣니다. 자바스크립트를 비롯한 대부분의 언어는 렉시컬 스코프를 따릅니다.

---

# 🏷 자바스크립트에서 함수는 일급 객체다.

일급 객체란 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킵니다.

1. 변수에 담을 수 있다.(변수에 함수 할당 가능)
2. 파라미터로 전달 할 수 있다.
3. 다른 함수의 반환값으로 사용할 수 있다.

이로 인해 `콜백 패턴`의 사용이 가능하고 `고차함수 생성`이 가능하며 `클로저`, `메모이제이션` 등이 가능해 집니다.

## 🔖 고차 함수(High-Order Function)

`함수를 매개변수로 전달받거나 함수를 결과로 반환하는 함수`를 말합니다.

자바스크립트의 `filter()`, `map()`, `reduce()` 함수도 고차 함수 개념을 활용해 만들어져 있습니다.

## 🔖 일급 함수란?

함수를 `일급 객체로 취급하는 것`을 말한다.

---

# 🏷 동기와 비동기

`동기(Syncronous)`는 요청 후 응답을 받아야 다음 동작을 실행하는 방식을 말하며

`비동기(Asynchronous)`는 요청을 보낸 후 응답과 관계없이 다음 동작을 실행하는 방식입니다.

자바스크립트는 단일 스레드 프로그래밍 언어이기 떄문에 단일 호출 스택이 있어 한 번에 하나의 일 밖에 처리하지 못합니다. 그러므로 자바스크립트는 기본적으로 `동기` 방식으로 진행됩니다.

그렇기 때문에 데이터의 로딩등이 오래걸리는 문제등이 생겨 비동기적으로 처리해야 합니다.

# 🏷 비동기적으로 실행이 되는 것을 동기적으로 코딩하는 방법에는 무엇이 있는가?

## 🔖 비동기 - callback(콜백함수)

콜백 함수란 `함수가 실행을 끝낸 뒤 실행되는 또 다른 함수`를 의미하며, `이벤트에 의해 호출되는 함수`입니다.

동시에 `비동기 방식으로 작성된 함수를 동기 처리하기 위해` 필요합니다.

그러나 자바스크립트 엔진만으로는 비동기적으로 구현할 수 없기 때문에 자바스크립트 실행 환경(Runtime)은 `브라우저에서 제공하는 Web api를 사용`하여 `비동기를 구현`하게 됩니다.

DOM 이벤트, setTimeout과 같은 비동기 함수는 web API를 호출하여 콜백 함수를 콜백 큐에 넣습니다. 이러한 콜백 함수들이 담긴 큐를 특정 시점에서 콜백을 실행시키는 방식입니다.

그러나 비동기 구현을 위한 첫 번째 방법인만큼 큰 문제가 있습니다. 콜백 함수가 콜백 함수를 부르고, 그 콜백 함수가 또 다른 콜백함수를 부르는 이른바 `콜백 지옥`이 발생할 수 있습니다.

### 🔖 콜백 지옥이란?

비동기 처리 로직을 위해 콜백 함수를 연속해서 사용할 때 발생하는 문제. 콜백 안에 콜백이 꼬리를 무는 구조

주된 `해결 방법`이 바로 `프로미스(Promise)`와 `async && await` 구문이다.

---

## 🔖 비동기 - 프로미스(Promise)

`프로미스`는 자바스크립트 `비동기 처리에 사용되는 객체`입니다. 주로 `서버에서 받아온 데이터를 화면에 표시할 때 사용`합니다.

new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

- Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태

- Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태

  이행 상태가 되면 `then()`을 이용하여 처리 결과 값을 받을 수 있습니다.

- Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

  실패 상태가 되면 `catch()`를 이용하여 실패한 이유를 받을 수 있습니다.

---

## 🔖 비동기 - async && await

[링크](https://ko.javascript.info/async-await#ref-2138)

기존의 promise와 다른 것이 크게 없는, 문법적 설탕(Syntactic sugar)의 일종입니다. 상황에 따라서 promise를 더 깔끔하게 사용할 수 있습니다.

달라진 점은

1. `async 키워드`가 function 앞에 붙었다는 점
2. Promise를 리턴하는 모든 비동기 함수 호출부 앞에는 `await 키워드`가 추가되었다는 점

`await 키워드`는 `async 키워드가 붙어있는 함수 내부에서만` 사용할 수 있으며 `비동기 함수가 리턴하는 Promise로부터 결과값을 추출`해줍니다.

await 키워드를 사용하면 일반 비동기 처리처럼 바로 실행이 다음 라인으로 넘어가는 것이 아니라 결과값을 얻을 수 있을 때까지 기다려줍니다.

---

### 🔖 프로미스(Promise)와의 차이점

1. 프로미스와 달리 하나의 catch만 사용하여 try 내부에서 발생하는 모든 에러를 핸들링 할 수 있다.

2. 코드가 길어지면 길어질수록, async/await 를 활용한 코드가 가독성이 좋습니다.

3. 에러의 위치를 찾기 쉽다.

---

# 🆚 프레임워크 vs 라이브러리

프레임워크와 라이브러리는 애플리케이션을 개발하는데 있어 쉽고 빠른 생산성을 위해 사용한다는 공통점을 지닌다.

둘의 가장 큰 차이점은 흐름을 누가 가지고 있느냐에 있다.

`프레임워크`는 스스로 흐름을 가지고 있어 사용자로 하여금 코드를 연결할 공간을 강제하지만 `라이브러리`를 사용할 때에는 사용자에게 흐름을 직접 제어하게한다.

한마디로 `프레임워크`를 집이라는 건물에 비유한다면 `라이브러리`는 집 안에 포함되는 가구들에 비유할 수 있다.

`프레임워크`는 가져다가 사용한다는 것보다는 프레임워크라는 `특정 공간에 사용한다는 느낌`이 더 강하고, `라이브러리`는 도구마냥 `라이브러리 자체를 가져다가 사용하고 호출하는 용도`로 사용한다고 생각하면 쉽다.

---

## 📗 프레임워크(Framework)

단어 그대로 프레임워크는 뼈대나 기반구조를 뜻하며

프로그래밍을 진행할 때 필수적인 코드, 알고리즘 등과 같이 어느 정도의 구조를 제공해주기 때문에 프레임워크를 사용하는 프로그래머는 이 `프레임워크의 뼈대 위에서 코드를 작성하여 프로그램을 개발`한다.

프레임워크는 완성된 제품이 아닌 완성된 제품을 만들기 위해서 개발자를 도와주는 또는 기반이 되는 역할을 한다.

소프트웨어적으로 다시 정의하면 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합이다.

### 📝 프레임워크 예시

- Java 개발자라면 Spring

- Python 개발자라면 Django

- JavaScript 개발자라면 Node.js

- PHP 개발자라면 Laravel

등이 있다.

### 💡 프레임워크 특징

- 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되어 있다.
- 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
- 컴포넌트들은 재사용이 가능하다.
- 높은 수준에서 패턴들을 조작화 할 수 있다.

---

## 📗 라이브러리(Library)

라이브러리는 단순 활용가능한 도구들의 집합이다.

프로그래머가 어떠한 기능을 수행하기 위해서 도움을 주는 또는` 필요한 것을 제공해주는 역할`을 수행한다.

즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 의미한다.

### 📝 라이브러리 예시

- 자바스크립트에서 가장 유명한 `jQuery`는 대표적인 라이브러리이다.
- `그래픽 사용자 인터페이스(Graphical user interface , GUI)`에서 재사용하기 쉽게 버튼, 테이블 같은 구성 요소를 호출해서 쓸수 있도록 분리해두었다면 라이브러리이다.
- Windows에서 간혹 보았을 dll 확장자는 `동적 링크 라이브러리(dynamic-link library, DLL)`의 약자로 라이브러리라고 할 수 있다.
- `객체지향 프로그래밍(object-oriented programming, OOP)`은 기본적으로 각 기능마다 함수화하는 것으로 클래스 라이브러리라고 할수도 있다.

---

# 🆚 얕은 복사(shallow copy) && 깊은 복사(deep copy)

## 🏷 얕은 복사(Shallow Copy)

얕은 복사는 `참조(주소)값의 복사`를 의미합니다.

```js
const obj = { value: 1 };
const newObj = obj;

newObj.value = 2;

console.log(obj.value); // 2
console.log(obj.value === newObj); // true
```

위와 같이 obj 객체를 newObj 객체에 할당 하였는데 이를 `참조 할당`이라 부릅니다.

참조 할당으로 복사한 후에 value 값을 바꿨음에도 두 객체의 비교값은 true로 같다고 나옵니다.

이러한 형태를 `얕은 복사`라고 말하며, 데이터가 생성되는 것이 아닌 해당 `데이터의 참조 값(= 메모리 주소)`를 전달하여 `데이터를 공유하는 것`을 말합니다.

## 🏷 깊은 복사(Deep Copy)

깊은 복사는 값 자체의 복사를 의미합니다.

```js
let a = 1;
let b = a;

b = 2;

console.log(a); // 1
console.log(b); // 2
console.log(a === b); // false
```

변수 a를 새로운 b에 할당하고, b의 값을 바꿨음에도 기존 a값은 변하지 않습니다. 비교하여도 false가 출력되며 서로의 값이 단독으로 존재합니다.

이렇듯 자바스크립트의 `원시 타입(Primitive type)은 깊은 복사`가 되며, `독립적인 메모리에 값 자체를 할당하여 생성하는 것`이라 볼 수 있습니다.

객체또한 깊은 복사가 가능한데 원본 데이터가 더럽혀 질 수 있어 주의해야 한다.

---

# 🏷 함수 선언식 vs 함수 표현식

함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않습니다.

## 🔖 함수 선언식

```js
function 함수명() {
  구현 로직
}
```

## 🔖 함수 표현식

```js
var 함수명 = function () {
  구현 로직
};
```

---

# 🏷 자바스크립트의 불변성

자바스크립트에서 불변성이란 `객체가 생성된 이후 그 상태를 변경할 수 없는 것`을 의미합니다.

```js
var coke = {
  name: 'coca',
  price: 2980,
};
var new_coke = coke;
coke.name = 'pepsi';
console.log(coke.name, new_coke.name); //'pepsi' 'pepsi'
```

객체의 경우 위와 같이 하나의 값만을 변경해도 모든 값들이 전부 변경됩니다.

redux에서 사용하는 immer 라이브러리나 객체의 깊은 복사 방법들을 사용하면 불변성을 쉽게 유지할 수 있습니다.

## 🔖 객체 깊은 복사 방법들

- Object.assign() : Objecvt.assign({}, 객체명)
- 전개 연산자(Spread Operator) : ...객체명
- JSON 객체 메소드 : stringify(), parse() 메소드

---

# 📚 문자열 리터럴 && 템플릿 리터럴 && 태그드 템플릿

## 📗 문자열 리터럴

리터럴은 선언과 동시에 값을 적용해 생성하는 방식을 말합니다.

```js
// 문자열 리터럴
ley str = "문자열"

tpyeof(str) // 'string'
```

위와 같은 선언 방식을 리터럴이라 하며, 문자열을 이런 방식으로 생성하는 것을 `문자열 리터럴` 이라고 합니다.

```js
// 객체 생성 방식
let str2 = new String('문자열 객체');

typeof str2; // 'object'
```

이 경우엔 객체이기 때문에 `객체 리터럴` 입니다.

### 📕 문자 리터럴

문자열에서 문자 1개는 `문자 리터럴`이라 하고, 이 `문자 리터럴`에는 용도가 정해진 `특수 문자 리터럴(=이스케이프 문자)`들이 있습니다.

대부분 `열슬래시(\)`와 조합해 그 용도를 표기하고, 문자열을 제어하는 용도로 주로 사용합니다.

| 문자 리터럴 |                                     용도                                     |
| :---------: | :--------------------------------------------------------------------------: |
|     \n      |                                    줄바꿈                                    |
|     \r      |                                 캐리지 리턴                                  |
|     \b      |                                  백스페이스                                  |
|     \t      |                                      탭                                      |
|     \f      |                                   폼 피드                                    |
| `\` => `\\` |      역슬래시를 문자열 안에 문자료 표현하려면 역슬래시 2개를 겹쳐 사용       |
|    ', "     | 따옴표 쌍따옴표. ''로 감싼 문자열에 작은 따옴표를 표현하려면 \' 와 같이 사용 |
|    \xnn     |                            16진수 코드 문자 표시                             |
|   \uXXXX    |                                유니코드 표시                                 |

## 📘 템플릿 리터럴

ES6에서 추가된 기능으로 표현식을 허용하는 `문자열 리터럴`을 의미합니다.

표현식은 자바스크립트 런타임 시점에 같은 변수로 선언한 리터럴 문자열의 값으로 변환됩니다.

템플릿 리터럴은 역따옴표(Backquote, Backticks) 로 감싸서 일반 문자열 선언과는 다르게 구분합니다.

템플릿 리터럴은 반드시 `` 로 감싸야 하며, '',"" 로 감싸게 되면 표현식이 문자열의 일부로 취급되어 템플릿의 기능을 하지 않게 됩니다.

템플릿 리터럴의 표현식은 `${변수명}` 으로 표현합니다.

```js
let str = 'good';
let template = `${str} game is Heroes of the Storm`;
console.log(template);
// 'good game is Heroes of the Storm'
```

## 고급 템플릿 리터럴 - 태그드 템플릿

변수값을 그대로 대입해 결과 문자열을 반환하는 간단한 템플릿 리터럴은 변수값 그대로를 대입하기 때문에 `조건에 따라 다른 값을 대입하는 것`이 불가능합니다.

태그드 템플릿은 중간 적용 함수를 작성해 입력받은 변수값을 조건에 따라 다른 값으로 변환해 템플릿에 적용할 수 있도록 합니다.

```js
let str1 = "good";

// 파라미터
// strings는 표현식(${변수명}) 사이의 문자열들만 남긴 문자열 배열. 첫번째 인자로 넘어감
// exp는 표현식(${변수명})이 들어감. 템플릿 리터럴에 표현식이 2가지 들어가면 exp1, exp2 이런식으로 갯수를 맞춰야 함
function taggedFunc(strings, exp) {
    //반환값 저장 변수
    let ret = "";
    for (let idx = 1; idx < strings.length; idx++) {
        // 루프를 도는 시작 인덱스와 갯수에 주의. 시작부분에 표현식이 있으므로 인덱스는 0('')부터 시작.
        if (idx < strings.length - 1) {
            ret += "bad" + strings[idx]; // 마지막 표현식이 아닌 경우 'bad' 문자열로 대입
        } else {
            ret += "moon" + strings[idx]; // 마지막 표현식인 경우 'moon' 문자열로 대입
        }
    }
    return ret; //결과 문자열 반환
}

//중간 함수 taggedFunc 바로 뒤에 역따옴표로 감싼 템플릿 리터럴을 붙여서 파라메터로 넘기면 된다.
let result = taggedFunc`${str1} morning, ${str1} afternoon, ${str1} evening, and ${str1} night`;
console.log(result);

// 위의 함수 console.log(strings,exp)로 파라미터를 호출하면
Array(5) -> strings
0: ""
1: " morning, "
2: " afternoon, "
3: " evening, and "
4: " night"

exp = good 호출됨
```

---

# 🏷 호이스팅(Hoisting)이란?

hoist(단어의 사전적 정의 : 끌어올리기). 인터프리터가 변수와 함수의 `메모리 공간`을 선언 전에 `미리 할당하는 것`을 의미합니다.

자바스크립트는 모든 선언(var, let, const, function, function\*, class)을 호이스팅합니다.

그러나 `var`로 선언된 변수와 달리 `let, const`의 경우 선언문 이전에 참조하려면 참조 에러를 발생시킵니다.

참고로, 변수는 선언 단계 > 초기화 단계 > 할당 단계 에 걸쳐 생성되는데, `var`로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어집니다.

반면 `let, const`로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행되기 때문에 스코프의 시작부터 ~ 변수의 선언 단계까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠집니다.

> 요약

즉 변수가 함수 내에서 정의된 경우, 선언이 함수의 최상단으로, 함수 바깥에서 정의된 경우에는 전역 컨텍스트의 최상위로 변경됩니다.

`할당`은 그 다음 런타임 과정에서 이뤄지기 때문에 `할당 구문은 호이스팅 되지 않습니다.`

---

# 🆚 var, let, const 차이점

`var`의 생명주기는 함수 스코프입니다. 반면 `let, const`의 경우는 블록 스코프 입니다.

`const`에 할당된 객체의 주소값은 수정이 안됩니다(원시 값은 깊은 복사로 이뤄져서 아예 수정 불가, 객체의 경우 얕은 복사로 이뤄져 변경을 진행해도 수정된다)

## 🔖 함수 표현식(Funtion Expression)

`var 변수이름 = function 함수이름(매개변수) {로직}`의 형태는 데이터 구조로 할당되기 때문에 런타임 과정에서 처리되어 호이스팅이 불가능합니다.

함수 리터럴에 의한 표현이 이에 해당됩니다.

---

# 🏷 자바스크립트의 데이터 타입

`원시 값(Primitive type)`과 `객체(Object)` 2개로 나뉜다.

## 🔖 원시 값(Primitive type)

- `불리언(BooleaN)` 타입 : True / False
- `Null` 타입 : null(어떤 값이 의도적으로 비어있음을 표현, 불리언에서 false로 취급)
- `undefined` 타입 : 값을 할당하지 않은 경우 undefined
- `Number` 타입 : Number와 BigInt 두개의 숫자 타입으로 나뉜다.
  - Number : 64비트 이진형식으로 -(2^53-1)부터 ~ (2^53-1)까지의 수를 표현 가능하다. 이 외에 +Infinity, -Infinity, NaN이 있다.
  - BigInt : Number의 안전 한계를 넘는 수를 저장 및 연산이 가능하다.
- `String` 타입 : 텍스트 데이터.
- `Symbol` 타입 : Symbol은 고유하고 변경 불가능한 원시 값으로 키로 사용할 수 있다.

## 🔖 객체 (Object)

CS에서 `객체`란 식별자로써 참조할 수 있는 메모리 데이터를 의미합니다.

또한 자바스크립트의 객체는 `키와 값 사이의 맵핑`입니다.

---

# 🏷 자바스크립트 형 변환(Type Conversion)

형 변환은 크게 `명시적` 형변환과 `암시적` 형변환 두 종류로 일어난다.

## 🔖 명시적 형 변환

명시적 형 변환은 주로 string, number, boolean 타입으로 이뤄진다.

말 그대로 값을 의도적으로 형태를 변형해서 사용하겠다는 선언.

```js
a = String(123);
b = Number('123');
c = Boolean(123);
```

각각의 형변환 메소드를 이용하여 형태를 변형시키는 방식으로 사용한다.

## 🔖 암시적 형변환

주로 연산할 때 발생하는 형변환 형태.

예시를 통해 알아보자

```js
// String
cons test = '문자' + 123 // '문자123'

// Number
const test2 = 1234 + '1234' // 문자열 12341234
const test3 = 1234 + true // 1235 (true = 1로 처리)
const test4 = 1234 + false // 1234 (false = 0으로 처리)
const test5 = 1234 + null // 1234(null도 0으로 처리)
const test6 = 1234 + undefined // NaN (숫자가 아닌걸로 처리)

// Boolean
const test7 = true + undefined // NaN
const test8 = false + undefined // NaN
```

피연산자가 한쪽이라도 문자열이라면 더하는 순간 무조건 문자열로 형변환이 일어난다.
나머지의 경우 산술덧셈 연산을 수행한다.

관계 연산자(< , >, <=, =>)의 경우에도 양쪽 모두 문자열인 경우를 제외하면 모두 숫자형으로 형 변환한 후에 크기를 비교하여 연산한다.

문자열간의 비교는 사전순 비교를 진행한다.

동등(==), 부등(!=) 연산자의 경우에도 자연스레 형변환이 일어난다.

나머진 해깔릴 것 없이 내가 알고있는 그대로

---

# 🏷 클로저(Closure)란?

클로저는 자바스크립트의 고유한 개념이 아니라, 여러 함수형 프로그래밍 언어에서 공통적으로 발견되는 특성이다.

[원리 설명 링크](https://hyunseob.github.io/2016/08/30/javascript-closure/)

클로저(Closure)의 정의는 `함수와 그 함수가 선언됐을 때의 어휘적(Lexical) 환경`을 의미합니다.

주된 사용으로는 Window 객체를 오염시지키지 않기 위해 사용하며 `스코프를 이용해 변수의 접근 범위를 조절하는 것`에 있습니다.

- 외부함수 스코프에서 내부함수 스코프로 접근은 불가능
- 내부함수에서는 외부함수 스코프에서 선언된 변수에 접근이 가능

또한 클로저 안에 정의된 함수는 만들어진 환경을 `기억한다`. 여기서 `환경`이라 함은 클로저가 생성될 때 그 `범위`에 있던 여러 지역 변수들이 포함된 context를 의미한다.

이 클로저를 통해서 자바스크립트에는 없는 `비공개(private) 속성`, 메소드를 만드는 `은닉화`를 할 수 있으며, 콜백 함수등을 사용할 때 발생할 수 있는 에러를 해결하는데도 유용하다.

---

# 함수 호출(call, apply, bind)

```js
function foo(a, b, c) {
  console.log(a + b + c);
}
foo(1, 2, 3); // 6
foo.call(null, 1, 2, 3); // 6
foo.apply(null, [1, 2, 3]); // 6
```

JS에서 호출 방식과 관계없이 this에 접근이 가능합니다. 이 this를 특정 객체로 지정하는 방법이다.

Call , apply는 함수를 호출하는 함수입니다. 첫번째 인자(this를 대체할 값)은 동일한데 , `차이`는 apply의 경우 두번째 인자를 배열에 담아야 한다는 것.

반대로 bind의 경우 함수를 실행하지 않는다.

---

# 🏷 this에 대해서

전역에서의 this, Node에서의 this.

자바스크립트에서 함수가 호출될 때, 매개 변수 외에 arguments라는 유사 배열 객체와 함께 `this라는 객체`를 함수 내부로 암묵적으로 전달됩니다.

함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 `바인딩할 객체가 동적으로 결정`됩니다.

브라우저에서는 기본적으로 window인 전역 객체를 참조합니다.

---

# 🏷 옵셔널 체이닝이란?

옵셔널 체이닝(optional chaining) `?.`을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.

> 특징 3가지

1. ?.는 존재하지 않아도 괜찮은 대상에만 사용해야 합니다.

2. ?.앞의 변수는 꼭 선언되어 있어야 합니다.

3. ?.은 읽기나 삭제하기에는 사용할 수 있지만 쓰기에는 사용할 수 없습니다.

---

# 🏷 화살표 함수의 this

일반 함수는 실행하는 문맥에 따라 결정된다.

화살표 함수는 함수가 선언되는 문맥에 따라 결정됩니다(정적으로 할당됨)

고로 화살표 함수의 this는 언제나 상위 스코프의 this를 가리키게 됩니다.

---

# 🏷 ES6란?

ES6란 ECMAScript 2015로도 알려져 있는 ECMAScript 6는 ECMAScript 표준의 가장 최신 버전이다.

ES6는 새로운 언어 기능이 포함된 주요 업데이트이며, 2009년도에 표준화된 ES5 이후로 언어 기능에 대한 첫 업데이트이다.

## 주요 문법들

- const , let
- Arrow function(화살표 함수)
- Template Literals(템플릿 리터럴)
- Default parameters(기본 매개 변수)
- Array and object destructing(배열 및 객체 비구조화할당 = 구조분해할당)
- Import and export (가져오기 및 내보내기)
- Promise(프로미스)
- Rest Parameter and Spread Operator(나머지 매개 변수 및 확산 연산자)
- Classs(클래스)

  클래스는 상속 가능, 프로토타입은 상속 불가능(프로토타입 체인으로 구현함)

- Multi-line String

  문자열 줄바꿈시에 \n 사용하지 않아도 백틱(`)으로 묶으면 자동으로 인식가능

등이 존재한다. 각 함수에 대한 기능은 면접 문서가 아닌 별도의 문서에서 다룰 예정.

---

# 🆚 순수함수 && 비순수함수

## 🏷 순수함수

동일한 인자를 주면 항상 동일한 값을 리턴하는 함수.

> 📝 예시

```js
// 순수함수 예시
const purity = (num1, num2) => {
  return num1 + num2;
};
```

언제나 purity(10,5)는 항상 15의 값을 리턴한다.

## 🏷 비순수함수

> 📝 예시

```js
// 비순수함수 예시 1
const nonpurity = (num1, num2) => {
  return num1 + num2 + other;
};
```

이 경우에는 other라는 변수에 따라 함수가 호출하는 결과값이 달라지기 때문에 순수함수가 아니다.

```js
// 비순수함수 예시 2
let other = 5;
const nonpurity2 = (num1, num2) => {
  other = num2;
  return num1 + num2;
};
```

이러한 경우에도 순수함수가 아니다. 함수가 외부의 값을 변경하는 코드를 가지고 있기 때문이다.

---

# 배열 순회 메소드

## map

배열을 하나씩 순회하면서 map의 콜백으로 주어진 함수를 실행시킨 결과물들을 배열에 넣어 이를 리턴합니다.

## reduce

초기값을 정하고, 배열을 순회하면서 초기값을 계속 변형해나가면서 결국 하나의 값으로 리턴합니다.

## foreach

주어진 함수를 배열 요소 각각에 대해 실행합니다.

```js
const array1 = ['a', 'b', 'c'];

array1.forEach((element) => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"
```

## filter

주어진 함수의 조건을 통과하는 모든 요소를 모아 하나의 배열로 반환핣니다.

## every

배열안의 모든 요소가 주어진 판별 함수를 통과하는지 테스트하여 Boolean 값을 반환하는 메소드

```js
const isBelowThreshold = (currentValue) => c urrentValue < 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true
```

## sum

---

# JAM Stack

Javascript, Api, MArkup Stack의 약자로 이 3가지로만 이루어진 웹의 구성을 말한다.

[레퍼런스 링크](https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7)

---

# 🚩 React

React는 Facebook에서 만든 JavaScript 라이브러리이다.

세부 내용은 React 이론 파트 참고하기. 해당 문서파트에 정리하는 내용은 토막 정보 위주로 서술하기.

# React의 사용 이유

배우기가 쉽다. 구문이 간편하고 바닐라 자바스크립트에 비해 동적인 웹 애플리케이션 구현이 쉬웠음.

높은 수준의 유연성과 응답성, 하위 데이터 바인딩등이 굉장히 간단했다.

---

# 상태 관리 라이브러리란 ?

리액트는 단방향 바인딩을 지원하기 때문에 부모에서 자식으로만 state를 props로 전달할 수 있고, 자식의 props를 부모에게 직접 전달할 수는 없다.

자식에서 부모의 상태를 바꾸려면 해당 상태를 컨트롤하는 함수를 props로 넘겨주어야 한다.

하지만 이것이 반복되다 보면 엄청난 `props drilling`이 발생하게 된다는 문제가 있다. 프로젝트의 규모가 커질수록 props의 뎁스가 증가하게 되고, 이는 불필요한 리렌더링을 유발할 수도 있다.

리덕스가 나오기 이전, 리액트를 포함한 대부분의 프로젝트는 `MVC 아키텍쳐(Model-View-Controller)`가 많이 사용되었다. 컨트롤러가 여러 모델을 제어하고, 모델과 뷰가 서로 바라보는 구조로, 모델가 뷰가 양방향으로 영향을 미쳐 프로젝트 규모가 커질 수록 상태관리가 복잡하고 어렵다.

<img src="https://media.vlpt.us/images/danmin20/post/9b658196-ee2e-466f-9d45-2bcb943b7614/image.png">

이러한 문제를 해결하기 위해 페이스북이 내놓은 새로운 아키텍쳐가 `Flux 아키텍쳐`이다.

데이터의 흐름이 단방향으로 흐르는 구조이다.

<img src="https://media.vlpt.us/images/danmin20/post/28783b5d-fe8c-4a5f-9834-358ffea74922/image.png">

---

# 🆚 제어 컴포넌트 && 비제어 컴포넌트

## 🔖 제어 컴포넌트

제어 컴포넌트란 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트하는 방식의 컴포넌를 말합니다.

```js
export default function App() {
  const [input, setInput] = useState('');
  const onChange = (e) => {
    setInput(e.target.value);
  };

  return (
    <div className="App">
      <input onChange={onChange} />
    </div>
  );
}
```

## 🔖 비제어 컴포넌트

바닐라 자바스크립트처럼 필드에서 값을 트리거해서 얻는 방식을 의미합니다.

```js
export default function App() {
  const inputRef = useRef(); // ref 사용
  const onClick = () => {
    console.log(inputRef.current.value);
  };

  return (
    <div className="App">
      <input ref={inputRef} />
      <button type="submit" onClick={onClick}>
        전송
      </button>
    </div>
  );
}
```

상태를 가지고 그리는 것이 아니기 때문에 컴포넌트간의 유기적인 연결이 어렵다.

---

# 🏷 useState(세터함수)의 사용 이유

리액트의 동작방식을 생각해보면 간단하다.

상태는 객체인데 리액트의 동작 방식을 생각해보면 세터함수를 이용하지 않고 직접 변경 하는 것은 불변성을 지키지 않는 것이기도 하고, 비교할 객체를 생성하지 않았기 떄문에 라이프 사이클에서 업데이트 단게로 넘어가지 않아 리렌더링이 일어나지 않기때문이다.

---

# 🏷 리액트의 메모이제이션

`메모이제이션`은 동일한 계산을 반복해야 할 때, 이전 계산 값을 메모리에 저장하여 반복 수행을 제거하는 기술입니다.

리액트에서 이런 메모이제이션이 쓰인 것은 크게 3가지가 있습니다.

1. memo
2. useMemo
3. useCallback

---

# 📚 React 렌더링 성능 최적화

컴포넌트의 리렌더링 조건은 다음과 같다.

- 부모에서 전달받은 props가 변경될때
- 부모 컴포넌트가 리렌더링 될 때
- 자신의 state가 변경 될 때

## 🔖 최적화 방법 1. useMemo

디펜던시로 걸어놓은 녀석이 변하지 않을 경우 함수 호출을 새로하지 않고 기존의 반환된 값을 사용하는 방식

리턴되는 값을 메모이제이션하여 활용한다.

```js
useMemo(() => func, [input_dependency]);
```

## 🔖 최적화 방법 2. React.memo 컴포넌트 메모이제이션

React.memo는 Hook이 아니기 때문에 어디서든 사용이 가능하다.

컴포넌트의 props가 바뀌지 않았다면, 리렌더링 하지 않도록 설정하여 리렌더링 성능의 최적화를 노릴 수 있다.

```js
// export 구문에 추가하면 된다.
export default memo(Item);
```

React.memo()로 래핑되면, React는 컴포넌트를 렌더링하고 결과를 메모이징한다. 이후 렌더링이 일어날 떄 props가 같으면, 메모이징된 값을 재사용하는 방식.

## 🔖 최적화 방법 3. useCallback

useMemo는 리턴되는 값을 메모이제이션 한다면, useCallback은 `함수의 선언`을 메모이제이션 한다.

## 🔖 최적화 방법 4. props로 객체를 넘겨줄 경우 변형하지 말기

props를 전달할 때 객체 리터럴이나 생성자 함수로 전달하는 것은 객체를 새롭게 생성하기 때문에 데이터의 가공이 필요하다면 state를 넘겨 데이터 가공을 하위 컴포넌트에서 진행하는 방식으로 코드를 짜야한다.

## 🔖 최적화 방법 5. 컴포넌트 매핑시에 key값으로 idnex 사용하지 않기

무조건 적은 아니나 배열의 요소에 필터링, 정렬 삭제, 추가등의 기능이 들어간다면 사용하지 않는 것이 좋다.

## 🔖 최적화 방법 6. useState의 함수형 업데이트 방식

```js
// 예시) 삭제 함수
const onRemove = useCallback(
  (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  },
  [todos],
);

// 예시) 함수형 업데이트 후
const onRemove = useCallback((id) => {
  setTodos((todos) => todos.filter((todo) => todo.id !== id));
}, []);
```

위와 같이 사용하면 useCallback의 디펜던시 값을 생략할 수 있다.(React useCallback 부분에도 정리해놓은 내용)

## 🔖 최적화 방법 7. Input의 onChange 최적화

lodash라는 최적화 라이브러리를 사용하여 보통의 onChange 이벤트에 상태를 변경시켜 타이핑마다 컴포넌트의 렌더링을 방지하기도 한다.

---

# Redux가 무엇인가?

리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜서 효율적으로 관리할 수 있다.

<img src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif">

## 액션(Action)

액션은 type 필드를 가지는 자바스크립트 객체이며 어떤 일이 일어났는지를 설명하는 이벤트이다.

`type(어떤 액션인지)`과 `payload(데이터)`를 프로퍼티로 갖는다.

액션은 디스패치(Dispatch)를 통해 리듀서(Reducer) 함수로 보내지며 기존의 state를 기반으로 새로운 state를 만든다.

## 디스패치(Dispatch)

디스패치(Dispatch)는 액션을 리듀서(Reducer) 전달합니다.

이벤트를 발생시키는 역할을 합니다.

## 리듀서(Reducer)

리듀서(reducer) 함수는 기존의 state와 action을 받아서 새로운 state를 만들어내는 함수입니다.

## 루트리듀서

리덕스는 하나의 스토어만을 사용하기 때문에 리듀서가 여러개 존재하는 경우 루트 리듀서라는 리듀서를 만들어 하나의 리듀서로 병합한다.

## 👍 장점

- Redux는 오직 하나의 스토어만을 가지고 하나의 객체 트리를 만들기 때문에 개발 확장성 및 디버깅에 강점이 있습니다.

- 스토어 내부의 상태는 action 객체에 의해서만 변경될 수 있습니다. 모든 상태 변화들이 하나의 store에 집중되어 있고, 단방향성을 갖기 때문에 항상 예측 가능한 결과를 낳게 됩니다.

## 👎 단점

- 배우기가 어렵습니다.
- 큰 보일러 플레이트를 가집니다.(라이브러리 안썼을 때, ex : 리듀스 생성시)

라이브러리를 사용하면 사용하는 문법또한 간단해진다. -> 배우기 어려운건 변함없음.

## 리덕스 미들웨어(Reudx middleWare)란?

`리덕스 미들웨어`는 액션을 디스패치(Dispatch)했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업을 실행할 수 있게 해줍니다. 액션과 리듀서 사이의 중간자라고 볼 수 있습니다.

전달받은 액션을 단순히 콘솔에 기록하거나, 전달받은 액션 정보를 기반으로 액션을 아예 취소하거나, 다른 종류의 액션을 추가하는 등 다양한 역할을 담당할 수 있습니다.

```js
const loggerMiddleware = store => next => action => {
  //기본 구조
}

export default loggerMiddleware;
const loggerMiddleware = function loggerMiddleware(store){
  return function(next){
    return function(action){
      //기본 구조
    }
  }
}

export default loggerMiddleware;
```

함수를 반환하는 함수를 반환하는 함수입니다.

## 🏷 reudx-toolkit(리덕스 툴킷)

redux의 동작 구조(라이브러리가 없을 때)

1. 액션타입 정의
2. 액션 함수 정의
3. 리듀서 정의

말했듯이 redux만으로는 너무 큰 보일러 플레이트가 발생하므로 redux-action을 사용하였고, 불변성을 유지하기 위해 immer를, 비동기를 수월하게 하기 위해 thunk나 saga를 사용하여 기존의 단점들을 보완하였습니다.

문제는 벌써 4개의 라이브러리를 설치해야 위의 기능을 사용할 수 있는데 reudx에서 공식적으로 만든 라이브러리인 redux-tookit이 saga를 제외한 기능을 모두 지원합니다.

---

# 🏷 SPA(Single Page Application) 이란?

## 🔖 배경

SPA를 설명하려면 과거의 웹 사이트에 대해 설명할 필요가 있다.

과거 웹사이트는 지금보다 문서 하나에 전달되는 파일의 용량이 적었다. 어떤 요소를 한번 클릭하면 완전히 새로운 페이지를 서버에서 전송해 주곤 했다.

그러나 현대에 이르러 한 페이지에 해당하는 페이지 용량이 커졌고, 매번 새로운 페이지를 전달하는게 버거워졌다.

## 🔖 그래서 `SPA`란?

이러한 문제를 해결하기 위해 등장한 것이 SPA. 어떤 웹사이트의 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현하는 것이 SAP이다.

뭔가를 클릭하거나 스크롤하면, 상호작용하기 위한 최소한의 요소만 변경이 일어난다.

'페이지 변경이 일어난다고 보여지는 것' 또한 최초 로드된 자바스크립트를 통해 미리 브라우저에 올라간 템플릿만 교체되는 것이다.

## 🔖 SPA 프레임워크가 하는 일

SPA 프레임워크로 유명한 Angular, React, Vue가 하는 일은 세부적인 구현 개념은 전부 다르지만, 그 목적은 모두 SPA를 쉽고 확장성 있게 구현하는 것을 목표로 Virtual DOM이라는 개념을 사용해 SPA를 구현한다.

SPA의 문제점은 자바스크립트로 인한 DOM 조작이 빈번하게 일어나 브라우저의 성능을 저하신킨다는 것이다.

Virtual DOM을 사용하는 프레임워크들은 실제 DOM 트리를 흉내 낸 가상의 객체 트리로 html 정보를 저장하고 있다가, 이 트리에 변경이 발생하면 모든 변화를 모아 단 한번 브라우저를 호출해 화면을 갱신하는 방법을 사용한다. 이렇게 하면 브라우저와의 불필요한 상호작용을 최소화하면서 인터렉티브한 웹 사이트를 만드는 것이 가능하다.

---

# Recoil

페이스북에서 내놓은 새로운 상태관리 라이브러리.

리코일은 아톰과 셀렉터로 이루어져 있ㄹ다.
아톰은 상태의 단위로, 유니크한 키값으로 구분된다. 해당 아톰을 구독하고 있으면 해당 컴포넌트들만 선택적으로 리렌더링된다.

다만 아직 버전이 낮아 안정성 측면에서 낮고, DevTool이 미흡하다고 한다.

# Context API

리액트가 자체적으로 가지고 있다. 정적인 데이터 위주로 처리하거나 업데이트가 빈번하지 않을 떄 적합하다.

Provider-Consumer의 구조로 상태를 주고 받는데, Provider 하위의 모든 Consumer는 Provider의 속성이 변경될 때마다 리렌더링 된다는 단점이 존재한다.

useMemo나 useReducer와 함께 사용하면 좋은 코드 작성이 가능할 것 같다.

# 🆚 함수형 컴포넌트 && 클래스형 컴포넌트 차이점

## 🔖 함수형 컴포넌트

- JSX를 return문을 사용해서 반환한다.
- state를 Hook을 이용하여 사용해야 한다
- 생명 주기 함수 작성 불가

## 🔖 클래스형 컴포넌트

- class 키워드로 시직한다
- render() 함수를 사용해 JSX를 반환한다
- props 조회시 this키워드 사용해야한다

---

# 생명주기 메소드 || 라이프 싸이클 메소드 (LifeCycle Method)

생명주기 메소드 or 라이프 싸이클 메소드는 컴포넌트가 브라우저상에 나타나고, 업데이트되고, 사라지게 될 때 호출되는 메소드 입니다.

물론 클래스형 컴포넌트에서만 사용이 가능하고, Hooks 에서의 useEffect와 비슷하게 동작한다. 함수형이 권장되는 오늘날 사용할 일들이 거의 없는 메소드들이기도 하다.

---

# 🚩 CSS

# 🏷 margin && padding

margin은 테두리 외부 요소에 공간을 만드는데 사용되고

padding은 테두리 내부 요소에 공간을 만드는데 사용됩니다.

# 🏷 position

position 속성은 문서 상에 요소를 배치하는 방법으로 여러 키워드 값을 가집니다.

- static : 요소를 문서의 흐름에 따라 배치합니다.
- relative : 자기 자신을 기준으로 Offset 을 적용합니다.
- absolute : 요소를 일반적 문서 흐름에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않습니다. 가장 가까운 조상요소에 대해 상대적으로 배치합니다.

---

# ETC

# TypeScript에 대해서 사용해봤는가? 어떻게 생각하는가?

정적 타이핑과 동적 타이핑의 관점에서 다소 의견이 분분하고 나또한 사용하진 않은 입장으로써 뭐가 더 나은지는 감히 말하기 힘들다.

허나 정적 타입을 지원함으로써 코드 안정성이 올라가는 측면은 짧은 소견으로도 동의하는 바입니다. 공부할 계획.

---

# 🚩 Vue
