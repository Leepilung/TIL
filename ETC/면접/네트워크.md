<style>
    h1 {
        border-bottom : none;
    }
</style>

# 네트워크

# HTTP 메소드

> 주요 메소드들

-   GET : 리소스 조회
-   POST : 요청 데이터 처리, 주로 데이터 등록에 사용 body 태그 활용
-   PUT : 리소스를 대체, 해당 리소스가 없으면 생성
-   PATCH : 리소스를 일부만 변경
-   DELETE : 리소스 삭제

> 기타 메모리 코드

# HTTP 상태코드

-   1xx (Informational): 요청이 수신되어 처리중
-   2xx (Successful): 요청 정상 처리
-   3xx (Redirection): 요청을 완료하려면 추가 행동이 필요
-   4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
-   5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

# 🏷 리다이렉트(Redirect)란?

말 그대로 다시 지시 하는 것을 의미합니다.

예를 들어 네이버 카페의 특정 글은 카페에 가입을 해야만 볼 수 있는데 이러한 접근에 대하여 권한이 없다고 할 경우 카페에 가입하는 창으로 이동시키거나 네이버 계정에 로그인이 안되어 있을 때 로그인 페이지나 회원가입 페이지로 리다이렉트 시킬 필요가 있습니다.

# 🏷 HTTPS란 ?

-> 2번 물어봄. 굉장히 중요하다.

HTTPS는 http의 `보안 취약점`을 해결하기 위한 프로토콜.

기본 골격이나 사용 목적등은 HTTP와 거의 동일하지만, 데이터를 주고 받는 과정에 '보안'요소가 추가된 것으로 `서버와 클라이언트 사이의 모든 통신 내용이 암호화`된다.

HTTPS를 사용하여 전송되는 데이터는 `TLS`를 통해 보호된다.

TLS는 `CA`라 불리는 인증서를 발급하는 기관으로부터 인증서를 발급받아 서버에 적용시킨다.

`인증서`는 사용자가 접속한 서버가 우리가 의도한 서버가 맞는지를 보장하는 역할을 한다.

-   🔖 TLS란?

    TLS(Transport Layer Security)란 암호화 보안 프로토콜이다. 기본 목표는 개인정보 보호, 데이터 무결성, 인증, 디지털 인증서를 사용하는 인증을 제공하는 것이다.

-   🔖 서드파티(third party) 란?

    하드웨어나 소프트웨어 등의 제품을 제조하고 있는 주요 기업이나 그 계열 회사 또는 기술 제휴를 하고 있는 기업이 아닌 `제3자 기업`을 부르는 말이다. 간략히 제3자 또는 3차 협력사라고도 한다.

## 📗 암호화 방식

`공개키 암호화 방식`과 공개키의 느리다는 단점을 보완한 `대칭키 암호화 방식`을 함께 사용한다.

공개키 방식으로 대칭키를 전달하고, 서로 공유된 대칭키를 가지고 통신하게 된다.

-   🔖 공개키 방식

    -   A키로 암호화를 하면 B키로 복호화를 할 수 있다.

    -   B키로 암호화를 하면 A키로 복호화를 할 수 있다.

    -   둘 중 하나를 `비공개키(Private Key)`혹은 `개인키`라 부르며, 자신만 가지고 있고 공개되지 않는다.

    -   나머지 하나를 `공개키(Public Key)`라고 부르며 타인에게 제공한다. 공개키는 유출이 되어도 비공개키를 모르면 복호화 할 수 없기 때문에 안전하다.

    -   구현이 어렵고 서버비용이 많이듦

        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F9943623359FF02B1056ED8">

-   🔖 대칭키 방식

    -   동일한 키로 암호화, 복호화가 가능하다.
    -   대칭키는 매번 랜덤으로 생성되어 안전하다.
    -   공개키보다 빠르게 통신할 수 있다.

    -   탈취시 모든 정보를 뺏길 가능성이 큼.

인증서는 사용자가 접속한 서버가 우리가 의도한 서버가 맞는지를 보장하는 역할을 한다.

## 동작 방식 (매우 중요)

<img src="https://t1.daumcdn.net/cfile/tistory/99F0FA445C456BB809">

1. 인터넷 사이트(서버)는 공개키와 개인키를 만들고, 신뢰할 수 있는 인증 기관(CA)에 자신의 정보와 공개키를 관리해달라고 계약하고 (경우에 따라) 돈을 지불한다.

2. 이 때, 계약을 완료한 인증 기관은 기관만의 공개키와 개인키가 있다. 인증 기관은 사이트가 제출된 데이터를 검증하고, 인증 기관의 개인키로 사이트에서 제출한 정보를 암호화해서 인증서를 만들어 제공한다. 사이트는 인증서를 가지게 되었다.

3. 인증 기관은 웹 브라우저에게 자신의 공개키를 제공한다

<img src="https://t1.daumcdn.net/cfile/tistory/993364345C457AED30">

4. 사용자가 사이트에 접속하면 서버는 자신의 인증서를 웹 브라우저(클라이언트)에게 보낸다. 예를 들어, 웹 브라우저가 index.html 파일을 달라고 요청했다면, 서버의 정보를 인증 기관의 개인키로 암호화한 인증서를 받게 되는 것이다.

5. 웹 브라우저는 `3.`에서 미리 알고 있던 인증기관의 공개키로 인증서를 해독하여 검증한다. 그러면 사이트의 정보와 서버의 공개키를 알 수 있게 된다.

    - 이 부분은 보안상의 의미는 없다. 단지 해당 서버로부터 온 응답임을 확신할 수 있게 된다.

6. 이렇게 얻은 서버의 공개키로 대칭키를 암호화해서 다시 사이트에 보낸다.

7. 사이트는 개인키로 암호문을 해독하여 대칭키를 얻게 되고, 이제 대칭키로 데이터를 주고받을 수 있게 된다.

<img src="https://t1.daumcdn.net/cfile/tistory/9997354E5C457AF229">

-   대칭키란 ?

    대칭 키 암호는 암호화 알고리즘의 한 종류로, 암호화와 복호화에 같은 `암호 키`를 쓰는 알고리즘을 의미한다.

        대칭 키 암호는 암호화를 하는 측과 복호화를 하는 측이 같은 암호 키를 공유해야 한다. ( 공개 키 암호에서는 공개 키와 비밀 키를 별도로 가지는데 이와는 구별되는 방식.) 공개 키 암호와 비교했을 때 속도가 빠르다는 장점을 가진다.

## 👍 HTTPS의 장점

-   HTTPS는 웹사이트의 무결성을 보호해준다. 즉 웹 사이트와 사용자 브라우저 사이의 통신을 침입자가 건드리지 못하도록 한다.

-   HTTPS는 침입자가 웹사이트와 사용자 사이의 통신을 몰래 수신하는 것을 방지함으로써 보안을 강화해준다.

## 👎 HTTPS의 단점

-   모든 사이트에서 텍스트를 암호화해서 주고 받으면 과부하가 걸려 속도가 느려질 수 있다.

-   HTTPS를 지원한다고 해서 무조건 안전한 것은 아니다. 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문이다.

---

# 🏷 GET , POST의 차이

`GET`은 클라이언트에서 서버로 정보를 요청하기 위해 사용되는 메소드입니다.

`POST`는 클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용 되는 메소드입니다.

## 🔖 GET 요청과 POST 요청의 차이점은?

1. GET 요청은 캐시가 가능합니다. (POST는 캐시가 안됨)
2. GET 요청은 브라우저 기록에 남습니다. (POST는 안남음)
3. GET 요청에는 길이 제한이 있습니다. (POST는 길이 제한 없음)
4. GET 요청을 북마크에 추가할 수 있습니다. (POST는 불가능)
5. GET 요청은 데이터를 요청할때만 사용 됩니다.
6. GET 요청은 중요한 정보를 다루면 안됩니다(파라미터에 다 노출되어 버리기 때문)

-   사용목적 : GET은 데이터를 요청, POST는 서버의 리소스 생성이나 업데이트에 사용.

-   요청에 body 유무 : POST에만 존재.

---

# TCP와 UDP의 차이점은?

`TCP`는 연결 동작을 통해 `ACK`와 `Sequence Number`를 주고받으며 신뢰성과 흐름제어를 제공한다.

-   `ACK`란?

    ACK, 응답 문자, 승인 코드(acknowledgement code)는 승인을 서명하거나, 응답을보내기 위해, 통신 프로토콜의 일부로서 통신 프로세서나 컴퓨터 사이를 지나가는 신호이다.

    어떠한 컴퓨터가 네트워크를 통해 `일련의 자료를 다른 컴퓨터로 성공적으로 전송했을 때, 전송을 받은 컴퓨터가 전송을 해 준 컴퓨터에게 보내는 신호`로 정의된다. 이는 수신측 컴퓨터가 `준비 완료`의 뜻을 알리는 신호이기도 하다.

-   `Sequence Number` 란?

    TCP에서는 데이터를 보낼때 마다 각 데이터에 고유한 번호를 부여해서 전송을 시도한다. 이 고유한 번호가 바로 Sequence Number이다.

    데이터를 한번씩 전송할 때마다 이 번호가 1씩 증가하게 된다.

    0 ~ 232-1까지 값을 가지게 되는 유한한 값으로 최고값인 232-1 에 도달하면 다시 0 부터 시작한다. ( 2^32 modulo )

    이 일련번호를 이용하여 수신측에서는 `중복된 자료는 폐기`하고, 순서가 바뀌어서 수신되는 경우 이를 순서대로 재구성할 수 있게 된다.

반면에 `UDP 방식`은 IP를 거의 그대로 사용하며 단순히 `Checksum`말고는 데이터의 훼손등을 감지할 수 없다. 또한 ACK와 Sequence Number를 주고받지 않으므로 중간에 데이터가 유실되어도 이를 다시 요청하거나 할 수 있는 방법이 없다.

-   Checksum 이란?

    체크섬(cehcksum)이란 중복 검사의 한 형태로, 통신에서 자료의 무결성을 보호하는 단순한 방법이다.

# TCP란 무엇인가?

데이터의 송수신을 위해 IP를 이용하는 프로토콜이다. 통신간에 신뢰성을 보장하기 위해 만들어졌다.

`TCP`는 3-way handshake라고 불리는 연결 동작과 4-way handshake라고 불리는 연결 종료를 통해 ACK와 Sequence Number를 주고 받아 데이터 흐름의 신뢰성을 구축한다.

# 🏷 브라우저에서 주소창에 url을 입력시 어떤일이 일어나는가?

1. 브라우저의 주소창에 url을 입력한다.
2. DNS 확인하여 IP주소를 찾는다. (없다면 DNS resolver를 통해 IP주소를 알아낸다)
3. 브라우저가 서버와 TCP 연결을 시작한다.
4. 브라우저가 웹 서버에 HTTTP 요청을 보낸다.
5. 서버가 요청을 처리하고 응답을 되돌려보낸다.
6. 브라우저는 서버가 보낸 HTML 내용을 표시한다.

# 🏷 LocalStorage, SessionStorage, Cookie 의 차이점

로컬 스토리지, 세션 스토리지 전부 브라우저의 window 객체 안에 들어있다.

근본적인 차이로 `로컬 스토리지`, `세션 스토리지`는 서버로 데이터통신이 이뤄지지 않고 `쿠키`는 매 순간마다 데이터 통신이 이뤄진다.

## 🔖 Local Storage

클라이언트에 저장됨. 네트워크 트래픽 비용 감소. 만료기간 설정이 없다.

## 🔖 Cookie

매번 서버로 전송해야 합니다. 개수와 용량에 제한이 존재. 하나의 사이트에 20개의 쿠키 제한, 용량또한 4KB. 만료일자 도달시 제거됩니다.

## 🔖 Session

SessionStorage는 데이터가 브라우저를 종료할때 사라집니다.

---

# 🏷 DNS란 무엇인가?

`도메인 이름 시스템`(DNS = Domain Network System)은 `사람이 읽을 수 있는 도메인 이름`을 `기계가 읽을 수 있는 IP주소(ex : 192.0.2.44)`로 변환합니다.

스마트폰부터 노트북까지 모든 인터넷상의 컴퓨터는 숫자를 사용한 주소(IP 주소)를 이용하여 서로를 찾고 통신합니다.

한마디로 DNS 서비스는 우리가 사용하는 주소들을 IP주소의 입력이 아닌 example.com고 같은 도메인 이름을 입력해도 서로 통신할 수 있게 해주는 시스템입니다.

---

# 🏷 CORS란?

교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)라고 번역되기도 하고 브라우저에서 다른 `출처`의 리소스를 공유하는 방법을 의미하기도 한다.

위에서 다른 출처의 `출처`가 무엇인지를 우선 살펴봐야 한다.

## 🔖 URL 구조

<img src="https://beomy.github.io/assets/img/posts/browser/url.png">

프로토콜의 HTTP는 80번, HTTPS는 443번 포트를 사용하는데, 이 80번, 443번 포트는 생략이 가능하다.

## 🔖 출처(Origin)란?

`출처(Origin)`란 URL 구조에서 살펴본 Protocal, Host, Port를 합친 것을 의미합니다.

브라우저 개발자 도구의 콘솔 창에 `location.origin`을 실행하면 출저를 확인할 수 있습니다.

## 🔖 같은 출처 VS 다른 출처

`Protocal(ex : https://)`이나 `Host(ex : github.io)`나 `Port(Host 바로 뒤에 붙는 :443 or :3000 )`중 하나라도 다르다면 서로 다른 출처를 의미합니다.

## 🔖 CORS 동작 원리

단순 요청 방법과 예비 요청을 먼저 보내는 방법 2가지 방법이 있다.

### 동작 방법 1. 단순 요청(Simple request) 방법

단순 요청 방법은 서버에게 바로 요청을 보내는 방법입니다.

<img src="https://beomy.github.io/assets/img/posts/browser/cors_simle_request.png">

단순 요청은 서버에 API를 요청하고, 서버는 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에게 보낸다. 브라우저는 Access-Control-Allow-Origin 헤더를 화인해서 CORS 동작을 수행할지 판단한다.

### Simple request 조건

서버로 전달하는 요청(request)이 아래의 3가지 조건을 만족해야 서버로 전달하는 요청이 단순 요청으로 동작한다.

1. 요청 메소드(method)는 GET, HEAD, POST 중 하나여야 한다.
2. ccept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안된다.
3. Content-Type 헤더는 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나를 사용해야 한다.

첫 번째 조건은 어렵지 않은 조건이지만 2번, 3번 조건은 까다로운 조건이다.
2번 조건은 사용자 인증에 사용되는 Authorization 헤더도 포함되지 않아 까다로운 조건이며, 3번 조건은 많은 REST API들이 Content-Type으로 application/json을 사용하기 때문에 지켜지기 어려운 조건이다.

### 동작 방법 2. 예비 요청(Preflight request) 방법

Preflight 요청은 서버에 예비 요청을 보내서 안전한지 판단한 후 본 요청을 보내는 방법

<img src="https://beomy.github.io/assets/img/posts/browser/cors_preflight_request.png">

GET, POST, PUT, DELETE 등의 메소드로 API를 요청했는데, 크롬 개발자 도구의 네트워크 탭에 OPTIONS 메소드로 요청이 보내지는 것을 본 적이 있다면 CORS를 경험한 것.

Preflight 요청은 실제 리소스를 요청하기 전에 OPTIONS라는 메소드를 통해 실제 요청을 전송할지 판단한다.

OPTIONS 메소드로 서버에 예비 요청을 먼저 보내고, 서버는 이 예비 요청에 대한 응답으로 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보낸다. 브라우저는 단순 요청과 동일하게 Access-Control-Allow-Origin 헤더를 확인해서 CORS 동작을 수행할지 판단한다.

## CORS 에러 해결 방법

앞에서의 CORS 동작 원 리를 보면, 서버에서 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보내는 방식으로 CORS 에러를 해결할 수 있다. 프론트엔드 개발자가 CORS 에러를 확인했다면, 서버에 Access-Control-Allow-Origin 등 CORS를 해결하기 위한 몇 가지 응답 헤더를 포함해 달라고 요청해야 한다.

Node.js의 Express는 cors라는 서드 파트 미들웨어를 지원한다. 이 라이브러리에서 CORS 응답 헤더를 추가해 주기 때문에, 개발자가 별도의 CORS 응답 헤더를 추가해 주지 않아도 된다. 다른 프레임워크에서도 CORS를 해결해 주는 라이브러리가 존재한다.

### 1. HTTP 응답 헤더 방식

라이브러리를 사용하면 간단하게 CORS를 해결할 수 있지만, 응답 헤더를 이용한 방식또한 존재한다.

굉장히 양이 방대하므로 [링크](https://beomy.github.io/tech/browser/cors/) 를 참조하자.

### 2. HTTP 요청 헤더 방식

CORS를 위해서, 브라우저에서 서버로 요청하는 헤더를 살펴보는 방식이다. 요청 헤더는 별도로 명시해 주지 않아도 브라우저에서 OPTIONS 요청에 추가한다.

### 3. JSONP or 프록시 방식

JSONP(JSON with Padding)는 `<script>` 요소가 외부 출처 리소스를 가져올 수 있는 특징을 사용하는 방법이고

프론트엔드와 백엔드 사이에 프록시 서버를 두는 방법으로도 CORS를 해결할 수 있다.

개발 환경에서 CORS를 해결해야 한다면, Webpack Dev Server 등의 라이브러리를 사용해서 프록시 설정을 하는 방법도 있다.

# 동일 출처 정책(Same-Origin-Policy)란?

Postman으로 APi를 테스트하거나, 다른 서버에서 API를 호추할 때에는 멀쩡히 잘 동작하다가 브라우저에서 API를 호출할 때에 CORS Policy오류가 발생하는 경우가 있다.

그 이유는 브라우저가 동일 출처 정책(Same-Origin Policy, SOP)를 지켜서 다른 출처의 리소스 접근을 금지하기 때문이다. 하지만 실제로 웹페이지는 상당히 자주 다른 출처의 리소스를 사용해야 한다.

예를 들어 leepilung.github.io라는 도메인 주소를 사용하는 웹페이지에서 leepilung.github.io라는 API 서버로 데이터를 요청해서 화면을 그린다면 이 웹페이지는 동일 출처 정책을 위반한 것이 된다.

## 동일 출처 정책의 장점

동일 출처 정책을 지키면 외부 리소스를 가져오지 못해 불편하지만, 동일 출처 정책은 `XSS`나 `XRSF` 등의 보안 취약점을 노린 공격을 방어할 수 있다.

-   XSS

사이트간 스크립팅(XSS - cross-site scripting)은 웹 애플리케이션에서 주로 나타는 취약점으로 웹사이트 관리자가 아닌 이가 웹페이지에 악성 스크립트를 삽입할 수 있는 취약점이다.

-   XSRF or CSRF

사이트 간 요청 위조(CSRF,XSRF - Cross-site request forgery)는 웹사이트 취약점 공격의 하나로, 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격을 말한다.

하지만 현실적으로는 외부 리소스를 참고하는 것은 필요하기 때문에 외부 리소스를 가져올 수 있는 방법이 존재해야 한다. 외부 리소스를 사용하기 위한 SOP의 예외 조항이 CORS이다.
