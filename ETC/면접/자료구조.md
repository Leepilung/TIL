<style>
    h1 {
        border-bottom : none;
    }
</style>

# 알고리즘 면접 질문

# 정렬 알고리즘(Sorting Algorithm)

## Sorting Algorithm에서 stable 하다는 것은 무엇을 의미하는가 ?

`stable`하다는 의미는 동일한 요소가 있을 때 정렬 전의 순서와 정렬 후의 순서가 동이함을 보장하는 것을 의미한다.

예를 들어 `[{k: 4, v: 1}, {k: 3, v: 2}, {k: 3, v: 1}, {k: 2, v: 1}, {k: 5, v: 1}]` 을 stable한 sorting algorithm을 이용한다면

똑같은 형태인 `[{k: 2, v: 1}, {k: 3, v: 2}, {k: 3, v: 1}, {k: 4, v: 1}, {k: 5, v: 1}]`가 된다. (k가 3인 동일한 정렬 기준을 가진 요소가 2개가 있지만 input된 순서 그대로 정렬되었다.)

## 정렬 알고리즘의 가짓수가 많은 이유는 무엇인가?

> 📜 정렬 알고리즘 시간복잡도 및 공간 복잡도 도표

<img src="https://github.com/qkraudghgh/coding-interview/raw/master/Interview/question/sorting.png">

1. 정렬 알고리즘마다 예상되는 속도가 전부 다르다.

2. 문제별로 시간 복잡도나 공간 복잡도등을 다르게 고려해야 하기 때문.

## 퀵 정렬이란?

퀵 정렬은 분할-정복 패러다임을 이용해 정렬을 수행하는 정렬 알고리즘이며 그 중에서도 Partitioning 이라는 아이디어를 이용한다.

-   Partitioning이란?
    특정 요소(Pivot element)를 기준으로 왼쪽에는 Pivot보다 작거나 같은 요소, 오른쪽에는 Pivot보다 크거나 같은 요소를 모으는 것을 의미한다.

퀵정렬은 Partitioning을 재귀적으로 반복하여 정렬을 완료한다.

---

# 🏷 Dynamic Programming이란?

동적 계획법이라고도 부르며 한 마디로 큰 문제를 작은 문제로 나누어 푸는 문제를 일컫는 말이다.

분할 정복과 비슷하게 보일 수 있지만 결정적 차이는 분할 한 작은 문제들이 중복으로 일어나지 않는다는 점(즉 반복되지 않는다는 것)이다.

이때문에 작은 문제의 반복이 일어나는 경우 메모이제이션을 이용해 작은 문제를 저장해놓는다.

2개의 구현방법이 존재한다.

1. Bottom-up
   작은 문제부터 차근차근 구해나가는 방법이다.

문제의 해결은 쉬워지지만 가독성이 저하되는 문제점.

2. Top-down
   재귀함수로 구현해야 하는 경우가 대부분 이케이스에 해당한다.

큰 문제를 해결할 때 작은 문제가 해결되지 않으면 그때서야 작은 문제를 해결하는 방법.

가독성이 증가된다는 장점이 있지만 그만큼 작성이 비교적 힘들다,

O(N)

---

# 🆚 스택(Stack) && 큐(Queue)의 차이

## 🏷 스택(STACK)

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fby1qnT%2FbtqBE1v1UlX%2FzbnXdYnGAXhMYbcDCca6WK%2Fimg.png">

`스택`이란 쌓아 올린다는 것을 의미하며 `LIFO(Last In First Out)` `후입 선출의 원리`로 책을 쌓듯이 `쌓아 올린 형태의 자료구조`를 의미한다.

> 활용 예시

-   웹 브라우저 방문 기록(뒤로 가기)
-   역순 문자열
-   실행 취소(undo 기능)

### 🔍 코드 구현(스택)

```js
class Stack {
    constructor() {
        this.arr = [];
        this.index = 0;
    }
    push(item) {
        this.arr[this.index++] = item;
    }
    pop() {
        if (this.index <= 0) return null;
        const result = this.arr[--this.index];
        return result;
    }
}
```

## 🏷 큐(Queue)

사전적 의미 그대로 줄, 혹은 줄을 서서 기다린다는 의미와 같이 `FIFO(First In First Out) 선입 선출의 원리`로 이뤄진 자료구조이다.

스택과는 달리 한쪽 끝에서는 삽입이, 다른 한쪽 끝에선 삭제 작업이 양쪽으로 이뤄진다.

이때 삭제 연산만 수행되는 곳을 프론트(front), 삽입연산만 이뤄지는 곳을 리어(rear)로 정하여 각각의 연산만을 수행한다.

보통 큐의 리어에서 이뤄지는 삽입연산을 인큐(enQueue), 프론트에서 이뤄지는 삭제연산을 디큐(deQueue)라고 부른다.

---

# 🆚 리스트(List)와 배열(Array)의 차이

## 🏷 배열(Array)

-   데이터가 많아지고 그룹으로 묶어 관리할 필요성이 있기 때문에 배열을 사용한다.

-   고정된 크기를 갖는 같은 자료형의 원소들이 연속적인 형태(논리적 저장 순서와 물리적 저장 순서가 일치하는 형태)로 구성된 자료구조이다.

    -   인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게되어 메모리가 낭비된다.

    -   처음 크기를 10으로 지정하면 5개의 데이터만 지정해도 실제 배열 크기는 여전히 10이다.

-   캐시 히트(Cache hit) 가능성이 높아 성능에 큰 도움이 된다.

    -   캐시 히트(Cache hit)란 ?
        CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있는 경우를 말한다.

-   데이터의 갯수가 확실하게 정해져있고, 접근이 빈번한 경우에 효율적

-   고정이고 연속적인 만큼 인덱스를 활용하여 random access가 가능하다.

    -   접근, 수정이 O(1)의 시간복잡도로 빠르게 조회가 가능하다.

-   하지만 삽입과 삭제의 경우 연속적인 형태를 유지하기 위해 shift연산을 해야 하므로 O(N)의 시간복잡도를 갖는다.

## 🏷 리스트(List) or 링크드 리스트(Linked List)

-   배열의 문제점을 해결하기 위한 자료구조

-   빈틈없는 데이터의 적재가 가능하다(장점)

    -   원소를 삭제했을 때 삭제된 데이터 뒤 원소로 빈틈없이 연속적으로 위치시킨다.

-   리스트의 핵심은 원소들 간의 순서로 순서가 있는 데이터의 모임이다. 다른 이름으로 시퀀스(sequence)라고도 부른다.

-   배열에서 인덱스는 유일무이한 식별자이지만, 리스트에서는 몇 번째 데이터인지 정도의 의미만을 가진다.

-   빈 엘리먼트를 허용하지 않는다.

-   순차성을 보장하지 못하여 캐시 히트(cache hit)가 어렵다.

*   단점

원하는 위치를 Search하는 과정에 이어서 첫번째 원소부터 전부 다 확인해봐야 한다. 이러한 과정 때문에 O(n)의 시간복잡도를 갖는다.

결국 탐색과 삽입, 삭제에 있어서도 O(N)의 시간복잡도를 갖는다.

---

# 트리(Tree)

그래프의 한 종류로써 방향성이 있는 비순환 그래프

트리는 스택과 큐와는 다른 비선형 자료구조이다. 트리는 계층적 관계를 표현하는 자료구조이다.

트리는 표현에 집중되있는 자료구조임을 기억하자.

-   트리의 구성 요소(용어)

    -   Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
    -   Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
    -   Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
    -   Terminal Node ( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
    -   Internal Node( 내부노드, 비 단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.

# 이진 트리(Binary Tree)

루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 진다.

# 그래프(Graph)

-   노드와 노드간을 연결하는 간선으로 구성된 자료 구조
-   연결되있는 객체 간의 관계를 표현할 수 있는 자료 구조

## 특징

-   노드간에 2개 이상의 경로도 가능하다.
-   부모 - 자식 관계라는 개념이 없다.
-   그래프는 순환, 비순환 구조를 이룬다.
-   그래프는 방향성이 있는 그래프와 방향성이 없는 그래프가 있다.

# 트리(Tree)와 그래프(Graph)의 차이점

|              |                             그래프                             |                             트리                              |
| :----------: | :------------------------------------------------------------: | :-----------------------------------------------------------: |
|     정의     |      노드와 그 노드를 연결하는 간선으로 구성된 자료 구조       |         그래프의 한 종류, 방향성이 있는 비순환 그래프         |
|    방향성    |                     방향, 무방향 모두 존재                     |                      방향 그래프만 존재                       |
|    사이클    |      순환, 비순환 모두 존재, 노드 한개의 자체 순환도 가능      |                     비순환 그래프만 존재                      |
|  루트 노드   |                    루트 노드의 개념이 없음                     |                  한 개의 루트 노드만이 존재                   |
|  부모-자식   |                    부모-자식의 개념이 없음                     |       루트 노드를 제외한 노드는 1개의 부모노드만을 가짐       |
|     모델     |                         네트워크 모델                          |                           계층 모델                           |
|     순회     |                            DFS, BFS                            |             DFS, BFS 방식의 전위, 중위, 후위 순회             |
|  간선의 수   |               간선의 개수는 자유, 없을수도 있음                |       N개의 노드를 가진 트리는 항상 N-1개의 간선을 가짐       |
|     경로     |                                                                |                임의의 두 노드 간의 경로는 유일                |
| 예시 및 종류 | 지도, 지하철 노선도의 최단 경로, 전기 회로의 소자들, 선수 과목 | 이진 트리, 이진 탐색 트리, 균형 트리(Red-Black 트리), 이진 힙 |
