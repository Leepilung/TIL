# 알고리즘 면접 질문

# 정렬 알고리즘(Sorting Algorithm)

## Sorting Algorithm에서 stable 하다는 것은 무엇을 의미하는가 ?

`stable`하다는 의미는 동일한 요소가 있을 때 정렬 전의 순서와 정렬 후의 순서가 동이함을 보장하는 것을 의미한다.

예를 들어 `[{k: 4, v: 1}, {k: 3, v: 2}, {k: 3, v: 1}, {k: 2, v: 1}, {k: 5, v: 1}]` 을 stable한 sorting algorithm을 이용한다면

똑같은 형태인 `[{k: 2, v: 1}, {k: 3, v: 2}, {k: 3, v: 1}, {k: 4, v: 1}, {k: 5, v: 1}]`가 된다. (k가 3인 동일한 정렬 기준을 가진 요소가 2개가 있지만 input된 순서 그대로 정렬되었다.)

## 정렬 알고리즘의 가짓수가 많은 이유는 무엇인가?

📜 정렬 알고리즘 시간복잡도 및 공간 복잡도 도표
<img src="https://github.com/qkraudghgh/coding-interview/raw/master/Interview/question/sorting.png">

1. 정렬 알고리즘마다 예상되는 속도가 전부 다르다.

2. 문제별로 시간 복잡도나 공간 복잡도등을 다르게 고려해야 하기 때문.

## 퀵 정렬이란?

퀵 정렬은 분할-정복 패러다임을 이용해 정렬을 수행하는 정렬 알고리즘이며 그 중에서도 Partitioning 이라는 아이디어를 이용한다.

-   Partitioning이란?
    특정 요소(Pivot element)를 기준으로 왼쪽에는 Pivot보다 작거나 같은 요소, 오른쪽에는 Pivot보다 크거나 같은 요소를 모으는 것을 의미한다.

퀵정렬은 Partitioning을 재귀적으로 반복하여 정렬을 완료한다.

# Dynamic Programming이란?

동적 계획법이라고도 부르며 한 마디로 큰 문제를 작은 문제로 나누어 푸는 문제를 일컫는 말이다.

분할 정복과 비슷하게 보일 수 있지만 결정적 차이는 분할 한 작은 문제들이 중복으로 일어나지 않는다는 점(즉 반복되지 않는다는 것)이다.

이때문에 작은 문제의 반복이 일어나는 경우 메모이제이션을 이용해 작은 문제를 저장해놓는다.

2개의 구현방법이 존재한다.

1. Bottom-up
   작은 문제부터 차근차근 구해나가는 방법이다.

문제의 해결은 쉬워지지만 가독성이 저하되는 문제점.

2. Top-down
   재귀함수로 구현해야 하는 경우가 대부분 이케이스에 해당한다.

큰 문제를 해결할 때 작은 문제가 해결되지 않으면 그때서야 작은 문제를 해결하는 방법.

가독성이 증가된다는 장점이 있지만 그만큼 작성이 비교적 힘들다,

O(N)

# 리스트(List)와 배열(Array)의 차이

# 배열(Array)

-   데이터가 많아지고 그룹으로 묶어 관리할 필요성이 있기 때문에 배열을 사용한다.

-   고정된 크기를 갖는 같은 자료형의 원소들이 연속적인 형태(논리적 저장 순서와 물리적 저장 순서가 일치하는 형태)로 구성된 자료구조이다.

    -   인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게되어 메모리가 낭비된다.

    -   처음 크기를 10으로 지정하면 5개의 데이터만 지정해도 실제 배열 크기는 여전히 10이다.

-   캐시 히트(Cache hit) 가능성이 높아 성능에 큰 도움이 된다.

    -   캐시 히트(Cache hit)란 ?
        CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있는 경우를 말한다.

-   데이터의 갯수가 확실하게 정해져있고, 접근이 빈번한 경우에 효율적

-   고정이고 연속적인 만큼 인덱스를 활용하여 random access가 가능하다.

    -   접근, 수정이 O(1)의 시간복잡도로 빠르게 조회가 가능하다.

-   하지만 삽입과 삭제의 경우 연속적인 형태를 유지하기 위해 shift연산을 해야 하므로 O(N)의 시간복잡도를 갖는다.

# 리스트(List)

-   배열의 문제점을 해결하기 위한 자료구조

-   빈틈없는 데이터의 적재가 가능하다(장점)

    -   원소를 삭제했을 때 삭제된 데이터 뒤 원소로 빈틈없이 연속적으로 위치시킨다.

-   리스트의 핵심은 원소들 간의 순서로 순서가 있는 데이터의 모임이다. 다른 이름으로 시퀀스(sequence)라고도 부른다.

-   배열에서 인덱스는 유일무이한 식별자이지만, 리스트에서는 몇 번째 데이터인지 정도의 의미만을 가진다.

-   빈 엘리먼트를 허용하지 않는다.

-   순차성을 보장하지 못하여 캐시 히트(cache hit)가 어렵다.

*   단점

원하는 위치를 Search하는 과정에 이어서 첫번째 원소부터 전부 다 확인해봐야 한다. 이러한 과정 때문에 O(n)의 시간복잡도를 갖는다.

결국 탐색과 삽입, 삭제에 있어서도 O(N)의 시간복잡도를 갖는다.
