운영체제와 네트워크는 분리되어있음.

Device driver -> 배우는걸 구현하는 노가다에 불과함. 현실적으로 가장 많은 부분을 잡아먹는 부분

# 운영체제를 왜배워야하는가?

file I/O system 살면서 현실적으로 다룰일이 거의없음.

운영체제는 앞으로 살아가면서 실무에서 절대 필요하지 않을 확률이 높음. 그러나 거의 모든 대학에서 전공필수인 과목

mmap -> 가상메모리의 주소를 리턴받는 시스템콜 // 1 << 20 -> 1MB 

캐시 

퍼포먼스 디버깅을 어느정도 할 줄 알아야 함.

페이지 폴트라고 부르는 에러가 어떤식으로 발생하는지 까진 이해할 필요가 없음. 어느 부분에서 오는 데이터가 어떤 속도로 처리되는지를 안다면 영역을 특정 시킬 수 있기 때문.

운영체제에 대한 백그라운드를 알면 좋지만 그걸 넘어가는 무언가가 있다.

코드가 40~50만줄, 디바이스 드라이버까지 합치면 100만줄을 넘어간다.

그러나 크롬등은 100만줄을 훨씬 넘어가고 더 복잡하지만 크롬을 교육시키진 않는다.

---

운영체제에 대한 지식도 좋지만, design principle에 대해 배울 수 있다.

특정 에러가 왜발생하는 지가 중요한지 아니라 그 에러를 어떻게 출력시키는지를 디자인 한것에 집중해야 한다는 것이다.

디자인 레밸에 대한 정보를 가르쳐야한다는 취지로 설립된 과목.(system design principle)

학부생들에게 디자인만 가르치면 굉장히 뜬구름잡는듯한 기분이 드는 경우가 많다.

고로 크게 2가지로 요약하면

1. 기본적인 백그라운드를 알아야 어떻게 돌아가는지 알 수 있다.

2. 이러한 디자인 패턴을 공부를 해봐야 다른 어떠한 것을 개발하던 여기서 배운 디자인을 활용할 수 있다.


# 운영체제는 왜 필요한가?

초창기에 OS는 없었다.

1960년대에는 때문에 모든 소프트웨어가 하드웨어를 직접적으로 다루도록 프로그래밍 되었었다.

때문에 이를 보완하기위해 OS에 대해 개발할 필요가 있었다.

# 운영체제의 역할

1. abstractions을 어떻게 디자인했는지
2. Protection & Isolation 을 어떻게 구현했는지
3. 리소스 쉐어링을 OS가 어떻게 구현했는지


# abstraction이란 무엇인가?

process or outcome -> ignoring some of details 

    어느정도 디테일을 날려도 이해하는데 있어서 매우 쉬워지는것.

하드웨어의 디테일을 숨기는 것에 해당된다.


# 운영체제에서 가장 중요한 하드웨어 3가지

 각 하드웨어 3가지를 추상화하면 다음과 같다.

1. CPU -> CPU를 추상화

2. Memory -> 가상 주소 공간

3. Storage -> file이란 형태 사용

# OS 디자이너의 첫 생각

프로그램을 쉽게하고, 유닛으 실행을 관리하고, 유닛의 실행을 보호하려는 이 3가지 개념을 추상화 시키면 무엇이 나올 것인가 -> process의 탄생 비화

- 10페이지 빈칸 machine

## 11p

각각의 프로세스는 서로 다른 주소로 이뤄져있음.(왼쪽 AS~)

AS에 속한 주소공간과 OS에 속한 주소공간을 서로 다르게 분리해야한다.

운영체제는 때문에 이 프로세스의 가상주소와 DRAM의 실제 주소를 매핑해주는 역할을 한다.

# 12p

어떻게 매핑하는가?

- Segmentation
- Paging
- Segmentation Paging


# 15p

메모리를 언제 할당하는가?

앱이 비할당 물리 메모리에 처음 만나면 멈춘다. -> 페이지를 할당하고 -> free page list에서 페이지를 가져온다. -> 페이지를 0으로 초기화시킨다. -> 페이지 테이블과 페이지를 매핑한다.

왜 페이지를 할당할때 0으로 초기화시킬까? -> 페이지는 요청받아서 해당 공간을 다시 반환할 때 초기화 한채로 주지않는다. 이미 데이터가 씌여진 상태이기 때문에 이를 초기화 시켜주는 것.

해커 들이 페이지 프리 리스트에서 덫붙이기를 가장 많이사용한다.

# 16p

메모리 타입 두가지 -> file-back and annymous

stack , heap은 반드시 0으로 초기화

data, text 영역은 있는 그대로 가져온다.


# 18p

데이터 스트럭쳐를 기본으로 꿰고있어야함. -> 얘가 장단점이 무엇인지, 캐쉬로케이트, 구조등을 완전히 말할 수 있어야함


EXT2, EXT3 ->  indirect inode(table)

EXT4 -> extent tree

Nts -> Btree


# 21p

스토리지가 훨씬 복잡해지고 연구를 많이한다.

스토리지는 느리다. 그러나 한번 실행하고나면 빠르다(DRAM)에 적재해두기 때문.

# 22p

buffer cache -> page cache로 이름이 변경되었다.

데이터안에 있는 내용들을 페이지 캐시에 저장한다.

EXT2, NFS, minix등의 파일 시스템등을  하나로 묶는 가상의 파일 시스템이 존재한다.(VFS) 

VFS가 왜존재하는가? -> VFS가 있음으로써 생기는 장점은 추상화이다. 한마디로 VFS는 복잡한 개별 파일 시스템에 대한 추상화를 묶어서 하는 역할이라고 보면 된다.

- Layer of abstraciton 

이 단어를 기억하자. 

- page fault 기억

3가지 관점 이야기에서

파일 시스템의

퍼시스턴스

저널링, 메타데이터 등 공부하기.