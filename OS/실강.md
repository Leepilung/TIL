운영체제와 네트워크는 분리되어있음.

Device driver -> 배우는걸 구현하는 노가다에 불과함. 현실적으로 가장 많은 부분을 잡아먹는 부분

# 운영체제를 왜배워야하는가?

file I/O system 살면서 현실적으로 다룰일이 거의없음.

운영체제는 앞으로 살아가면서 실무에서 절대 필요하지 않을 확률이 높음. 그러나 거의 모든 대학에서 전공필수인 과목

mmap -> 가상메모리의 주소를 리턴받는 시스템콜 // 1 << 20 -> 1MB

캐시

퍼포먼스 디버깅을 어느정도 할 줄 알아야 함.

페이지 폴트라고 부르는 에러가 어떤식으로 발생하는지 까진 이해할 필요가 없음. 어느 부분에서 오는 데이터가 어떤 속도로 처리되는지를 안다면 영역을 특정 시킬 수 있기 때문.

운영체제에 대한 백그라운드를 알면 좋지만 그걸 넘어가는 무언가가 있다.

코드가 40~50만줄, 디바이스 드라이버까지 합치면 100만줄을 넘어간다.

그러나 크롬등은 100만줄을 훨씬 넘어가고 더 복잡하지만 크롬을 교육시키진 않는다.

---

운영체제에 대한 지식도 좋지만, design principle에 대해 배울 수 있다.

특정 에러가 왜발생하는 지가 중요한지 아니라 그 에러를 어떻게 출력시키는지를 디자인 한것에 집중해야 한다는 것이다.

디자인 레밸에 대한 정보를 가르쳐야한다는 취지로 설립된 과목.(system design principle)

학부생들에게 디자인만 가르치면 굉장히 뜬구름잡는듯한 기분이 드는 경우가 많다.

고로 크게 2가지로 요약하면

1. 기본적인 백그라운드를 알아야 어떻게 돌아가는지 알 수 있다.

2. 이러한 디자인 패턴을 공부를 해봐야 다른 어떠한 것을 개발하던 여기서 배운 디자인을 활용할 수 있다.

# 운영체제는 왜 필요한가?

초창기에 OS는 없었다.

1960년대에는 때문에 모든 소프트웨어가 하드웨어를 직접적으로 다루도록 프로그래밍 되었었다.

때문에 이를 보완하기위해 OS에 대해 개발할 필요가 있었다.

# 운영체제의 역할

1. abstractions을 어떻게 디자인했는지
2. Protection & Isolation 을 어떻게 구현했는지
3. 리소스 쉐어링을 OS가 어떻게 구현했는지

# abstraction이란 무엇인가?

process or outcome -> ignoring some of details

    어느정도 디테일을 날려도 이해하는데 있어서 매우 쉬워지는것.

하드웨어의 디테일을 숨기는 것에 해당된다.

# 운영체제에서 가장 중요한 하드웨어 3가지

각 하드웨어 3가지를 추상화하면 다음과 같다.

1. CPU -> CPU를 추상화

2. Memory -> 가상 주소 공간

3. Storage -> file이란 형태 사용

# OS 디자이너의 첫 생각

프로그램을 쉽게하고, 유닛으 실행을 관리하고, 유닛의 실행을 보호하려는 이 3가지 개념을 추상화 시키면 무엇이 나올 것인가 -> process의 탄생 비화

- 10페이지 빈칸 machine

## 11p

각각의 프로세스는 서로 다른 주소로 이뤄져있음.(왼쪽 AS~)

AS에 속한 주소공간과 OS에 속한 주소공간을 서로 다르게 분리해야한다.

운영체제는 때문에 이 프로세스의 가상주소와 DRAM의 실제 주소를 매핑해주는 역할을 한다.

# 12p

어떻게 매핑하는가?

- Segmentation
- Paging
- Segmentation Paging

# 15p

메모리를 언제 할당하는가?

앱이 비할당 물리 메모리에 처음 만나면 멈춘다. -> 페이지를 할당하고 -> free page list에서 페이지를 가져온다. -> 페이지를 0으로 초기화시킨다. -> 페이지 테이블과 페이지를 매핑한다.

왜 페이지를 할당할때 0으로 초기화시킬까? -> 페이지는 요청받아서 해당 공간을 다시 반환할 때 초기화 한채로 주지않는다. 이미 데이터가 씌여진 상태이기 때문에 이를 초기화 시켜주는 것.

해커 들이 페이지 프리 리스트에서 덫붙이기를 가장 많이사용한다.

# 16p

메모리 타입 두가지 -> file-back and annymous

stack , heap은 반드시 0으로 초기화

data, text 영역은 있는 그대로 가져온다.

# 18p

데이터 스트럭쳐를 기본으로 꿰고있어야함. -> 얘가 장단점이 무엇인지, 캐쉬로케이트, 구조등을 완전히 말할 수 있어야함

EXT2, EXT3 -> indirect inode(table)

EXT4 -> extent tree

Nts -> Btree

# 21p

스토리지가 훨씬 복잡해지고 연구를 많이한다.

스토리지는 느리다. 그러나 한번 실행하고나면 빠르다(DRAM)에 적재해두기 때문.

# 22p

buffer cache -> page cache로 이름이 변경되었다.

데이터안에 있는 내용들을 페이지 캐시에 저장한다.

EXT2, NFS, minix등의 파일 시스템등을 하나로 묶는 가상의 파일 시스템이 존재한다.(VFS)

VFS가 왜존재하는가? -> VFS가 있음으로써 생기는 장점은 추상화이다. 한마디로 VFS는 복잡한 개별 파일 시스템에 대한 추상화를 묶어서 하는 역할이라고 보면 된다.

- Layer of abstraciton

이 단어를 기억하자.

- page fault 기억

3가지 관점 이야기에서

파일 시스템의

퍼시스턴스

저널링, 메타데이터 등 공부하기.

# 1 / 3

파일에 대한 정보의 총집합 -> 파일 메타데이터
우리가 쓰는 메타데이터와 우리가 쓰는 메타데이터가

DRAM과 Device 사이의 데이터 사이에 consistency가 다를 수 있다.

데이터를 저장할 때 2개의 조건을 만족해야한다.

Atomicity -> 데이터가 부분적으로 저장되면 안된다. 반만 된 경우 이걸 복구할 수 없다. 때문에 시스템은 데이터를 전부 저장하거나 아예 안하거나 두 개의 케이스로 나뉜다.

Durability -> 데이터가 반드시

하드디스크는 4kb가 기본단위 이다.

파일 시스템 저장할 때 크래쉬가 발생한다.

\*\* 이를 해결하는 방법이 undo와 redo 두 가지가 있다. -> 각 방법의 특징(장단점)은 어느정도 숙지하고 있어야함.

> 29p

두개의 파일을 덮어씌우는 구문이 있다면

fsync로 두개의 파일구문을 싱크시켜야 한다.

문제는 이때 디렉토리 별로 fsync해줘야 한다.

예로 creat

```c
creat(/a/log)
write(/a/log, “Foo”)
fsync(/a/log)  // 바로 아래 fsync(/a)와 순서가 바뀌어도 무관함.
fsync(/a/)     // 그러나 fsync(/a/file)아래로 들어갈 경우엔 에러가 발생한다.
write(/a/file, “Bar”)
fsync(/a/file)
 unlink(/a/log)
```

OS는 탑다운 방식으로 하는게 맞다고 생각

Memory 측면, 파일측면

# 프로텍션

- 인스트럭션을 분리해야 한다.

- 어플리케이션이 다른 어플리케이션의 메모리로부터 읽기 쓰기를 행하는걸 막아야 한다.

- OS가 어플리케이션으로부터 control을 다시 얻어야 한다.(timer interrupt)

# Prvilege

-> CPU가 제일 높은데 CPU -> 하드웨어인걸 까먹음.

- HW vs SW. who has more privilege?
  무조건 하드웨어가 더 높음

> Segmentaion fault

sig segv 라는 신호가 있는데 이걸 cpu가 어플리케이션에게 보낸다.

즉 그말은 이러한 신호를 sig가 컨트롤 하고, 이러한 처리를 하는 핸들러가 있따는 것이다.

sig segv핸들러는 lib.c에 구현되어 있음.

ldd /bin/ls 입력시 아래와 같이 나온다.
linux-vdso.so.1 (0x00007ffdc4dda000)
libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f30873e3000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3086ff2000) // 이러한 애들은 gcc가 전부 처리해준다.
libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f3086d80000)
libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f3086b7c000)
/lib64/ld-linux-x86-64.so.2 (0x00007f308782d000) // lib.c를 링크해주는 녀석
libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f308695d000)

중요한건 어떠한 신호가 핸들러르 거쳐서 어플리케이션으로 오면 어플리케이션이 이를 처리한다는 것이다.

# A Philosoph of software Design / Jhon Qusterhout / Talks at Google

## read write 인터페이스

-> 가장 잘만들어진 deep interface

file is everything 을 만족하는 완벽한 인터페이스.

# Reference Monitor

OS는 하드웨어를 총괄하는 Reference Monitor 이다.

# LRU

유튜브 패턴 -> LRU를 절대 사용하지 않음

앞에서 배운 프로텍션, 아이솔레이션 등을 어떻게 구성할 것인가에 따라

1. Monolithic Kernel

2. Microkernel

3. Exokernel 등으로 나뉜다.

지금 배우는 OS 공부가 컴퓨터 자체를 이루는 근간이면서 공부를 함에 있어서 현재 OS를 매우 얕게 배운다는 느낌을 느낀다.

허나 오늘날 흔히 말하는 개발자는 프론트와 백으로 나뉘는데

# 웹 어플리케이션과 OS의 연관 관계

-> PHP등을 이용하여 개발할 떄 어떤식으로 무언가를 나누고 기능을 분할하고 할 때 어떻게 개념을 abstraction을 행하는지,

이러한 abstraction을 통해서 디자인 하는지에 대해 선행 학습한다? 라는 그런 느낌이다.

한마디로 OS의 디자인 패턴을 통해 웹어플리케이션의 개발 디자인 패턴을 메타인지 한다라는 느낌으로 생각하면 될 것 같다.
