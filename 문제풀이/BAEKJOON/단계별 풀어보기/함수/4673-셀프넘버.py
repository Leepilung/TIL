# 백준 알고리즘 - 함수 - 4673.셀프 넘버
# https://www.acmicpc.net/problem/4673
# 생성자가 없는 숫자를 셀프 넘버라고 한다. 10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.
# 생성자란 n(ex = 33)이 주어졌을 때 33 + 3 + 3 = 39 -> 39 + 3 + 9 = 51 과같이 수열을 만들 수 있는 숫자들이다.
# 생성자가 없다는 것은 저런 생성자로 만들어질수 없는 숫자를 의미한다.

# * 복기할 부분 *
# 접근법은 비슷했으나 풀이과정이 아예 글러먹었던 알고리즘.
# 우선 문제에서 주어지는 입력이 아예없어서 매개변수가 없는 함수로 접근했으나 이것도 올바른 접근이 아님.
# 함수 양식을 아예 안줬으면 함수양식을 쓰면 안됬던것. -> 근대 왜 함수 카테고리에 들어가있는지 의문
# 딕셔너리 -> 스택을 활용한 접근법을 사용했었으나 시간만 버리고 통과실패
# set함수 이용하여 중복값을 삭제시키고 원본숫자에서 생성자로 생성될 수 있는 모든 숫자를 구해서 빼는 방식 사용해야함.
# 

Nums = set(range(1,10001))
newNums = set()

for i in range(1, 10001):
    for j in str(i):
# 위와 같이 사용하면 i =1, j=1이고, 10일땐 i = 10 j = 1, 0 이런식으로 연산됨.
        i += int(j) # 그렇기 때문에  61이면 61 + 6 + 1 과 같이 연산됨.
    newNums.add(i)  # 이렇게 생성자로 생성된 값을 newNums에 추가.

selfNumber = sorted(Nums - newNums) # selfnumber는 기존 숫자배열 - 생성자로 생성된 숫자로 구한다.
for i in selfNumber:
    print(i)


# 다른 풀이
# 풀이에 걸리는 시간이 압도적으로 길다.(in, not in 사용해서 배열 순회하면서 검색해서 그런듯)
# 풀이 시간만 따져도 압도적으로 위의 풀이가 낫다.ㅠㅠ 그래도 직접푸는데 성공.


def selfNumber ():
    e = []
    for i in range(1,10001):
        N = i
        for j in str(i):
            N += int(j)
        if N not in e:
            e.append(N)
        if i not in e:
            print(i)

selfNumber()
