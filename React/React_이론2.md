# React 이론 정리2

복습용으로 최대한 축약하여 이해하는데 있어 어색함이나 부족함 없게끔 정리하는 것이 목표.

# 이벤트 핸들링

사용자가 웹 브라우저에서 DOM 요소들과 상호 작용하는 것을 `이벤트(event)`라고 한다.

예를 들어 버튼에 마우스 커서를 올렸을 때는 onmouseover 이벤트를 실행하고, 클릭했을 때는 onclick 이벤트를 실행하는 것, Form 요소가 값이 바뀔 때 onchange 이벤트를 실행하는 것들이 해당된다.

## React에서 이벤트를 사용할 때 주의 사항

> 1. 이벤트 이름은 카멜 표기법으로 작성한다.

예를 들어 HTML의 onclick은 리액트에서는 onClick으로 작성해야 한다.

> 2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달한다.

HTML에서 이벤트를 설정할 때는 큰따옴표 안에 실행할 코드를 넣었지만, 리액트에서는 함수 형태의 객체를 전달한다.

화살표 함수 문법으로 함수를 만들어 전달해도 되고, 렌더링 부분 외부에서 만들어서 전달해도 된다.

> 3. DOM 요소에만 이벤트를 설정할 수 있다.

div, button, input, form, span 등의 DOM 요소에는 이벤트를 설정할 수 있지만, 우리가 직접 만든 컴포넌트에는 이벤트를 자체적으로 설정할 수 없다.

예를 들어 다음과 같이 MyComponent에 onClick 값을 설정한다면 MyComponent를 클릭할 때 이벤트(doSomething 함수)를 실행하는 것이 아니라, 그냥 이름이 onClick인 props를 MyComponent에게 전달해 줄 뿐인 것이다.

> 📝 예시

```js
<MyComponent onClick={doSomething} />
```

따라서 컴포넌트에 자체적으로 이벤트를 설정할 수는 없다. 하지만 전달받은 props를 컴포넌트 내부의 DOM 이벤트로 설정할 수는 있다.

> 📝 예시

```js
<div onClick={this.props.onClick}>{/* (…) */}</div>
```

리액트에서 지원하는 이벤트 종류는 다음 [리액트 메뉴얼](https://facebook.github.io/react/docs/events.html)에서 확인하자.

# e 객체(이벤트 객체)

> 📝 예시

```js
onChange={
  (e) => {
    console.log(e.target.value);
  }
}
```

다음과 같은 코드에서 쓰이는 e 객체는 `SyntheticEvnet`로 웹 브라우저의 `네이티브 이벤트`를 감싸는 객체라곤 하는데 저 두 키워드가 이해가 안간다.

네이티브 이벤트와 인터페이스가 같으므로 순수 자바스크립트에서 HTML 이벤트를 다룰 때와 똑같이 사용하면 된다고 한다.

아무튼 이벤트가 끝나고 나면 이벤트가 초기화되므로 정보를 참조할 수 없다. 예를들어 0.5초 뒤에 e 객체를 참조하면 e 객체 내부의 모든 값이 비워지게 된다.

# ref

일반적으로 HTML에서 DOM 요소에 이름을 달 때는 id를 사용한다.

> 📝 예시

```html
<!-- HTML의 경우 -->
<div id="“my-element“"></div>
```

이와 같이 특정 DOM 요소에 어떤 작업을 해야 할 때 id를 달면 CSS에서 특정 id에 특정 스타일을 적용하거나 자바스크립트에서 해당 id를 가진 요소에 작업하기도 한다.

리액트 프로젝트 내부에서 DOM에 이름을 다는 방법이 있는데 바로 ref(reference의 줄임말) 개념이다.

> 🔍 리액트 컴포넌트 안에서 id를 사용하면 안될까?

리액트 컴포넌트 안에서도 id를 사용할 수는 있다. JSX안에서 DOM에 id를 달면 DOM을 렌더링할 떄 그대로 전달된다. 그러나 특수한 경우가 아니면 사용을 권하지 않는다고 한다.

예를 들어 같은 컴포넌트르 여러번 사용한다고 가정하면 HTML에서 DOM의 id는 유일해야 하는데 컴포넌트는 재사용 가능성을 염두에 두기 때문에 중복 id를 가진 DOM이 여러개 생기기 때문이다.

ref는 전역적으로 작동하지도 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않는다.

굳이 id를 사용해야 한다면 컴포넌트를 만들 때마다 id 뒷부분에 추가 텍스트를 붙여 중복 id를 방지하면 된다.

## ref의 사용처

ref는 DOM에 작업을 해야 할 때 사용한다는 것은 알았지만 어떤 작업을 해야할 때 사용하는가에 대해 알아보자면 'DOM을 직접적으로 건드려야 할 때' 사용한다.

## DOM을 꼭 사용해야 하는 상황

가끔 state만으로는 해결할 수 없는 기능이 있다.

-   특정 input에 포커스 주기
-   스크롤 박스 조작하기
-   Canvas 요소에 그림 그리기 등

위의 상황에서는 DOM에 직접적으로 접근해야 하는데, 이를 위해 바로 ref를 사용한다.

## ref 사용방법

### 콜백 함수를 통한 ref 설정

ref를 만드는 가장 기본적인 방법은 콜백 함수를 사용하는 것이다. ref를 달고자 하는 요소에 ref라는 콜백 함수를 props로 전달해 주면 된다.

이 콜백 함수는 ref 값을 파라미터로 전달받는다. 그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해 준다. 잘 이해가 안가므로 예시를 통해 알아보자.

```js
<input
    ref={(ref) => {
        this.input = ref;
    }}
/>
```

this.input은 input 요소의 DOM을 가리킨다. 이 때 ref의 이름은 원하는 것으로 자유롭게 지정이 가능하다. DOM 타입과 관계없이 this.spuerman = ref처럼 마음대로 지정이 가능하다.

## 컴포넌트에 ref 달기

리액트에서는 컴포넌트에도 ref를 달 수 있다. 이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 쓴다.

### 사용법

```js
<MyComponent
    ref={(ref) => {
        this.myComponent = ref;
    }}
/>
```

이렇게 하면 예시에서 쓰인 MyComponent 내부의 메서드 및 멤버 변수에도 접근할 수 있다. 즉, 내부의 ref에도 접근할 수 있다(EX: myComponent.handleClick, myComponent.input 등).

## 정리

컴포넌트 내부에서 DOM에 직접 접근해야 할 때는 ref를 사용한다. 먼저 ref를 사용하지 않고도 원하는 기능을 구현할 수 있는지 반드시 고려한 후에 활용하자.

컴포넌트끼리 데이터를 교류할 때는 언제나 데이터를 부모 ↔ 자식 흐름으로 교류해야 한다. ref를 이용하여 컴포넌트끼리의 데이터 교류는 잘못된 사용이다.

뭣보다 요샌 함수형 컴포넌트가 권장사항인지라 useRef라는 HOOK 함수를 주로 이용한다.

---
