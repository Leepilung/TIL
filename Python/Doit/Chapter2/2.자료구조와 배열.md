# 자료 구조와 배열

2장에서는 자료구를 정의하고 기본 자료구조인 배열을 살펴본다.( 배열은 리스트와 튜플로 구현한다)

## 배열(Array)

배열에는 객체가 저장되며 배열에 저장된 객체 하나하나를 `원소(Element)`라고 한다. 또한 각 원소는 0,1,2 순으로 `인덱스(Index)`를 부여받는다.

배열은 생성할 때 원소의 개수를 자유롭게 지정이 가능하다.

또한 score[1],score[3]등과 같이 인덱스를 활용하여 score 원소의 1번째, 3번째 값을 바로 찾을 수 있는 것처럼 특정 값에 접근하기가 용이하다.

또한 배열 원소의 `자료형(Type)`은 int형, float형 등 어떤것도 상관이 없다. 배열에는 서로 다른 자료형을 같이 저장할 수 있으며, 배열 원소자체를 배열에 저장할 수도 있다.

---

## 리스트와 튜플

`리스트`와 `튜플`은 JumpToPython에서 한번 공부한 내용이지만 헤깔리기 쉬운 항목이므로 다시 한번 다루고 넘어가도록 하자.

---

### 1. 리스트

리스트는 원소를 변경할 수 있는 `뮤터블(mutable) list형 객체` 이다. 리스트는 연산자 [ ]안에 원소를 쉼표(,)로 구분하여 표기, 생성할 수 있다. 원소없이 []만 사용하면 빈 리스트를 생성한다.

```mm
>>> list1 = []
>>> list2 = [4,5,6]
>>> list3 = ['Code','List','Tuple',] #맨 마지막 원소엔 쉼표를 써도 된다.
```

파이썬 내장 함수인 `list()`를 사용하면 문자열이나 튜플, 다양한 자료형 객체를 원소로하는 리스트를 생성할 수 있다.

```md
> > > list4 = list('ABC') #[A,B,C] 문자열의 각문자로부터 원소 생성
> > > list4
> > > ['A', 'B', 'C']
> > > list5 = list([1,2,3]) #[1,2,3]리스트로부터 원소 생성
> > > list5
> > > [1, 2, 3]
> > > list6 = list((1,2,3,)) #[1,2,3]튜플로부터 원소 생성
> > > list6
> > > [1, 2, 3]
> > > list7 = list({1,2,3}) #[1,2,3]집합으로부터 원소생성
> > > list7
> > > [1, 2, 3]
```

특정 범위의 정수로 구성된 리스트를 만들고자 한다면 `range(),list()`함수를 조합하여 사용하면 된다.

```md
> > > list8 = list(range(7)) #[0,1,2,3,4,5,6]
> > > list8
> > > [0, 1, 2, 3, 4, 5, 6]
> > > list9 = list(range(3,8)) #[3,4,5,6,7]
> > > list9
> > > [3, 4, 5, 6, 7]
> > > list10 = list(range(3, 13, 2)) #[3,5,7,9,11]
> > > list10
> > > [3, 5, 7, 9, 11]
```

## 리스트의 Map

`map`은 리스트의 요소를 지정된 함수로 처리해주는 함수이다.

- list(`map`(함수, 리스트))
- tuple(`map`(함수, 튜플))

예를 들어 실수가 저장된 리스트가 있을 때 이 리스트의 모든 요소를 정수로 변환하려면 어떻게 해야할까?

```m
>>> a = [1.2, 2.5, 3.7, 4.6]
>>> for i in range(len(a)):
...     a[i] = int(a[i])
...
>>> a
[1, 2, 3, 4]
```

for문을 이용하여 범위를 i부터 len(a)까지 (0~4까지) 지 인덱스로 하나하나 가져와서 이를 정수형(int())으로 변환하였다.

그러나 이처럼 for문으로 매번 반복하기엔 번거로운 면이 없지않아 있다. 이럴 때 `map`을 사용하면 간편하다.

```m
>>> a = [1.2, 2.5, 3.7, 4.6]
>>> a = list(map(int, a))
>>> a
[1, 2, 3, 4]
```

a = list(map(int, a)) 한 줄로 변환이 끝난다.

map에 int와 리스트를 넣으면 리스트의 모든 요소를 int를 사용해서 변환한다.

그 다음에 list를 사용해서 map의 결과를 다시 리스트로 만들어주면 된다.

---

### 2. 튜플(Tuple)

튜플은 원소를 변경할 수 없는 `이뮤터블(immutable)`자료형이다. 튜플은 원소를 쉼표(,)로 구분하여 나열한 뒤 결합 연산자 ()로 둘러싸는 방식이다.

```md
> > > tuple = () #빈 문자열
> > > tuple
> > > ()
> > > tuple1 = 3,
> > > #(3,)출력
> > > tuple1
> > > (3,)
> > > tuple2 = (3,)
> > > #(3,)출력
> > > tuple2
> > > (3,)
```

tuple1,2처럼 원소가 1개인 경우 원소 뒤에 쉼표를 반드시 입력해야 한다.

```md
> > > ex01 = 1

# 1 튜플이 아닌 하나의 값을 가진 int형 변수

> > > ex02 = (1)

# 1 튜플이 아닌 하나의 값을 가진 int형 변수
```

튜플 뒤에 쉼표가 없으면 그냥 변수로 취급됨으로 주의해야한다.

#### 리스트와 튜플 풀어내기

리스트나 튜플의 원솟값들을 풀어 여러 변수에 대입하는 것을 `언팩(Unpack)`이라고 한다.

```mm
>>> x = [4, 5, 6]
>>> a, b, c = x
>>> a, b, c
(4, 5, 6)
```

---

### 인덱스로 원소에 접근하기

인덱스 연산자 []안에 정수값 인덱스를 지정하여 특정 원소를 정할 수 있다.

```md
> > > x = [11, 22, 33, 44, 55 , 66, 77]
> > > x[2]
> > > 33

# 리스트 x의 앞에서 3번째 원소 출력

> > > x[-3]
> > > 55

# 리스트 x의 뒤에서 3번째 원소 출력

> > > x[-4] = 3.14

# 리스트 x의 뒤에서 4번째 원소를 3.14로 덮어씌움

> > > x
> > > [11, 22, 33, 3.14, 55 ,66 ,77]
> > > x[7]

# 리스트 x에는 7번째 원소가 없어 오류가 출력됨

> > > x[7] = 3.14

# 리스트 x에는 7번째 원소가 없어 덮어씌기 불가. 오류출력됨.
```

---

### 슬라이스식으로 원소에 접근하기

리스트 또는 튜플의 원소 일부를 연속해서 일정한 간격으로 꺼내 새로운 리스트, 튜플을 만드는 것을 `슬라이스(slice)`라고 한다.

- `s[i:j]` -> `s[i]`부터 `s[j-1]`까지 나열한다.
- `s[i:j:k]` -> `s[i]`부터 `s[j-1]`까지 `k`씩 건너뛰며 나열한다.

예시)

```md
> > > s = [1, 2, 3, 4, 5, 6, 7]
> > > s[0:6] > > > [1, 2, 3, 4, 5, 6] #리스트 s의 0번째부터 5번째 원소까지 출력

> > > s[0:7] > > > [1, 2, 3, 4, 5, 6, 7] #리스트 s의 0번째부터 6번째 원소까지 출력

> > > s[0:7:2] > > > [1, 3, 5, 7] #리스트 s의 원소를 0번째부터 7번째까지 2씩 건너뛰며 원소 출력

> > > s[-4:-2] > > > [4, 5] #리스트 s의 뒤에서 4번째 원소부터 뒤에서 2번째 원소까지 출력

> > > s[3:1]
> > > [] #리스트 s의 j값(1)이 i값(3)보다 작지만 오류가 나지는 않는다.
```

- `s = [1, 2, 3, 4, 5, 6, 7]`이라고 가정 할 때

| 패턴    |                            설명                             | 실행 예  |    실행 결과    |
| ------- | :---------------------------------------------------------: | :------: | :-------------: |
| s[:]    |             리스트 s의 원소를 모두 출력합니다.              |   s[:]   | [1,2,3,4,5,6,7] |
| s[:n]   |    리스트 s의 원소 중 맨 앞에서부터 n개까지 출력합니다.     |  s[:3]   |     [1,2,3]     |
| s[i:]   |      리스트 s의 원소 중 s[i]부터 맨 끝까지 출력합니다.      |  s[3:]   |    [4,5,6,7]    |
| s[-n:]  |    리스트 s의 원소 중 맨 끝에서부터 n개까지 출력합니다.     |  s[-3:]  |     [5,6,7]     |
| s[::k]  | 리스트 s의 원소 중 맨 앞에서부터 k개씩 건너뛰며 출력합니다. |  [s::2]  |    [1,3,5,7]    |
| s[::-1] |      리스트 s의 원소 중 맨 끝에서부터 전부 출력합니다.      | [s[::-1] | [7,6,5,4,3,2,1] |

> 튜플 , 리스트 함수의 len

```m
`a = [1, 31, 3.14, [11, 22 ,33], 'Tuple']`

>>> len(a)
5
```

리스트 안에 리스트나 문자열로 되있는 경우는 각각 1개로 친다.

### 등가성과 동일성

파이썬은 값을 비교할 때 `등가성(equality)`과 `동일성(idenity)`를 사용한다.

`등가성(equality)`은 ==를 사용하고 좌변과 우변의 값이 같은지를 비교한다.

`동일성(idenity)`은 is를 사용하고 값은 물론 객체의 식별번호까지 같은지를 비교한다.

## 내포 표기 생성

리스트 안에서 for, if 문을 사용하여 새로운 리스트를 생성하는 기법을 `내포 표기 생성`이라고 한다.

```m
>>>numbers = [1,2,3,4,5]
>>>twise = [num * 2 for num in numbers if num % 2 == 1]
# 리스트 numbers의 홀수 원소값을 *2한 리스트 생성.
>>>print(twise)
[2, 6, 10]
```

---

## 배열

배열을 사용하는 기본 알고리즘들에 대해 알아보자.

> 배열 원소의 최댓값 구하기

```md
#a의 원소가 3개일 때

maximum = a[0]
if a [1] > maximum : maximum = a[1]
if a [2] > maximum : maximum = a[2]
```

```md
#a의 원소가 4개일 때

maximum = a[0]
if a [1] > maximum : maximum = a[1]
if a [2] > maximum : maximum = a[2]
if a [3] > maximum : maximum = a[3]
```

위와 같이 첫번째 원소(a[0])의 값을 maximum에 대입한다. 원소의 수가 n이라면 if문은 n-1번 실행하는 것이다.

이를 파이썬 함수로 바꿔 정의내려보면

```md
def max_of(a):
for i in range (1, len(a)):
if a[i] > maximum
maximum = a[i]
```

위와 같은 형태가 될 것이다. len(a)는 배열 a의 원소 갯수를 의미한다. 그 만큼 반복해야 하기 때문에

> 시퀀스 원소의 최댓값 출력하기

```mm
# 시퀀스 원소의 최댓값 출력하기

from typing import Any, Sequence
#from ~ import는 모듈삽입문을 의미.

def max_of(a: Sequence) -> Any:
    """ 시퀀스형 a 원소의 최댓값을 반환 """
    #Any는 제약이 없는 임의의 자료형을 의미.
    #Sequence는 시퀀스형을 의미한다.
    maximum = a[0]
    for i in range(1, len(a)):
        if a[i] > maximum:
            maximum = a[i]
    return maximum

if __name__ == '__main__':
    print('배열의 최댓값을 구합니다.')
    num = int(input('원소 수를 입력하세요. : '))
    x = [None] * num
    #원소 수가 num인 리스트를 생성

    for i in range(num):
        x[i] = int(input(f'x{i}값을 입력하세요 : '))

    print(f'최댓값은 {max_of(x)}입니다.')

```

배열 a의 최댓값을 구하는 max_of() 함수를 정의한 것

또한 if 문에서 `__name__` == `'__main__'`이 같은지를 판단한다.

위 프로그램에서 if문은 max.py를 직접 시작한 경우에만(`__name__`과 `__main__`이 일치하는 경우) 참이 되어 그 아래 나머지 행을 시행할 수 있는 구조이다.

다른 스크립트 프로그램에서 `import`한 경우에는 거짓이 되므로 if문은 실행되지 않는다.

---

### 재사용할 수 있는 모듈 작성하기.

파이썬에서는 하나의 스크립트 프로그램을 `모듈(module)`이라고 한다.

확장자(.py)를 포함하지 않는 파일의 이름자체를 모듈 이름으로 사용한다. 따라서 max.py 파일의 모듈 이름은 max가 된다.

모듈 `max`로 정의된 `max_of()`함수를 다른 프로그램에서 호출해보자.

> int형 정수값을 차례로 입력받다 End를 입력하면 더 이상 입력받지 않으며 그 시점에서 원소 수를 확정하는 프로그램

```mm
from max import max_of

print('배열의 최댓값을 구합니다.')
print('주의: "End"를 입력하면 종료합니다.')

number = 0
x = []          #빈 리스트

while True:
    s = input(f'x[{number}]값을 입력하시오. : ')
    if s == 'End':
        break
    x.append(int(s)) #배열의 맨 끝에 추가
    number +=1

print(f'{number}개를 입력했습니다.')
print(f'최댓값은 {max_of(x)}입니다.')
```

모듈 `max`로 정의된 `max_of()` 함수를 사용할 수 있도록 `import` 한 예제이다.

그리고 End를 입력하면 break문이 작동하여 while문을 종료한다.

하지만 입력받은 값이 End가 아니라면 문자열을 int()함수로 변환하고 배열 x에 차례대로 추가합니다.

> 배열의 원소값을 난수로 결정하기

```md
#배열의 원소값을 난수로 결정 #배열의 원소 수, 최댓값, 최솟값은 입력받고, 최댓값과 최솟값 안에서 배열을 구성하는 원소값은 난수로 결정하는 프로그램
```

```mm
import random
from max import max_of

print('난수의 최대값을 구합니다.')
num = int(input('난수의 개수를 입력하세요. : '))
low = int(input('난수의 최솟값을 입력하세요 : '))
high = int(input('난수의 최댓값을 입력하세요 : '))
x = [None] * num        #원소수가 num인 리스트 생성

for i in range(num):
    x[i] = random.randint(low,high) #low 이상 high 이하의 정수를 난수로 반환

print(f'{(x)}')
print(f'이 가운데 최댓값은 {max_of(x)}입니다.')

```

> 튜플, 문자열, 문자열 리스트의 최댓값 구하기

```mm
# 튜플, 문자열, 문자열 리스트의 최댓값 구하기


from max import max_of

t = (10 , 20 , 3.14159, 30, 2, 1)
s = "string"
a = ['BTS', 'ABCD', 'Kyochon']

print(f'{t}의 최댓값은 {max_of(t)}입니다.')
print(f'{s}의 최댓값은 {max_of(s)}입니다.')
print(f'{a}의 최댓값은 {max_of(a)}입니다.')
```

튜플 `t`는 정수와 실수가 섞여 있으나 최댓값으로 30 출력

string이라는 문자열 `s`는 문자 가운데 가장 큰 문자코드인 t 출력

문자열 리스트 `a`는 사전순으로 가장 큰 문자열인 Kyochon을 출력한다.

## 리스트, 튜플의 대입

리스트를 2개 선언하여 서로 대입해도 원소 자체는 복사되지 않는다.
대입에서 복사되는 것은 값이 아니라 참조하는 곳이기 때문이다.

```mm
>>> list = [1,2,3,4,5]
>>> list2 = list1
>>> list1 is list2
True
>>> list1[2] = 9
>>> list1
[1,2,9,4,5]
>>> list2
[1,2,9,4,5]
```

대입식 lst2 = list1에서 lst2는 lst1(참조하는 곳의 리스트)를 참조한다.

list2와 lst1이 같은 실체(리스트[1,2,3,4,5])를 참조하는 것이다. 따라서 lst1에서 인덱스 식으로 원솟값을 바꾸면 lst2의 원솟값도 바뀐다.

> 리스트 스캔

- 실습 2C-1 : 원소 수를 LEN() 함수로 미리 알아내서 0에서 원소 수 n-1까지 반복한다.
- 실습 2C-2 : 인덱스와 원소를 짝지어 enumerate() 함수로 반복해서 꺼낸다.
- 실습 2C-3 : 실습 2C-2와 같지만 1부터 카운트 시작
- 실습 2C-4 : 인덱스값 사용하지 않고 in사용하여 원소를 처음부터 순서대로 꺼낸다.

`Enumerate()` 함수는 인덱스와 원소를 짝지어 튜를로 꺼내는 내장 함수이다.

> 2C-1 Len 함수 사용

```m
x = ['Apple', 'banana', 'kiwi', 'Orange']

for i in range(len(x)):
    print(f'x[{i}] = {x[i]}')
```

> 2C-2 enumerate() 함수 사용

```m
x = ['Apple', 'banana', 'kiwi', 'Orange']

for i, name in enumerate(x):
    print(f'x[{i}] = {name}')
```

> 2C-3 enumerate() 함수 사용

```m
x = ['Apple', 'banana', 'kiwi', 'Orange']

for i, name in enumerate(x,1):
    print(f'{i}번째 = {name}')
```

> 2C-4 모든 원소를 enumerate()함수로 스캔하기

```m
x = ['Apple', 'banana', 'kiwi', 'Orange']

for i in x:
    print(i)
```

### 배열 원소를 역순으로 정렬하기

x = [2,5,1,3,9,6,7]을 x = [7,6,9,3,1,5,2]로 바꿔보자.

2와 7, 5와 6, 1과 9만을 바꾸면 교환 횟수 자체는 원소 수 // 2 가 될 것이다.

> 뮤터블 시퀀스 원소를 역순으로 정렬

```mm
# 배열 원소를 역순으로 정렬

from typing import Any, MutableSequence

def reverse_array(a: MutableSequence) -> None:
    """ 뮤터블 시퀀스 a의 원소를 역순으로 정렬 """
    n = len(a)
    for i in range (n // 2 ):
        a[i], a[n-1-i] = a[n-1-i], a[i]

if __name__ == '__main__':
    print('배열 원소를 역순으로 정렬합니다.')
    nx = int(input('원소 수를 입력하세요 .'))
    x = [None] * nx  #원소 수가 nx개인 리스트 생성

    for i in range(nx):
        x[i] = int(input(f'x[{i}]값을 입력하시오. : '))
        #x의 원소값을 차례대로 입력받음


    reverse_array(x)    # x를 역순으로 정렬

    print('배열 원소를 역순으로 정렬했습니다.')
    for i in range(nx):
        print(f'[{i}] = {x[i]}')
```

## 기수와 서수

- `기수` : 수를 나타내는데 기초가 되며 10진법에서는 0~9까지의 정수를 말한다.
- `서수` : 사물의 순서를 나타낸다. 첫째, 둘째, 셋째 등이라고 생각하면 된다.

10진수 정수값을 입력받아 n진수로 변환하여 출력하는 프로그램을 짜보자.

```mm
#10진수 정숫값을 입력받아 2~36진수로 변환하여 출력하기

def card_conv(x=int, r=int) -> str:
    """ 정숫값 x를 r진수로 변환한 뒤 그 수를 나타내는 문자열을 반환"""

    d = ''   # 변환 후의 문자열 입력 부분
    dchar = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            #2진수~36진수까지의 문자열

    while x > 0:
        d += dchar[x % r]  # x % r 후에 해당하는 문자를 꺼내 결합
        x //= r

    return d[::-1]      #역순으로 반환
```

`card_conv()` 함수는 정수 x를 r진수로 변환, 그 수를 문자열로 반환한다.

문자열 d를 빈 문자열로 초기화한다.

while문이 포함되있는 행에서는 x를 r로 나눈 나머지를 인덱스로 하는 문자, dchar[x%r]를 문자열 d에 추가한다.

x를 r로 나눈 나머지 값 위치에 있는 문자를 d에 결합, 문자열 d의 맨 앞은 마지막으로 구한 문자가 된다.

변환된 문자열 d는 역순으로 출력해야 하므로 return문 + 슬라이스식d[::-1]을 통해 역순으로 반환시킨다.

## 뮤터블, 이뮤터블

* `뮤터블(mutable)` 1.변경가능 객체. 2.상태를 바꿀 수 있는 객체. 3.최초 생성 이후에도 자유롭게 값 변경 가능
* `이뮤터블(Imutable)` 1.변경불가 객체. 2.상태를 바꿀 수 없는 객체 3.최초 생성(인스턴스화) 이후로는 값 변경 불가

뮤터블의 대표적인 예 -> 리스트

>리스트에서 임의의 원솟값을 업데이트하기
```mm
def change(lst, idx, val):
    """list[idx]의 값을 val로 업데이트"""
    lst[idx] = val
    #함수 선언. lst[idx] = val lst의 [idx]번의 인수를 val로 바꾼다는 의미
x = [11, 22, 33, 44, 55]
print('x =', x)

index = int(input('업데이트할 인덱스를 선택하세요. : '))
value = int(input('새로운 값을 입력하세요. : '))

change(x, index, value)
#x라는 리스트에서 바꿔야 하므로 lst값은 위에서 전역설정한 리스트 x로 고정
print(f'x = {x}')
```



