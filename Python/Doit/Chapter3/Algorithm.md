# 검색 알고리즘

## 검색과 키

주소록을 검색한다고 가정해보자.

- 국적이 한국인 사람을 찾습니다.
- 나이가 21세 이상 27세 미만인 사람을 찾습니다.
- 이름에 '민'자가 들어간 사람을 찾습니다.

검색 조건들은 모두 어떠한 항목에 주목한다. 이렇게 주목하는 항목을 `키(key)`라고 한다.

국적으로 검색하는 경우 국적이 키. 나이로 검색하는 경우 나이가 키인 것이다.
대부분 `키`는 데이터의 일부이다. 데이터가 간단한 정숫값이나 문자열이면 데이터값이 그대로 키값이 될 수도 있다.

다시 말해 위의 주소록 검색 조건을 수행하려면 다음과 같이 키를 지정해야 한다.

- **국적** : 키값과 일치하도록 지정한다.
- **나이** : 키값의 구간을 지정한다.
- **문자** : 키값에 가깝도록 지정한다.

검색에서는 이러한 조건을 하나만 지정할 수도 있고 논리곱, 논리합 등을 사용해서 복합해서 지정할 수 있다.

---

# 선형 검색

`선형 검색(Linear search)`란 직선 모양(선형)으로 늘어선 배열에서 검색하는 경우 원하는 키값을 가진 원소를 찾을 때까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘이다.

> 선형 검색의 종료 조건

1. 검색할 값을 찾지 못하고 배열의 맨 끝을 지나간 경우 -> 검색 실패
2. 검색할 값과 같은 원소를 찾는 경우 -> 검색 성공

배열의 원소 개수가 n이라면 이 조건을 판단하는 횟수는 평균 n / 2 번입니다.

배열 a에서 검색하는 프로그램은 다음과 같이 나타낼 수 있다.

```m
i = 0
while True:
    if i == len(a):
        # 검색 실패
    if a[i] == key:
        # 검색 성공(찾은 원소의 인덱스는 i)

        i +=1
```

배열을 스캔할 때 주목하는 원소의 인덱스를 카운터용 변수 i로 나타냈다. i를 0으로 초기화하고 원소를 하나씩 검사할 때마다 while 문의 끝에서 1씩 증가한다.

while문을 빠져나가는 것은 앞에서 설명한 선형 검색의 종료 조건1 , 2가운데 어느 하나가 성립되는 경우이며 각 if문과 대응한다.

- 선형 검색의 종료 조건 1. if i == len(a)이 성립하면 스캔 종료.
- 선형 검색의 종료 조건 2. if a[i] == key 가 성립하면 스캔 종료.

> While문으로 작성한 선형 검색 알고리즘

```m
from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 같이 같은 원소를 선형 검색(while문)"""
    i = 0

    while True:
        if i == len(a):
            return -1       # 검색 실패하여 -1 반환
        if a[i] == key:
            return i        # 검색에 성공하여 현재 검사한 배열의 인덱스 반환
        i += 1

if __name__ == '__main__':
    num = int(input('원소 수를 입력하세요. : ')) # num값 입력받음
    x = [None] * num        # 원소 수가 num인 배열 생성

    for i in range(num):
        x[i] =int(input(f'x[{i}]: '))

    ky = int(input('검색할 값을 입력하세요.: ')) #검색할 키 ky를 입력받음

    idx = seq_search(x ,ky)        # ky와 같이 같은 원소를 x에서 검색

    if idx == -1:
        print('검색값을 갖는 원소가 존재하지 않습니다.')
    else:
        print(f'검색값은 x[{idx}]에 있습니다.')
```

`seq_search()`는 배열 a에서 값이 key인 원소를 선형 검색하는 함수이며, 찾은 원소의 인덱스를 반환한다. 값이 key인 원소가 여러개 존재 하는 경우에는 스캔 과정에서 맨처음 발견한 원소(배열에서 맨 앞의 원소)를 반환한다.

그러나 배열의 스캔을 for문으로 구현하면 코드가 더 짧고 간결해진다.
앞에서 작성한 while문을 for문으로 수정해보자

> for문으로 작성한 선형 검색 알고리즘

```mm

from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:
    """ 시퀀스 a에서 key와 같이 같은 원소를 선형 검색(for 문)"""
    for i in range(len(a)):
        if a[i] == key:
            return i        #검색 성공(인덱스를 반환)
    return -1               #검색 실패(-1을 반환)
```

> test.py파일의 seq_search()함수 사용하여 실수 검색하기

```mm
#seq_search() 함수를 사용하여 실수 검색하기
from test import seq_search

print('실수를 검색합니다')
print('주의 : "End"를 입력하면 종료합니다.')

number = 0
x = []

while True:
    s = input(f'x[{number}]')
    if s == 'End':
        break
    x.append(float(s))
    number += 1

ky = float(input('검색할 값을 입력하세요. : '))

idx = seq_search(x, ky)

if idx == -1:
    print('검색값을 갖는 원소가 존재하지 않습니다.')
else :
    print(f'검색값은 x[{idx}]에 있습니다.')

```

위에서 작업한 teset.py파일내의 함수를 import하여 사용한 프로그램이다.

## 보초법

선형검색은 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 반복하면 종료 조건을 검사하는 비용을 무시할 수 없게된다. 이 비용을 반으로 줄이는 방법이 바로 `보초법(Sentinal method)`이다.

```mm
#선형 검색 알고리즘(실습3-1)을 보초법으로 수정

from typing import Any, Sequence
import copy

def seq_search(seq: Sequence, key: Any) -> int:
   """시퀀스 seq에서 key와 일치하는 원소를 선형 검색(보초법)"""

   a = copy.deepcopy(seq)  #seq를 deepcopy 한다.
   a.append(key)           #보초 key를 추가하는 명령어

   i = 0
   while True:
       if a[i] == key:
           break
       i += 1
   return -1 if i == len(seq) else i

if __name__ : '__main__':
   num = int(input('원소 수를 입력하시오. : ')     #num값을 입력
   x = [None] * num                             # 원소 수가 num인 배열 생성

   for i in range(num):
       x[i] = int(input(f'x[{i}]'))

   ky = int(input('검색할 값을 입력하세요.: '))    # 검색할 ky를 입력받는 함수

   idx = seq_search(x, ky)                      # 키 ky값과 같은 원소를 x에서 검색

   if idx == -1:
       print('검색값을 갖는 원소가 존재하지 않습니다.')

   else:
       print(f'검색값은 x[{idx}에 있습니다.')

```

보초법을 사용한 선형 검색 알고리즘이다.

배열 seq를 a로 복사하고 a의 마지막에 보초 key를 추가한다.

보초법은 성형 검색의 종료 조건 1(값을 찾는경우)이나 종료 조건2(못찾는 경우)에나 사용 가능하며 종료 조건 1의 경우 보초법을 활용할 필요가 없다.

보초는 반복을 종료하는 판단 횟수를 크게 줄인다는 것만 기억하자.

# 이진 검색(Binary search)

이진 검색 알고리즘을 사용하려면 배열 데이터가 정렬되어있어야 한다. 이진 검색은 선형 검색보다 빠르게 검색 가능하다.

배열이 다음과 같다고 가정해보자
a = [5, 7, 15, 28, 29, 30, 35, 40, 41, 42, 48, 50, 60]
index = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

위 배열에서 41의 값을 찾는다고 가정해보자
중앙값인 a[6]=35는 찾아야할 값 41보다 작다. 이 경우 검색 범위를 a[7]~a[12]로 줄일 수 있다.

여기서 a[7]=35~a[12]=60의 범위에서 중앙값은 대략 a[9]라고 하면 a[9] =42로 찾고자 하는값 41보다 크다. 그렇다면 이경우에는 a[9]이상의 범위는 찾아볼 필요가 없게 된다.

그러다면 범위를 한번더 조정해보자 a[7]~a[9]. 이경우 중앙값인 a[8]은 41의 값과 동일하다. 이렇게 되면 찾고자하는 값이 중앙값이 되므로 찾을 수 있게된다.

이렇듯 선형검색의 경우와 다르게 검색에 걸리는 시간이 굉장히 적게 걸림을 알 수 있다.

> 이진 검색의 종료 조건

- 중앙값 (a[mid])이 key와 일치하는 경우
- 검색 범위가 더 이상 없는 경우

## 이진 검색의 경우 알고리즘을 반복할 때마다 검색 범위가 절반으로 줄어들기 때문에 필요한 검색 횟수는 평균 `log N번`이다. 검색에 실패한 경우 [`log(N+1)번`]이며 검색에 성공한 경우에는 `log N-1번`이다.

# 번외 모듈편

보통 if **name** == 과 같이 **name**은 모듈의 이름이 저장되는 변수이다. 동시에 import로 모듈을 가져오면 그 모듈의 이름이 들어가게 되는 부분이다.

하지만 파이썬 인터프리터로 직접 시행할경우 모듈의 이름이 아닌 **main**이 들어가게 된다. 이는 프로그램의 시작점을 의미하기도 한다.

즉 test3-4.py와 같이 if **name** == '**main**':처럼 **name** 변수의 값이 '**main**'인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업이다. 즉, 스크립트 파일이 메인 프로그램으로 사용될 때와 모듈로 사용될 때를 구분하기 위한 용도라고 보면 된다.

> 참고 | 파이썬은 왜 프로그램의 시작점이 정해져 있지 않은가?

파이썬이 처음에 개발 될 당시에는 리눅스/유닉스에서 사용하는 스크립트 언어 기반이었기 때문에 프로그램의 시작점이 따로 정해져 있지 않았다고 한다.

보통 리눅스/유닉스의 스크립트 파일은 파일 한 개로 이루어진 경우가 많은데, 이 스크립트 파일 자체가 하나의 프로그램이다 보니 시작점이 따로 필요하지 않는 것이다.

하지만 C 언어나 자바같은 언어는 처음 만들어질 때부터 소스 파일을 여러 개 사용했기 때문에 여러 소스 파일의 함수들 중에서도 시작 함수(main)를 따로 정해 놓는다.

---

# 복잡도

알고리즘의 성능을 객관적으로 평가하는 기준을 `복잡도(Complexity)`라고 한다.

조건은 2가지가 있다.

- 시간 복잡도 (time complexity) : 실행하는데 필요한 시간을 평가한다.
- 공간 복잡도 (space complexity) : 메모리와 파일 공간이 얼마나 필요한지 평가한다.

보통 `선형검색`의 `시간 복잡도`는 `O(n)`으로 나타낸다.
n이 점점 커지면 O(n)에 필요한 시간도 점점 비례해서 길어진다. 하지만 O(1)에 필요한 계산 시간은 변하지 않는다.

예를 들어 각 단계별 실행 횟수가 각각 1, n/2 인 선형검색이 있다고 하면 이 선형 검색의 복잡도는 o(1) + o(n/2) = o(max(1),(n/2)) 의 형태가 된다.

그리고 여기서 한가지 알아야 할 것은 복잡도에서 O(n/2)던 o(n-1)이던 복잡도는 엄청나게 큰 정수값을 넣을 경우 /2나 -1같은 계산은 그다지 중요해지지 않는다. 결국 n이라는 값에 수렴하기 때문이다.

참고로` 이진 검색`의 `시간 복잡도`는`O(logN)`이다.

대충 그래프로 표시하자면

```
작다                                             크다
<-------------------------------------------------->
1       logn    n   nlongn  n^2    n^3    n^k     2^n
```

의 형태를 이룬다.
