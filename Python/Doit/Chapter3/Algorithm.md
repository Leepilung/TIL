# 검색 알고리즘

## 검색과 키

주소록을 검색한다고 가정해보자.

- 국적이 한국인 사람을 찾습니다.
- 나이가 21세 이상 27세 미만인 사람을 찾습니다.
- 이름에 '민'자가 들어간 사람을 찾습니다.

검색 조건들은 모두 어떠한 항목에 주목한다. 이렇게 주목하는 항목을 `키(key)`라고 한다.

국적으로 검색하는 경우 국적이 키. 나이로 검색하는 경우 나이가 키인 것이다.
대부분 `키`는 데이터의 일부이다. 데이터가 간단한 정숫값이나 문자열이면 데이터값이 그대로 키값이 될 수도 있다.

다시 말해 위의 주소록 검색 조건을 수행하려면 다음과 같이 키를 지정해야 한다.

- **국적** : 키값과 일치하도록 지정한다.
- **나이** : 키값의 구간을 지정한다.
- **문자** : 키값에 가깝도록 지정한다.

검색에서는 이러한 조건을 하나만 지정할 수도 있고 논리곱, 논리합 등을 사용해서 복합해서 지정할 수 있다.

---

# 선형 검색

`선형 검색(Linear search)`란 직선 모양(선형)으로 늘어선 배열에서 검색하는 경우 원하는 키값을 가진 원소를 찾을 때까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘이다.

> 선형 검색의 종료 조건

1. 검색할 값을 찾지 못하고 배열의 맨 끝을 지나간 경우 -> 검색 실패
2. 검색할 값과 같은 원소를 찾는 경우 -> 검색 성공

배열의 원소 개수가 n이라면 이 조건을 판단하는 횟수는 평균 n / 2 번입니다.

배열 a에서 검색하는 프로그램은 다음과 같이 나타낼 수 있다.

```m
i = 0
while True:
    if i == len(a):
        # 검색 실패
    if a[i] == key:
        # 검색 성공(찾은 원소의 인덱스는 i)

        i +=1
```

배열을 스캔할 때 주목하는 원소의 인덱스를 카운터용 변수 i로 나타냈다. i를 0으로 초기화하고 원소를 하나씩 검사할 때마다 while 문의 끝에서 1씩 증가한다.

while문을 빠져나가는 것은 앞에서 설명한 선형 검색의 종료 조건1 , 2가운데 어느 하나가 성립되는 경우이며 각 if문과 대응한다.

- 선형 검색의 종료 조건 1. if i == len(a)이 성립하면 스캔 종료.
- 선형 검색의 종료 조건 2. if a[i] == key 가 성립하면 스캔 종료.

> While문으로 작성한 선형 검색 알고리즘

```m
from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 같이 같은 원소를 선형 검색(while문)"""
    i = 0

    while True:
        if i == len(a):
            return -1       # 검색 실패하여 -1 반환
        if a[i] == key:
            return i        # 검색에 성공하여 현재 검사한 배열의 인덱스 반환
        i += 1

if __name__ == '__main__':
    num = int(input('원소 수를 입력하세요. : ')) # num값 입력받음
    x = [None] * num        # 원소 수가 num인 배열 생성

    for i in range(num):
        x[i] =int(input(f'x[{i}]: '))

    ky = int(input('검색할 값을 입력하세요.: ')) #검색할 키 ky를 입력받음

    idx = seq_search(x ,ky)        # ky와 같이 같은 원소를 x에서 검색

    if idx == -1:
        print('검색값을 갖는 원소가 존재하지 않습니다.')
    else:
        print(f'검색값은 x[{idx}]에 있습니다.')
```

`seq_search()`는 배열 a에서 값이 key인 원소를 선형 검색하는 함수이며, 찾은 원소의 인덱스를 반환한다. 값이 key인 원소가 여러개 존재 하는 경우에는 스캔 과정에서 맨처음 발견한 원소(배열에서 맨 앞의 원소)를 반환한다.

그러나 배열의 스캔을 for문으로 구현하면 코드가 더 짧고 간결해진다.
앞에서 작성한 while문을 for문으로 수정해보자

> for문으로 작성한 선형 검색 알고리즘

```mm

from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:
    """ 시퀀스 a에서 key와 같이 같은 원소를 선형 검색(for 문)"""
    for i in range(len(a)):
        if a[i] == key:
            return i        #검색 성공(인덱스를 반환)
    return -1               #검색 실패(-1을 반환)
```

> test.py파일의 seq_search()함수 사용하여 실수 검색하기

```mm
#seq_search() 함수를 사용하여 실수 검색하기
from test import seq_search

print('실수를 검색합니다')
print('주의 : "End"를 입력하면 종료합니다.')

number = 0
x = []

while True:
    s = input(f'x[{number}]')
    if s == 'End':
        break
    x.append(float(s))
    number += 1

ky = float(input('검색할 값을 입력하세요. : '))

idx = seq_search(x, ky)

if idx == -1:
    print('검색값을 갖는 원소가 존재하지 않습니다.')
else :
    print(f'검색값은 x[{idx}]에 있습니다.')

```

위에서 작업한 teset.py파일내의 함수를 import하여 사용한 프로그램이다.

## 보초법

선형검색은 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 반복하면 종료 조건을 검사하는 비용을 무시할 수 없게된다. 이 비용을 반으로 줄이는 방법이 바로 `보초법(Sentinal method)`이다.

```mm
#선형 검색 알고리즘(실습3-1)을 보초법으로 수정

from typing import Any, Sequence
import copy

def seq_search(seq: Sequence, key: Any) -> int:
   """시퀀스 seq에서 key와 일치하는 원소를 선형 검색(보초법)"""

   a = copy.deepcopy(seq)  #seq를 deepcopy 한다.
   a.append(key)           #보초 key를 추가하는 명령어

   i = 0
   while True:
       if a[i] == key:
           break
       i += 1
   return -1 if i == len(seq) else i

if __name__ : '__main__':
   num = int(input('원소 수를 입력하시오. : ')     #num값을 입력
   x = [None] * num                             # 원소 수가 num인 배열 생성

   for i in range(num):
       x[i] = int(input(f'x[{i}]'))

   ky = int(input('검색할 값을 입력하세요.: '))    # 검색할 ky를 입력받는 함수

   idx = seq_search(x, ky)                      # 키 ky값과 같은 원소를 x에서 검색

   if idx == -1:
       print('검색값을 갖는 원소가 존재하지 않습니다.')

   else:
       print(f'검색값은 x[{idx}에 있습니다.')

```

보초법을 사용한 선형 검색 알고리즘이다.

배열 seq를 a로 복사하고 a의 마지막에 보초 key를 추가한다.

보초법은 성형 검색의 종료 조건 1(값을 찾는경우)이나 종료 조건2(못찾는 경우)에나 사용 가능하며 종료 조건 1의 경우 보초법을 활용할 필요가 없다.

보초는 반복을 종료하는 판단 횟수를 크게 줄인다는 것만 기억하자.

# 이진 검색(Binary search)

이진 검색 알고리즘을 사용하려면 배열 데이터가 정렬되어있어야 한다. 이진 검색은 선형 검색보다 빠르게 검색 가능하다.

배열이 다음과 같다고 가정해보자
a = [5, 7, 15, 28, 29, 30, 35, 40, 41, 42, 48, 50, 60]
index = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

위 배열에서 41의 값을 찾는다고 가정해보자
중앙값인 a[6]=35는 찾아야할 값 41보다 작다. 이 경우 검색 범위를 a[7]~a[12]로 줄일 수 있다.

여기서 a[7]=35~a[12]=60의 범위에서 중앙값은 대략 a[9]라고 하면 a[9] =42로 찾고자 하는값 41보다 크다. 그렇다면 이경우에는 a[9]이상의 범위는 찾아볼 필요가 없게 된다.

그러다면 범위를 한번더 조정해보자 a[7]~a[9]. 이경우 중앙값인 a[8]은 41의 값과 동일하다. 이렇게 되면 찾고자하는 값이 중앙값이 되므로 찾을 수 있게된다.

이렇듯 선형검색의 경우와 다르게 검색에 걸리는 시간이 굉장히 적게 걸림을 알 수 있다.

> 이진 검색의 종료 조건

- 중앙값 (a[mid])이 key와 일치하는 경우
- 검색 범위가 더 이상 없는 경우

이진 검색의 경우 알고리즘을 반복할 때마다 검색 범위가 절반으로 줄어들기 때문에 필요한 검색 횟수는 평균 `log N번`이다. 검색에 실패한 경우 [`log(N+1)번`]이며 검색에 성공한 경우에는 `log N-1번`이다.

# 번외 모듈편

보통 if `__name__` == 과 같이 `__name__`은 모듈의 이름이 저장되는 변수이다. 동시에 import로 모듈을 가져오면 그 모듈의 이름이 들어가게 되는 부분이다.

하지만 파이썬 인터프리터로 직접 시행할경우 모듈의 이름이 아닌 `__main__`이 들어가게 된다. 이는 프로그램의 시작점을 의미하기도 한다.

즉 test3-4.py와 같이 if `__name__` == `'__main__'`:처럼 `__name__` 변수의 값이 `'__main__'`인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업이다. 즉, 스크립트 파일이 메인 프로그램으로 사용될 때와 모듈로 사용될 때를 구분하기 위한 용도라고 보면 된다.

> 참고 | 파이썬은 왜 프로그램의 시작점이 정해져 있지 않은가?

파이썬이 처음에 개발 될 당시에는 리눅스/유닉스에서 사용하는 스크립트 언어 기반이었기 때문에 프로그램의 시작점이 따로 정해져 있지 않았다고 한다.

보통 리눅스/유닉스의 스크립트 파일은 파일 한 개로 이루어진 경우가 많은데, 이 스크립트 파일 자체가 하나의 프로그램이다 보니 시작점이 따로 필요하지 않는 것이다.

하지만 C 언어나 자바같은 언어는 처음 만들어질 때부터 소스 파일을 여러 개 사용했기 때문에 여러 소스 파일의 함수들 중에서도 시작 함수(main)를 따로 정해 놓는다.

---

# 복잡도

알고리즘의 성능을 객관적으로 평가하는 기준을 `복잡도(Complexity)`라고 한다.

조건은 2가지가 있다.

- 시간 복잡도 (time complexity) : 실행하는데 필요한 시간을 평가한다.
- 공간 복잡도 (space complexity) : 메모리와 파일 공간이 얼마나 필요한지 평가한다.

보통 `선형검색`의 `시간 복잡도`는 `O(n)`으로 나타낸다.
n이 점점 커지면 O(n)에 필요한 시간도 점점 비례해서 길어진다. 하지만 O(1)에 필요한 계산 시간은 변하지 않는다.

예를 들어 각 단계별 실행 횟수가 각각 1, n/2 인 선형검색이 있다고 하면 이 선형 검색의 복잡도는 o(1) + o(n/2) = o(max(1),(n/2)) 의 형태가 된다.

그리고 여기서 한가지 알아야 할 것은 복잡도에서 O(n/2)던 o(n-1)이던 복잡도는 엄청나게 큰 정수값을 넣을 경우 /2나 -1같은 계산은 그다지 중요해지지 않는다. 결국 n이라는 값에 수렴하기 때문이다.

참고로` 이진 검색`의 `시간 복잡도`는`O(logN)`이다.

대충 그래프로 표시하자면

```
작다                                             크다
<-------------------------------------------------->
1       logn    n   nlongn  n^2    n^3    n^k     2^n
```

의 형태를 이룬다.

---

# 해시법

데이터의 추가 및 삭제를 효율적으로 할 수 있는 방법이다.

a = [5,6,14,20,29,34,37,51,69,75, -, -, -]

index= [0,1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12]

b = [5,6,14,20,29,34,35,37,51,69,75, -, -]

a에 나타난 배열 x의 원소 수는 총 13이고 앞에서부터 10개의 데이터가 오름차순 되어있다. 그림 a의 배열에 35를 추가해 보자.

35를 추가하는 과정은 다음과 같다.

```mm
1.x[5]와 x[6]사이에 값이 추가되도록 이진 검색법 활용
2.그림 b처럼 x[6]이후의 모든 원소를 한칸 씩 뒤로 이동
3.x[6]에 35를 대입
```

이 경우 원소가 이동하는데 필요한 복잡도는 O(n)이고 그 비용은 숫자가 커질수록 작지 않다. 데이터 삭제의 경우도 동일하다.

`해시법(hasing)`은 '데이터를 저장할 위치 = 인덱스'를 간단한 연산으로 구하는 것이다. 이 방법은 원소의 검색, 추가, 삭제까지 효율적으로 수행할 수 있다.

위에서 a에 나타난 배열의 키(원소의 값)을 원소 개수인 13으로 나눈 나머지는 다음의 표와 같다.

|             키             |  5  |  6  | 14  | 20  | 29  | 34  | 37  | 51  | 67  | 75  |
| :------------------------: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 해시값(13으로 나눈 나머지) |  5  |  6  |  1  |  7  |  3  |  8  | 11  | 12  |  4  | 10  |

이 값을 `해시값(hash value)`라고 한다.

이렇게 구한 해시값을 인덱스로 하여 원소를 새로 저장한 배열이 `해시 테이블(hash table)`이다.

해시 테이블은 다음과 같은 모양을 가진다.

index = <span style=color:green>[0,1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12]</span>

a = [-,14,-,29,69,5,6,20,34,-,75,37,51]

위의 해시 테이블에 `35`를 추가한다고 하면 35를 13으로 나눈 나머지는 9이므로 a[9]에 저장한다.

a =[-,14,-,29,69,5,6,20,34,`35`,75,37,51]

이렇게 키 -> 해시값으로 변환하는 과정을 `해시 함수(hash function)`이라고 한다. 일반적으로 해시 함수는 나머지를 구하는 연산 또는 그 연산을 응용할 때 주로 사용한다. 이렇게 해시 테이블에서 만들어진
원소를 `버킷(bucket)`이라고 한다.

---

## 해시 충돌

키와 해시값은 일반적으로 다대 1(n:1) 의 관계이다.
만약 a = [-,14,-,29,69,5,6,20,34,-,75,37,51]에 18을 추가한다고 해보자. 18을 13으로 나누면 5의 나머지가 생기므로 저장할 곳은 버킷 a[5]이지만 a[5]에는 이미 값이 들어가 있다. 이처럼 저장할 버킷이 중복되는 현상을 `충돌(collision)`이라고 한다.

해시법에서 충돌이 발생하는 경우 2가지 방법으로 대처가 가능하다.

- 체인법 : 해시값이 같은 원소를 연결 리스트로 관리한다.
- 오픈 주소법 : 빈 버킷을 찾을 때까지 해시를 반복한다.

---

## 체인법

체인법이란 해시값이 같은 데이터를 체인모양의 연결 리스트로 연결하는 방법.
`오픈 해시법(OPEN HASHING)`이라고도 한다.

<img src = https://blog.kakaocdn.net/dn/bixxIM/btqLFTinQWo/nKk3kMJL2LtOs5DkclRwIk/img.png>

체인법에서는 해시값이 같은 데이터를 연결리스트에 의해 체인모양으로 연결한다. 배열의 각 버킷(해시 테이블)에 저장하는 것은 인덱스를 해시값으로 하는 연결리스트의 앞쪽 노드를 참조하는 것이다.

예를 들어 사진의 69와 17의 해시값은 둘다 4이며 이들을 연결하는 연결 리스트의 앞쪽 노드를 참조하여 table[4]에 저장한다. 참고로 해시값 0이나 2처럼 데이터가 하나도 없는 버킷의 값을 None이라고 한다.

- table[4]는 버킷 69를 참조하는 것이며, 버킷 69의 뒤쪽 포인터는 17을 참조하는 것이다. 또한 버킷 17의 뒤쪽 포인터는 뒤쪽 노드가 존재하지 않음을 알려주는 None이다.

> 체인법으로 해시 함수 구현하기

```mm
from __future__ import annotations
from typing import Any, Type
import hashlib

class Node:
    """해시 구성하는 노드"""

    def __init__(self, key: Any, value: Any, next: Node) -> None:
        """초기화"""
        self.key = key          #키
        self.value = value      #값
        self.next = next        # 뒤쪽 노드를 참조
```

## Node 클래스 만들기

Node 클래스는 개별 버킷을 나타낸다. 이 클래스에는 다음과 같이 필드가 3개 있다.

- key : 키(임의의 자료형)
- value : 값(임의의 자료형)
- next : 뒤쪽 노드를 참조(Node형)
  NODE 클래스는 키와 값이 짝을 이루는 구조이다. 키에 해시 함수를 적용하여 해시값을 구한다.
  <img src = https://blog.kakaocdn.net/dn/xoPJg/btqtYZexACW/ghUidmvh6OVQBLkgoKHVvK/img.jpg>
  next를 통해 자신과 같은 자료형인 인스턴스를 참조한다.

Node형 인스턴스를 초기화하는` __init__`()함수는 3개의 인수 key, value, next를 전달받아 각각
대응하는 필드인 self.key, self.value, self.next에 대입한다.

---

## ChainedHash 해시 클래스 만들기

```mm
class chainedhash
    """체인법으로 해시 클래스 구현"""

    def __init__(self, capacity: int) -> None:
        """초기화"""
        self.capacity = capacity                # 해시 테이블의 크기를 지정
        self.table = [None] * self.capacity     # 해시 테이블(리스트)을 선언

    def hash_value(self, key: Any) -> int:
        """해시값을 구함"""
        if isinstance(key,int):                 # key가 int형인 경우 해당.
                return key % self.capacity
        return(int(hashlib.sha256(str(key).endcode()).hexdigest(), 16) % self.capacity)     # 표준 라이브러리 사용 예
        #haslib에서 sha256을 사용하여 바이트 문자열의 해시값을 구하는 해시 알고리즘 생성자를 생성한다.
        # 그 뒤에 hashlib.sah256에 바이트 문자열의 인수를 전달해야 하므로 key를 str형 문자열로 변환한 뒤, 그 문자열을 encode() 함수에 전달
        # hexdigest()함수는 sha 256 알고리즘에서 해시값을 16진수 문자열로 꺼낸다.
        # int()함수 : hexdigest()함수로 꺼낸 문자열을 16진수 문자열로 하는 int형으로 변환한다.
```

해시 클래스는 필드 2개로 구성됩니다.

- capacity : 해시 테이블의 크기(배열 table의 원소 수)를 나타낸다.
- talbe : 해시 테이블을 저장하는 list형 배열을 나타낸다.

해시 테이블의 각 버킷은 맨 앞부터 table[0], table[1], ~~~ table[capacity -1] 순으로 접근할 수 있다.

`__init__` 함수가 호출된 직후 배열 table의 모든 원소는 None이고 전체 버킷이 빈 상태이다.

---

## hash_value() 해시 함수 만들기

def hash_value()~ 부분이 이에 해당한다. 이 함수는 인수 key에 대응하는 해시값을 구한다.

> key가 int형인 경우
>
> key를 해시의 크기 capacity로 나눈 나머지를 해시값으로 한다. 예를 들어 ChainedHash 클래스를 사용한 프로그램인 실습 test3-6.py를 보면 key가 int형이고 크기가 13이므로 키를 13으로 나눈 나머지가 해시값이 된다.

> key가 int형이 아닌경우

key가 정수가 아닌 문자열, 리스트, 클래스 등의 형태인 경우 그 값은 바로 나눌 수 없다. 다음과 같은 표준 라이브러리로 형변환을 거쳐야 해시값을 얻을 수 있다.

```mm
*sha256 알고리즘 : hashlib 모듈에서 제공하는 sha256은 주어진 바이트(byte) 문자열의 해시값을
구하는 알고리즘의 생성자(constructor)이다.

*encode() 함수 : hashlib.sha256에는 바이트 문자열의 인수를 전달해야 한다. 그래서 key를 str형 문자열로 변환한 뒤 그 문자열을 encode()함수에 전달하여 바이트 문자열을 생성한다.

*hexdigest()함수 : sha 256 알고리즘에서 해시값을 16진수 문자열로 꺼낸다.

*int()함수 : hexdigest()함수로 꺼낸 문자열을 16진수 문자열로 하는 int형으로 변환한다.
```

---

## 해시와 해시 함수 보조설명

`해시(hash)`는 '긁어모음, 뒤죽박죽, 가늘게 썬 고기 음식'등을 뜻하는 용어이다. 만약 충돌이 전혀 발생하지 않는 경우 해시함수로 인덱스를 찾는 것만으로 검색, 추가, 삭제가 대부분 완료되고 이 때의 시간복잡도는 모두 O(1)이다.

해시 테이블을 충분히 크게 만들면 충돌 발생을 억제할 수 있지만 이 방법은 메모리를 낭비한다. 때문에 통상적인 경우에선 시간과 공간의 트레이드 오프(trade off 즉 상충관계)문제가 발생한다.

충돌을 피하기 위해선 해시 함수가 해시 테이블 크기보다 작거나 같은 정수를 고르게 생성해야 한다. 따라서 해시 테이블의 크기는 `소수`를 선호한다.

---

## 키로 원소를 검색하는 search()함수

<img src = https://blog.kakaocdn.net/dn/bixxIM/btqLFTinQWo/nKk3kMJL2LtOs5DkclRwIk/img.png>

실습 test3-5c.py에서 search()함수는 key인 원소를 검색한다.

33의 해시값은 7이므로 table[7]이 가리키는 연결 리스트를 찾아간다.
20 -> 33으로 찾아가면 성공이다.

26 검색의 경우 26의 해시값은 0이다. table[0] = None 이므로 검색에 실패한다.

search()함수가 원소를 검색하는 과정은 다음과 같다.

```
1. 해시 함수를 사용하여 키를 해시값으로 변환한다.
2. 해시값을 인덱스로 하는 버킷에 주목한다.
3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 스캔한다. 키와 같은 값이 발견되면 검색에 성공, 원소의 맨 끝까지 스캔해서 발견되지 않으면 검색 실패.
```

---

## 원소를 추가하는 add()함수

test3-5c.py 를 참고하자

add()함수는 키가 key이고 값이 value인 원소를 추가한다.\

add함수의 추가 과정은 책을 참고하자. 마땅한 이미지를 추가하기가 힘듦. p138~139

> add()함수가 원소를 추가하는 과정

1. 해시 함수를 사용하여 키를 해시값으로 변환한다.
2. 해시값을 인덱스로 하는 버킷에 주목
3. 버킷이 참조하는 연결리스트를 맨 앞부터 차례로 선형 검색한다. 키와 같은값이 발견되면 키가 이미 등록된 경우이므로 추가에 실패한다. 원소의 맨 끝까지 발견되지 않으면 해시값인 리스트 맨 앞에 노트를 추가한다.

---

## 원소를 삭제하는 remove()함수

test3-5d.py를 참고하자.
remove()함수는 키가 key인 원소를 삭제한다.

구체적인 예는 add()와 마찬가지로 책을 참고하자. p139~140

> remove()함수로 원소를 삭제하는 과정

1. 해시 함수를 사용하여 키를 해시값으로 변환
2. 해시값을 인덱스로 하는 버킷에 주목
3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례대로 선형 검색 한다. 키와 같은 값이 발견되면 그 노드를 리스트에서 삭제한다. 그렇지 않으면 삭제에 실패한다.

---

## 원소를 출력하는 dump()함수

dum()함수는 모든 원소를 덤프하는 것, 즉 해시 테이블의 내용을 한꺼번에 출력한다.

해시 테이블의 모든 원소인 table[0] ~ table[capacity -1] 까지 뒤쪽 노드를 찾아가며 각 노드의 키와 값을 출력하는 작업을 반복한다.

<img src = https://blog.kakaocdn.net/dn/bixxIM/btqLFTinQWo/nKk3kMJL2LtOs5DkclRwIk/img.png>

이 그림을 dump()함수로 실행하면 다음과 같이 출력된다

```
00
01 -> 14
02
03 -> 29
04 -> 69 -> 17
05 ->  5
06 ->  6
07 -> 20 -> 33
08
09
10
11
12
```

---

## 오픈 주소법

해시 충돌이 발생할 때 해결하는 또 다른 방법으로 `오픈 주소법(open addressing)`이 있다.
오픈 주소법은 충돌이 발생했을 때 `재해시(rehashing)`을 수행하ㅓ여 빈 버킷을 찾는 방법을 말하며 `닫힌 해시법(closed hashing)`이라고도 한다.

원소의 추가는 그림으로 설명해야하나 참조하기가 힘듦으로 책 p145를 참고하자.

## isinstance 함수

isinstance(인스턴스, 클래스/데이터타입)

이때 인스턴스가 특정 클래스/데이터 타입과 일치할 경우에는 True를 아닌 경우에는 False를 리턴해준다.
