# 문자열 검색

---

## 7-1. 브루트 포스법

문자열에서 부분 문자열을 검색하는 알고리즘으로 `브루트 포스법`, `KMP법`, `보이어 무어법`이 있다. 우선 브루트 포스법에 대해 알아보자.

### 문자열 검색이란?

`문자열 검색(string Search)`는 어떤 문자열 안에 다른 문자열이 포함되어 있담뎐 어디에 위치하는지 찾아내는 것을 의미한다.

예를 들어 'STRING'에서 'IN'을 검색하면 성공하지만, 문자열 'QUEEN'에서 'IN'을 검색하면 실패한다.

이처럼 검색되는 쪽의 문자열(ex ='STRING') 을 `텍스트(text)`라고 하고, 찾아내는 문자열(ex = 'IN')을 `패턴(pattern)`이라고 한다.

### 브루트 포스법 알아보기

`브루트 포스법`은 문자열 검색 알고리즘에서 가장 기초적이고 단순한 방법이다. 이 방법은 선형 검색을 단순하게 확장한 알고리즘이라 `단순법`이라고도 부른다.

예를 들어 텍스트 'ABABCDEFGHA'에서 패턴'ABC'를 브루트 포스법으로 검색하는 순서를 알아보자.

setp 1)

```
'0 1 2 3 4 5 6 7 8 9 10' -> index 번호
'A B A B C D E F G H  A' -> text
'A B C'  -> 패턴
```

텍스트의 첫문자 'A'에서 시작하는 문자 3개가 패턴 'ABC'와 일치하는지 검사한다.
'A'와 'B'는 일치하지만 마지막 'C는 일치하지 앟는ㄴ다.

step 2)

```
'0 1 2 3 4 5 6 7 8 9 10' -> index 번호
'A B A B C D E F G H  A' -> text
'  A B C'  -> 패턴
```

패턴을 오른쪽으로 1칸 밀고, 텍스트의 2번째 문자와 그 이후 부분이 일치하는지 검사한다. 패턴의 첫 문자 'A'와 텍스트 'B'는 일치하지 않는다. 그럼 한칸 더 밀자.

step 3)

```
'0 1 2 3 4 5 6 7 8 9 10' -> index 번호
'A B A B C D E F G H  A' -> text
'    A B C'  -> 패턴
```

패턴의 문자 'A', 'B', 'C'가 모두 일치하므로 검색에 성공한다.

그러나 브루트 포스법은 이미 검사한 위치를 기억하지 못하여 다시 검사하므로 효율이 좋지 않은 방법이라고 할 수 있다.(P.306 참조)

```mm
실습 7-1

def bf_match(txt: str, pat: str) -> int:
    '브루트 포스법으로 문자열 검색'
    pt = 0                  # 텍스트(txt)를 따라가는 커서
    pp = 0                  # 패턴(pat)을 따라가는 커서

    while pt != len(txt) and pp != len(pat):        #각각의 커서를 의미하는 pt와 pp가 각 문자열의 길이와 같지 않을동안 반복
        if txt[pt] == pat[pp]:                      #txt[pt]가 pat[pp]와 같을 때
            pt += 1
            pp += 1
        else:                                       # txt[pt] != pat[pp] 일 경우
            pt = pt - pp + 1                        # PT - PP +1 한값 출력
            pp = 0                                  # PP는 0으로 만듦

    return pt - pp if pp == len(pat) else -1        # 개인적으로 판단하기에
    #if pp == len(pat):
    #   return pt - pp
    #else:  -1                                      과 같다고 판단됨.

if __name__ == '__main__':
    s1 = input('텍스트를 입력하시오. : ')              # 텍스트용 문자열
    s2 = input('패턴을 입력하시오. : ')                # 패턴용 문자열

    idx =bf_match(s1,s2)                             #문자열 s1, s2를 브루트 포스법으로 검색

    if idx == -1:
        print('텍스트 안에 패턴이 존재하지 않습니다.')
    else:
        print(f'{(idx+1)}번째 문자가 일치합니다.')
```

실습 7-1에서 bf_match()함수는 텍스트 txt에서 패턴 pat를 검색한다. 그리고 검색에 성공한 txt위치의 인덱스를 반환한다.

텍스트 txt 안에 패턴 pat이 여러 번 포함된 경우에는 가장 앞쪽에 위치한 인덱스를 반환한다.

---

## 멤버십 연산자와 표준 라이브러리를 사용한 문자열 검색

파이썬에서 문자열을 검색할 때는 멤버십 연산자나 표준 라이브러리를 사용하여 구현할 수 있다.

> 멤버십 연산자로 구현하기

`멥버십 연산자(membership operator)`인 `in`과 `not in`을 사용하면 어떤 문자열이 다른 문자열 안에 포함되어 있는지 검색할 수 있다.
예를 들어 txt 안에 문자열 ptn이 있는지 파단할 때에는 다음과 같이 수행하면 된다.

- ptn in txt -> ptn은 txt안에 포함되어 있습니까?
- ptn not in txt -> ptn은 txt에 포함되어 있지 않습니까?

이 방법은 해당 문자열이 다른 문자열 안에 포함되어 있는지 판단할 수는 있지만 그 위치는 알지 못한다.

- 검색한 문자열의 위치를 알고 싶다면 실습 7-1과 같이 배열을 사용해야 한다.

## find, index 계열 함수로 구현하기

str 클래스형에 소속된 find(), rfind(), index(), rindex() 함수는 문자열을 검색하여 검색한 문자열의 위치를 반환한다.

```
str.find(sub[, start[, end]])
```

문자열 str의 [start:end]에 sub가 포함되면 그 가운데 갖장 작은 인덱스를 반환하고, 그렇지 않으면 -1을 반환한다.

`find()` 함수에서는 전달받은 인수 sub, start, end 중에서 end만 생략하거나 start, end 둘다 생략이 가능하다.

sub는 생략할 수 없다.(생략할 수 있는 인수 start와 end는 슬라이스 표기에 따라 지정되기 때문)

- 슬라이스 표기에 따라 start는 슬라이스의 시작 인덱스이며 기본값은 0이다. 또한 end는 슬라이스의 끝 인덱스이며 기본값은 슬라이스되는 시퀀스의 길이를 말한다.
- []는 그 안의 인수를 생략할 수 있다는 것을 의미하는 표기이다.

```
str.rfind(sub[, start [, end]])
```

문자열 str [start:end]에 sub가 포함되면 그 가운데 가장 큰 인덱스를 반환하고, 그렇지 않으면 -1을 반환한다. (생략할 수 있는 인수 start와 end는 슬라이스 표기에 따라 지정한다.)

```
str.index(sub[, start [, end]])
```

find() 함수와 같은 기능을 수행한다. sub가 발견되지 않으면 예외 처리로 ValueError를 내보낸다.

```
str.rindex(sub[, start [, end]])
```

rfind()함수와 같은 기능을 수행한다. sub가 발견되지 않으면 예외 처리로 ValueError를 내보낸다.

---

### with 계열 함수로 구현하기

with 계열 함수는 어떤 문자열이 다른 문자열의 시작이나 끝에 포함되어 있는지를 판단한다.

```
str.startswitch(prefix[, start [, end]])
```

문자열이 prefix로 시작하면 True를, 그렇지 않으면 False를 반환한다. start가 지정되어 있으면 그 위치에서 판단을 시작하고, end가 지정되어 있으면 그 위치에서 비교를 중지한다.

```
str.endswitch(suffix[, start [, end]])
```

문자열이 suffix로 끝나면 True를, 그렇지 않으면 False를 반환한다. start가 지정되어 있으면 그 위치에서 판단을 시자하고, end가 지정되어 있지 않으면 그 위치에서 비교를 중지한다.

---

# 7 - 2 KMP 법

브루트 포스법은 일치하지 않는 문자를 만나면 다시 패턴의 첫 문자부터 검사를 수행하지만, KMP법은 검사한 결과를 효율적으로 사용하는 알고리즘이다.

문서화 하기 힘든 항목이다. 책을 참조해서 복습하도록 하자

P310 ~ 314

KMP법은 실제로 복잡하기만 할 뿐 효용가치가 없고 성능면에서도 뒤쳐지는 검색법이다.

---

# 7 - 3 보이어 무어법

`보이어 무어법(Boyer-Moor method)`은 KMP법보다 더 효율적이어서 실제 문자열 검색에서 널리 사용하는 알고리즘이다.

패턴의 끝문자에서 시작하여 앞쪽을 향해 검사를 수행하는 방식이다. 이 과정에서 일치하지 않는 문자를 발견하면 미리 준비한 표를 바탕으로 패턴이 이동하는 값을 결정한다.

텍스트 'ABCXDEZCABACABAC' DPTJ VOXJS 'ABAC'를 검색한다고 가정해보자.

```
STEP 7-1
     0  1  2  '3'  4  5  6  7  8  9 10 11 12 13 14 15    -> index
     A  B  C  'X'  D  E  Z  C  A  B  A  C  A  B  A  C    -> 텍스트(text)
a    A  B  A  'C'                                        -> 패턴(Pat)
b       A  B  'A'  C
c          A  'B'  A  C
d             'A'  B  A  C
```

위의 예시처럼 텍스트와 패턴의 첫문자를 위아래로 나란히 놓고 패턴의 마지막 문자 'C'에 주목해보자 (a 과정)

같은 위치에 있는 텍스트 'X'는 패턴 안에 포함되어 있지 않다. 따라서 b~d 과정처럼 패턴을 이동시켜도 텍스트 문자 'X'와 패턴의 문자는 일치하지 않는다.

이처럼 패턴이 포함되지 않는 문자를 택스트에서 발견하면 그 위치까지는 건너띌 수 있다.

```
STEP 7-2
     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15    -> index
     A  B  C  X  D  E  Z  C  A  B  A  C  A  B  A  C    -> 텍스트(text)
                 A  B  A  C
```

앞에서 b~d의 과정처럼 비교하는 과정을 생략하고 패턴을 오른쪽으로 한번에 4칸 밀어서 위와 같은 상태로 만든다. 그런데 이 경우에는 패턴의 마지막 문자'C'와 텍스트의 문자가 일치한다.

이 경우에는 패턴의 1칸 앞의 문자 'A'로 되돌아가서 다음과 같은 상태를 만든다.

```
STEP 7-3
     0  1  2  3  4  5 '6' 7  8  9 10 11 12 13 14 15    -> index
     A  B  C  X  D  E 'Z' C  A  B  A  C  A  B  A  C    -> 텍스트(text)
a             A  B  A 'C'
b                A  B 'A' C
c                   A 'B' A  C
```

그러나 위와 같은 상태에서 패턴의 문자 'A'는 텍스트의 문자 'Z'와 일치하지 않는다. 이 경우 과정 b,c처럼 패턴을 1칸, 2칸 밀어도 텍스트의 문자 'Z'와 패턴의 문자는 일치하지 않는다. 그렇기 때문에 여기서 패턴을 한번에 3칸 밀어 아래와 같이 만든다.

```
STEP 7-4
     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15    -> index
     A  B  C  X  D  E  Z  C  A  B 'A' C  A  B  A  C    -> 텍스트(text)
a                         A  B  A 'C'         -> 패턴이 일치하지 않는다
b                            A  B 'A' C       -> 패턴을 오른쪽으로 1칸밀면 A가 일치
c                               A 'B' A  C    -> 패턴을 오른쪽으로 2칸밀어도 일치하지 않는다.
d                                 'A' B  A  C -> 패턴을 오른족으로 3칸밀면 안된다.
```

- 패턴의 문자 길이를 n개라고 하면 패턴에 없는 문자를 만난 경우에 패턴을 n개만큼 이동하는 것이 아니다. 즉, 주목하는 문자의 위치가 n개만큼 떨어질 수 있도록 패턴을 이동한다는 점에 유의하자. 위의 예시를 예로 들면 처음에는 패턴을 4칸(=n) 움직였지만 그 뒤로는 주목하는 텍스트의 위치(6)으로부터 4만큼 떨어진 위치(10)에서 검사를 시작하기 위해 패턴을 3칸 움직인 것이다.

위에서 a과정을 보면 패턴의 마지막 문자 'C'는 텍스트의 문자 'A'와 일치하지 않는다. 그러나 문자 'A'는 패턴의 1번째와 3번째에 포함되어 있다. 그래서 b의 과정처럼 뒤쪽에 있는 'A'가 위 아래로 겹치도록 패턴을 오른쪽으로 1칸 밀어서 다음과 같은 상태를 만들어보자.

```
STEP 7-5
     0  1  2  3  4  5  6  7  8  9 10 '11' 12 13 14 15    -> index
     A  B  C  X  D  E  Z  C  A  B  A  'C'  A  B  A  C    -> 텍스트(text)
                             A  B  A  'C'
```

맨 끝 문자 'C'를 기점으로 앞으로 문자를 비교하면 모든 문자가 일치하므로 검색에 성공한다.

그런데 보이어 무어 알고리즘도 각각의 문자를 만났을 때 패턴을 이동할 크기를 저장하는 표(건너뛰기 표)를 만들어둘 필요가 있다. 패턴 문자열의 크기가 n일 때 이동할 크기(이동량)은 다음과 같이 결정한다.

> 패턴에 포함되지 않는 문자를 만날경우

`패턴 이동량`이 곧 `n(패턴의 길이)`이다. STEP 7-1 ~ STEP 7-2가 해당된다. 'X'는 포함되지 않으므로 4문자만큼 밀어낸 것이다.

> 패턴에 포함되는 문자를 만난 경우

마지막에 나오는 위치의 `인덱스`가 `k`이면 `이동량`은 `n-k-1` 이다. STEP 7-4가 해당된다. 'A'는 패턴안에 2곳이나 존재한다. 패턴을 오른쪽으로 한칸 밀어낸다.(n = 4, A의 인덱스는 0, 2이나 마지막 A는 3이므로 4-2-1 = 1이 나와 한칸 움직인다.)

같은 문자가 패턴안에 중복해서 존재하지 않으면 패턴의 맨 끝 문자의 이동량은 `n`이다. 예를 들어 'ABAC'의 'C'를 만나면 이동할 필요가 없으므로 이동량은 n이 된다.

---

위의 내용을 정리하여 건너뛰기 표를 만들면 다음과 같게 된다.

```
A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S
-------------------------------------------------------------------------
1   2   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4

T   U   V   W   X   Y   Z
-------------------------
4   4   4   4   4   4   4
```

이 표에 없는 문자(기호나 숫자)등의 이동량은 모두 4로 취급하면 된다.

## 문자열 검색 알고리즘의 시간 복잡도

> 브루트 포스법

이 알고리즘의 시간복잡도는 O(mn)이지만 일부러 꾸며낸 패턴이 아니라면 O(n)이 된다고 알려져 있다. 단ㄷ순한 알고리즘이지만 실제로는 아주 빠르게 동작한다.

> KMP법

이 알고리즘의 시간 복잡도는 최악의 경우에도 O(n)이다. 다만 처리하기 복잡하고, 패턴 안에 반복이 없으면 효율이 좋지 않다. 그러나 검색 과정에서 주목하는 곳을 되돌릴 필요가 전혀 없어 파일을 차례대로 읽어 들이면서 검색할때 사용하면 좋다.

> 보이어 무어법

이 알고리즘의 시간 복잡도는 최악의 경우라도 O(n)이고 평균 O(n/m)이다. test 7-3.py에선 배열을 1개만 사용하였는데 배열 2개로 알고리즘을 구현할 경우 kmp법과 마찬가지로 배열을 만드는데 복잡한 처리 과정이 필요하여 효율성이 떨어진다. 보이어 무어법은 배열을 1개만 사용해도 충분히 빠르다.

일반적으로 파이썬에서 문자열 검색을 하려면 표준 라이브러리를 사용하는 것을 추천한다.
만약 표준 라이브러리를 사용하지 않는다고 가정하면 보이어 무어법이나 브루트 포스법을 사용하는 경우가 많다.

---

## 문자 코드를 다루는 ord() 함수와 chr() 함수

ord()함수는 단일한 문자를 전달받아 그 문자의 유니코드 포인트를 정수로 반환한다..
예를 들어 ord('a') 는 정수 97을 반환한다.

이 함수의 변환을 거꾸로 수행하는 내장 함수는 chr() 함수이다.
예를들어 chr(97)은 문자 'a'를 반환한다.
