# 힙 정렬 (heap Sort)

`힙 정렬(heap sort)`는 힙의 특성을 이용하여 정렬하는 알고리즘이다. `힙`이란 '부모의 값이 자식의 값보다 항상 크다' 혹은 '부모의 값이 자식의 값보다 항상 작다'와 같이 두 값의 대소 관계가 일정한 조건을 만족하는 `완전 이진 트리`이다.

여기서 `이진 트리`란 우선 `트리는` 각원소를 의미하는 노드(node)들이 연결된 계층 구조이다.

<img src = https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/220px-Binary_tree.svg.png>

이미지와 같이 맨위에 위치한 노드(=2)인 `루트(root)`는 부모가 없는 노드이다. 노드의 상하 관계에는 `부모 노드(parent node)`와 `자식 노드(child node)`가 있다. 그리고 부모가 같은 자식 간의 관계를 `형제 노드(sibling node)` 라고 한다.

그리고 완전 이진 트리란 트리의 한 종류로 완전 이진 상태라는 특징을 갖는다. 여기서 `완전`이란 부모는 왼쪽 자식부터 추가하여 모양을 유지하라는 의미이고 `이진`이란 부모가 가질 수 있는 자식노드의 최대 개수가 2개 라는 의미이다.

그러나 힙은 형제의 대소관계가 정해져 있지 않으므로 `부분 순서 트리`라고도 한다.

```mm
a = [10,9,5,8,3,2,4,6,7,1] 의 형태이다.

              10
         9         5
     8      3    2    4
   6   7  1
```

짝대기를 생략한 엉성한 이진트리이다.. 복습할 때 해깔리면 책 p.287을 참고하자..

자세히 보면 순서대로 2의 배수대로 잘라서 나열한것을 확인할 수 있다.
a = [10/ 9,5/ 8,3,2,4/ 6,7,1]

이렇듯 부모 인덱스와 왼쪽 자식 인덱스, 오른쪽 자식 인덱스 사이에는 다음과 같은 관계가 성립한다.

```mm
원소 a = [i]에서
* 부모 : a[(i-1)//2]
* 왼쪽 자식 : a[i*2+1]
* 오른쪽 자식 : a[i*2+2]
```

## 힙 정렬의 특징

힙 정렬은 `힙에서 최댓값은 루트에 위치한다` 특징을 이용하여 정렬하는 알고리즘이다.

- 힙에서 최댓값인 루트를 꺼낸다
- 루트 이외의 부분을 힙으로 만든다

꺼낸 값을 나열하면 정렬이 끝난 배열이 완성된다. 즉, `힙 정렬`은 선택 정렬을 응용한 알고리즘이다.

또한 최댓값인 루트를 꺼낸 뒤 다시 남은 원소 중에서 최댓값을 구해야 한다.

예를 들어 위에서 예시로 든 원소 10개에서 최댓값을 꺼내면 남은 원소 9개에서 다시 최대값을 구해야 한다. 남은 9개 원소로 구성한 트리도 힙이 되도록 재구성 해야 한다.

## 루트를 삭제한 힙의 재구성

a) 힙에서 루트인 10을 꺼낸다. 비어 있는 루트 위치에 힙의 마지막 원소인 1을 이동한다.

```
a-1)
             '10'-> 루트 삭제하고 마지막 원소 루트로 이동
         9         5
     8      3    2    4
   6   7 '1'
```

```
a-2)
             '1'
         9         5
     8      3    2    4
   6   7
```

이때 이동한 1 이외의 원소는 힙 상태를 유지한다. 1만 알맞은 위치로 이동하면 힙 상태를 유지할 수 있다.

b) 이제 1을 알맞은 위치로 이동시켜야 한다. 이동할 1의 두 자식은 9와 5이다. 1,9,5 가운데 최댓값이 가장 위쪽에 위치해야 한다. '부모의 값 >= 자식의 값'이라는 힙의 조건이 성립하려면 두 자식을 비교하여 큰 값인 9와 교환한다.

```
b-1)
             `9`
        `1`         5
     8      3    2    4
   6   7
```

c) 이제 1의 두 자식은 8과 3이다. 큰 값인 왼쪽 자식 8과 교환한다. 1이 8의 위치로 내려온다.

```
c-1)
             `9`
        '8'          5
     '1'      3    2    4
   6     7
```

d) 이제 1의 두 자식은 6과 7이다. 이중에서 큰값인 오른쪽 자식 7과 교환한다. 그리고 1을 트리의 가장 아랫부분으로 이동 시켰으니 작업을 종료한다.

```
d-1)
             `9`
         8          5
     '7'      3    2    4
   6    '1'
```

이렇게 만든 트리는 힙 상태를 유지한다. 어떠한 부모와 자식 관계를 비교해도 부모의 값 >= 자식의 값 이고 최대값인 9는 루트에 위치한다.

그러나 이렇게 원소를 항상 끝까지 이동 시킬 필요는 없다. 이동할 원소값보다 왼쪽과 오른쪽 두 자식이 더 작으면 더이상 교환할 수 없으므로 그 시점에서 스캔을 종료한다. 따라서 루트를 삭제하고 다시 힙으로 만들기 위해 원소를 알맞은 위치로 이동하는 순서는 다음과 같다.

1. 루트를 꺼낸다.
2. 마지막 원소(가장 하단,우측에 위치한 원소)를 루트로 이동시킨다.
3. 루트에서 시작하여 자신보다 값이 큰 자식노드와 자리를 바꾸고 아래쪽으로 내려가는 작업을 반복한다. 자식의 값이 작거나 리프의 위치에 도달하면 종료.

---

## 힙 정렬 알고리즘 알아보기

위의 예처럼 힙 정렬 알고리즘의 흐름을 예시를 통해 알아보자.

이 부분은 책을 통해 보는 편이 이해가 더 빠를 것이다. 책 p290을 참조하자.

원소 안에 ['*'] 과 같이 ''표시는 정렬완료를 의미한다.

a) 힙의 루트 a[0]에 위치한 최댓값 10을 꺼내 배열의 맨 끝 원소인 a[9]와 교환한다.

```
              10
         9         5
     8      3    2    4
   6   7  1
                            a = [10,9,5,8,3,2,4,6,7,1]
```

b) 최대값을 a[9]으로 이동하면 a[9]은 정렬을 마친다. 앞에서 살펴본 순서대로 a[0]~a[9]의 원소를 힙으로 만든다. 그 결과 두 번째로 큰 값인 9가 루트에 위치한다.

```
              9
         8         5
     7      3    2    4
   6   1
                            a = [9,8,5,7,3,2,4,6,1,'10']
```

그럼 다시 힙의 루트 a[0]에 위치한 최댓값 9를 꺼내 아직 정렬하지 않은 부분의 맨 끝 원소인 a[8]과 교환한다.

c) 두 번째로 큰 값을 a[8]로 이동한 결과 a[8]~a[9]가 정렬을 마친다. 앞의 단계와 마찬가지로 a[0]~a[7]의 원소를 힙으로 만든다. 그 결과 세 번쨰로 큰 값인 8이 루트에 위치한다. 힙의 루트 a[0]에 위치한 최댓값 8을 꺼내 아직 정렬하지 않은 부분의 맨 끝 원소인 a[7]과 교환한다.

```
              8
         7         5
     6      3    2    4
   1
                            a = [8,7,5,6,3,2,4,1,'9','10']
```

d,e도 이 과정을 반복하여 배열의 맨끝을 하나하나 최대값부터 순서대로 저장한다.

이 과정을 단순히 정리하면 다음과 같다.

n이 배열의 원소 수이고 i값은 배열의 마지막 인덱스라고 할 때

1.  i값을 n-1로 초기화한다.
2.  a[0]와 a[i]를 교환한다
3.  a[0],a[1],~~~a[i-1]을 힙으로 만든다.
4.  i값을 1씩 감소시켜 0이 되면 종료한다. 그렇지 않으면 2로 돌아간다.

---

## 배열을 힙으로 만들기

이 부분은 위와 같은 방법으로 설명하기가 힘든 부분이다. p 292를 참조하자.

## 힙 정렬 예제

```mm
from typing import MutableSequence

def heap_sort(a : MutableSequence) -> None:
    '힙 정렬'
```

## `heap_sort()` 함수

원소 수가 n인 배열 a를 힙 정렬하는 함수이다. 다음과 같이 2단계로 구성된다.

- 1단계 : `down_heap()` 함수를 호출하여 배열 a를 힙으로 만든다.
- 2단계 : 최댓값인 루트 a[0]를 꺼내 배열의 마지막 원소와 교환하고, 배열의 남은 부분을 다시 힙으로 만드는 과정을 반복하여 정렬을 수행한다.

```mm
    def down_heap(a: MutableSequence, left: int, right: int) -> None:
        'a[left] ~ a[right]를 힙으로 만들기'
        temp = a[left]  # 루트 선정

        parent = left   # 부모 노드
        while parent < (right + 1) // 2:
            cl = parent *2 +1   #왼쪽 자식
            cr = cl +1          #오른쪽 자식
            child = cr if cr<= right and a[cr] > a[cl] else cl      #child가 =cr 이기위한 조건
            if temp >= a[child]:        #만약 temp>= a[child] -> 이경우는 이미 더 큰경우라 교환안됨
                break                   #바로 반복문 종료
            a[parent] = a[child]
            parent = child
        a[parent] = temp
```

## `down_heap()` 함수

배열 a에서 a[left]~a[right]의 원소를 힙으로 만든다. a[left]이외에는 모두 힙상태라고 가정하고 a[leftr]를 아랫부분의 앎자은 위치로 옮겨 힙상태를 만든다.

```mm
    n = len(a)

    for i in range((n-1) // 2, -1, -1):     # a[i]~a[n-1]을 힙으로 만들기
        down_heap(a, i, n-1)

    for i in range(n-1, 0, -1):
        a[0], a[i] = a[i], a[0]             # 최댓값인 a[0]와 마지막 원소 교환
        down_heap(a, 0 ,i-1)

if __name__ == '__main__':
    print('힙 정렬을 수행합니다.')
    num = int(input('원소 수를 입력하시오. : '))
    x = [None] * num

    for i in range(num):
        x[i] = int(input(f'x[{i}]: '))

    heap_sort(x)

    print('오름차순으로 정렬했습니다.')
    for i in range(num):
        print(f'x[{i}] = {x[i]}')
```

---

## 힙 정렬의 시간 복잡도

힙 정렬은 선택 정렬을 응용한 알고리즘이다. 단순 선택 정렬은 아직 정렬하지 않은 부분의 모든 원소 중에서 최대값을 선택한다. 힙 정렬은 맨 앞원소를 꺼내는 것만으로 최댓값을 구할 수 있지만 남은 원소를 힙으로 재구성 해야한다.

단순 선택정렬에서 최댓값인 원소를 선택하는 시간 복잡도는 O(N) 이지만, 힙 정렬에서는 다시 힙으로 만드는 작업의 시간 복잡도는 O(logN) 이다.

- 이는 루트를 알맞은 위치까지 내리는 작업이 스캔할때마다 선택 범위가 절반으로 줄어드는 이진 검색과 유사하기 때문이다.

## heqpq 모듈을 사용하는 힙 정렬

파이썬의 heapq 모듈은 힙에 원소를 추가하는 heappush()와 힙에서 원소를 제거하는 heappop() 함수를 제공한다. 이때 푸시와 팝은 힙의 조건을 유지하며 수행된다.
