# C언어

C언어는 현재 사용하고 있는 거의 모든 컴퓨터 시스템에서 사용할 수 있는 프로그래밍 언어이다.

프로그래밍 언어는 크게 `저급 언어(low-level language)`와 `고급 언어(high-level language)` 나뉜다.

저급 언어와 고급 언어는 좋고 나쁜 언어가 아니라, 기계가 이해하기 쉬운가(저급 언어), 사람이 이해하기 쉬운가(고급 언어)를 상대 적으로 나눈 개념이다.

> 저급 언어

`저급 언어`는 컴퓨터가 이해하기 쉽게 작성된 프로그래밍 언어로, 대표적인 언어로는 `기계어(machine language)`와 `어셈블리어(assembly language)` 등이 있다.

이 언어는 실행 속도가 매우 빠르지만, 사람이 배우기에는 매우 어려워 프로그램의 유지보수가 힘들다.

> 고급 언어

고급 언어는 컴퓨터보다는 사람이 알기 쉽도록 작성된 프로그래밍 언어이다.

고급 언어는 컴파일러나 인터프리터에 의해 기계가 이해 할 수 있는 언어로 번역되어 실행된다.

저급 언어보다는 상대적으로 실행 속도가 느리다. 대표적으로 `자바`, `파이썬` 등이 있다. 저급 언어에 비해 가독성이 높고 다루기가 쉽다.

C언어는 저급 언어와 고급 언어의 특징을 모두 가지고 있는 절차 지향 프로그래밍 언어(procedure-oriented programming language)에 해당한다.

# C 언어의 특징

C언어가 가지는 장, 단점은 다음과 같다.

> 장점

1. C언어로 작성된 프로그램은 다양한 하드웨어로의 이식성이 좋다.
2. C언어는 절차 지향 프로그래밍 언어로, 코드가 복잡하지 않아 유지보수가 상대적으로 쉽다.
3. C언어는 저급 언어의 특징을 가지고 있으므로, 어셈블리어 수준으로 하드웨어를 제어할 수 있다.
4. C언어는 코드가 간결하여, 완성된 프로그램의 크기가 작고 실행 속도가 빠르다.

> 단점

1. C언어는 저급 언어의 특징을 지니고 있어, 자바와 같은 다른 고급 언어보다 배우기가 쉽지 않다.
2. C언어는 다른 언어와는 달리 시스템 자원을 직접 제어할 수 있어 프로그래밍하는데 세심한 주의를 기울여야 한다.

# C 프로그래밍

프로그래밍이란 목적에 맞는 알고리즘으로부터 프로그래밍 언어를 사용하여 구체적인 프로그램을 작성하는 과정을 의미한다.

C언어에서는 작성된 프로그램이 실행파일로 변환되어야 실행할 수 있다.

C언어에서 실행 파일을 생성하는 순서이다.
<img src="http://tcpschool.com/lectures/img_c_programming.png">

1. 소스 파일(source file)의 작성
2. 선행처리기(preprocessor)에 의한 선행처리
3. 컴파일러(compiler)에 의한 컴파일
4. 링커(linker)에 의한 링크
5. 실행 파일(executable file)의 생성

## 1. 소스 파일(source file)의 작성

C언어를 사용하여 문법에 맞게 논리적으로 작성된 프로그램을 원시 파일 또는 소스 파일이라고 부른다.

C언어를 통해 작성된 소스 파일의 확장자는 .c 가 된다.

## 2. 선행처리기(preprocessor)에 의한 선행처리

`선행처리(preprocess)`란 소스 파일 중에서도 `선행처리 문자(#)`로 시작하는 선행처리 지시문의 처리 작업을 의미한다.

이러한 선행처리 작업은 선행처리기(preprocessor)가 수행한다.

선행처리기는 코드를 생성하는 것이 아닌, 컴파일하기 전 컴파일러가 작업하기 좋도록 소스를 재구성해주는 역할만을 한다.

## 3. 컴파일러(compiler)에 의한 컴파일

컴퓨터는 0과 1로 이루어진 이진수로 작성된 기계어만을 이해할 수 있다.

그러나 소스 파일은 개발자에 의해 C언어로 작성되므로, 컴퓨터는 그것을 바로 이해할 수 없다.

따라서 소스 파일을 컴퓨터가 알아볼 수 있는 기계어로 변환시켜야 하는데, 그 작업을 `컴파일(compile)`이라고 부른다.

컴파일은 컴파일러에 의해 수행되며, 컴파일이 끝나 기계어로 변환된 파일을 `오브젝트 파일(object file)`이라고 부른다.

이러한 오브젝트 파일의 확장자는 `.o` 나 `.obj` 가 된다.

## 4. 링커(linker)에 의한 링크

컴파일러에 의해 생성된 오브젝트 파일(`.o` 나 `.obj`)은 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)를 가지고 있지 않는다.

또한, 대부분의 C 프로그램에서 사용하는 C 표준 라이브러리 파일도 포함되어 있지 않다.

이때 하나 이상의 오브젝트 파일과 라이브러리 파일, 시동 코드 등을 합쳐 하나의 파일로 만드는 작업을 `링크(link)`라고 한다.

`링크`는 `링커(linker)`에 의해 수행되며, 링크가 끝나면 하나의 새로운 실행 파일이나 라이브러리 파일이 생성된다.

이처럼 여러 개의 소스 파일을 작성하여 최종적으로 링크를 통해 하나의 실행 파일로 만드는 것을 `분할 컴파일`이라고 부른다.

## 5. 실행 파일(executable file)의 생성

소스 파일은 선행처리기, 컴파일러 그리고 링커에 의해 위와 같은 과정을 거쳐 실행 파일로 변환된다.

최근 사용되는 개발 툴은 대부분 위에서 소개한 선행처리기, 컴파일러, 링커를 모두 내장하고 있기 때문에 소스 파일에서 한 번에 실행 파일을 생성해 준다.

이렇게 생성된 실행 파일의 확장자는 `.exe` 가 된다.

# C 프로그램의 구조

간단한 C 프로그램의 기본 구조는 다음 예제와 같습니다.

> 예제 )

```c
#include 문
#define 문

int main(void)

{
    명령문;
    ...
    return 문;
}
```

> 예제 )

```c
#include <stdio.h>
#define TEXT "Welcome to C Programming!!"

int main()

{
    printf(TEXT);
    return 0;
}
// 실행결과 = Welcome to C Programming!!
```

## C 프로그램의 특징

C언어로 작성된 프로그램이 가지는 일반적인 특징은 다음과 같다.

1. C 프로그램의 기본 단위는 함수이다.
2. 함수 내의 각 명령문은 세미콜론(;)으로 끝나야 한다.
3. C언어는 대소문자를 구분한다.
4. C언어는 자유 형식(free-format)을 허용한다.

## 또한 C프로그램의 기본 단위는 함수이다.

C프로그램은 하나 또는 그 이상의 함수(function)으로 이뤄진다.

또한, C언어로 구현되는 모든 프로그램은 반드시 main()함수를 가지고 있어야 한다. 왜냐하면 C 프로그램이 실행되면 컴퓨터는 제일 먼저 main()함수를 찾아서 호출하기 때문이다.

```c
#include <stdio.h>
#define TEXT "Welcome to C Programming!!"

int main()
{
    return 0;     // main() 함수의 모든 명령문을 수행한 후에는 0을 반환함.
}
```

## 또한 함수 내의 각 명령문은 세미콜론(;)으로 끝나야 한다.

함수는 언제나 기능을 가지고 있어야 한다. C언어에서 이러한 기능을 정의하기 위해 사용되는 문장을 명령문(statement)라고 한다.

함수 내의 명령문은 언제나 위에서부터 아래로 순차적으로 실행되며, 언제나 세미콜론(;)으로 끝나야 한다.

> EX)

```c
printf("C언어"); // 정상적으로 출력됨.
printf("C언어") // 오류가 발생함.
```

## C언어는 대소문자를 구분한다.

C언어에서 변수나 함수의 이름을 작성할 때나 키워드나 예약 등을 사용할 때는 대소문자를 정확히 구분하여 사용해야 한다.

> 예제

```c
printf("C언어"); // 정상적으로 출력됨.
Printf("C언어")  // 오류가 발생함.
```

## C언어는 자유 형식(free-format)을 허용한다.

C언어에서는 문법만 맞으면 여러 개의 명령문을 한 줄에 쓸 수도 있고, 하나의 명령문을 여러 줄에 나누어 쓸 수도 있다.

하지만 프로그램의 구조를 한눈에 파악할 수 있도록, 될 수 있으면 들여쓰기 등을 잘 활용해 보기 좋게 작성하는 것이 좋다.

다음 두 예제는 동일한 동작을 한다.

> 예제

```c
int func() { printf("C언어는 재밌어요!"); }
```

```c
int func()
{
    printf("C언어는 재밌어요!");
}
// 그러나 코드의 가독성을 위해 들여쓰기를 사용하여 코들들 작성하는 것이 좋다.
```

# 주석(comments)

주석은 코드에 대한 이해를 돕는 설명을 적거나 디버깅을 위해 작성한다.

C언어의 한 줄 주석은 시작위치에 //을 사용하고, 여러 줄 주석은 /_로 시작해서 반드시 _/로 끝나야 한다.

> 문법

```c
// 한 줄 주석

/* 여러
   줄
   주석 */
```

> 예제

```C
/* 여러 줄
    // 이렇게 두 줄 주석 안에 또 다른 한 줄 주석을 삽입할 수 있습니다.
주석입니다. */
```

C언어에서는 여러 줄 주석 안에 또 다른 한 줄 주석은 삽입할 수 있다.

하지만 다음 예제처럼 여러 줄 주석 안에 또 다른 여러 줄 주석은 중첩해서 삽입할 수 없다.

> 예제

```c
① /* 여러 줄
②    /* 또 다른 여러 줄 주석입니다. */
③ 주석입니다. */
```

위의 예제처럼 여러 줄 주석 안에 또 다른 여러 줄 주석을 삽입하면, 2번 라인에서 삽입한 주석의 `종료 기호(*/)`를 1번 라인에서 시작한 첫 번째 주석이 자신의 `종료 기호(*/)`로 잘못 인식하게 된다.

따라서 위 예제의 3번 라인은 주석으로 인식되지 못하고, 컴파일 시 오류가 발생한다.

그렇기 때문에 C언어에서 여러 줄 주석은 절대로 중첩해서 사용하면 안 된다.

```c
#include <stdio.h>
#define TEXT "Welcome to C Programming!!"

/* 여기서부터 main() 함수 시작 부분임.
    작성자 : 이필웅(Lenol) */

int main()
{
    printf(TEXT); // printf() 함수는 인자로 전달받은 데이터를 출력해주는 함수이다.
    return 0;   // main()함수의 모든 명령문을 수행한 후에 반환하는 부분. (여기선 0을 반환)
}
```

## printf() 함수

printf() 함수란 C 언어 표준 입출력 함수이다.

- 입출력 함수란?
  사용자가 프로그램과 대화하기 위해 사용하는 함수를 입출력 함수 or I/O(In/Out) 함수라고 한다.

printf() 함수와 scanf() 함수는 C언어 표준 입출력 함수중에서도 가장 많이 사용되는 대표적인 입출력 함수이다.

printf()함수는 여러 종류의 데이터(data)를 다양한 서식에 맞춰 출력할 수 있게 해준다.

> 함수 원형

```c
#include <stdio.h>
int printf(const char * restrict format, ...);
```

printf 에서 f는 formatted의 약자이며, 서식화된 출력을 지원한다는 의미이다.

이 함수는 출력할 데이터를 어떤 서식에 맞춰 출력할지 서식 지정자(format specifier)를 통해 직접 지정할 수 있다.

> 예제

```c
printf("printf() 함수는 서식 지정자를 통해 출력할 데이터의 서식을 지정할 수 있어요!\n");
// printf() 함수는 서식 지정자를 통해 출력할 데이터의 서식을 지정할 수 있어요!  -> 출력됨

printf("변수에 저장된 숫자는 %d입니다.", 10);
// 변수에 저장된 숫자는 10입니다. -> 출력됨
```

위의 예제에서 int형 데이터를 나타내기 위해 `%d`와 같은 서식 지정자를 사용했다.

또한 줄 바꿈은 흔히 아는 `\n`이라는 이스케이프 시퀀스를 사용하여 표현하고 있다.

## 이스케이프 시퀀스(escape sequence)

`\n`과 같은 문자를 이스케이프 시퀀스(escape sequence)라고 한다.

| 서식지정자 |       출력데이터 형태        |
| :--------: | :--------------------------: |
|     \'     |          작은따옴표          |
|     \"     |           큰따옴표           |
|     \?     |            물음표            |
|    `\\`    |        백슬래시`(\)`         |
|     \a     |         경고음 발생          |
|     \b     |    백스페이스(backspace)     |
|     \n     |      줄 바꿈(new line)       |
|     \r     | 캐리지 리턴(carriage return) |
|     \t     |         수평 탭(tab)         |
|     \v     |         수직 탭(tab)         |
|     \f     |      폼 피드(form feed)      |

> 예제

```c
#include <stdio.h>
#define TEXT "C언어에서 사용하는 \'특수 문자\'에는 여러가지가 있습니다. \n"
#define TEXT2 "\t특수 문자의 바로 앞에는 언제나 \\가 와야 합니다."

int main()
{
  printf(TEXT);
  return 0;
}
// C언어에서 사용하는 '특수 문자'에는 여러가지가 있습니다. -> 출력됨

// 	특수 문자의 바로 앞에는 언제나 \가 와야 합니다. -> 출력됨
```

## 서식 지정자(format specifier)

앞선 예제에서 두 번째 printf() 함수에 나온 `%d`와 같은 문자를 서식 지정자(format specifier)라고 한다.

printf() 함수에서는 이러한 서식 지정자를 통해 출력할 데이터의 서식을 사용자가 직접 지정할 수 있다.

C언어에서 사용되는 대표적인 서식 지정자는 다음과 같다.

| 서식 지정자 |                     출력 데이터 형태                     |
| :---------: | :------------------------------------------------------: |
|     %c      |                       하나의 문자                        |
|     %s      |                          문자열                          |
|     %d      |                   부호 있는 10진 정수                    |
|     %i      |             부호 있는 10진 정수 (%d와 동일)              |
|     %f      | 고정 소수점으로 표현한 실수 (소수점 이하 6자리까지 표현) |
|     %o      |                    부호 없는 8진 정수                    |
|     %u      |                   부호 없는 10진 정수                    |
|     %x      |            부호 없는 16진 정수 (소문자 사용)             |
|     %X      |            부호 없는 16진 정수 (대문자 사용)             |
|     %e      |          부동 소수점으로 표현한 실수 (e-표기법)          |
|     %E      |          부동 소수점으로 표현한 실수 (E-표기법)          |
|     %g      |               값에 따라 %f나 %e를 사용함.                |
|     %G      |               값에 따라 %f나 %E를 사용함.                |
|     %%      |                   퍼센트(%) 기호 출력                    |

> 예제

```c
#include <stdio.h>

int main()
{
  printf("%%c를 사용한 결과 : %c\n", 'a');            // 문자, 출력값 : %c를 사용한 결과 : a
  printf("%%s를 사용한 결과 : %s\n", "즐거운 C언어"); // 문자열, 출력값 : %s를 사용한 결과 : 즐거운 C언어

  printf("%%f를 사용한 결과 : %f\n", 0.123456); // 출력값 : %f를 사용한 결과 : 0.123456
  printf("%%f를 사용한 결과 : %f\n", 0.123456789);    // 소수점 6자리까지만 표현, 출력값 : %f를 사용한 결과 : 0.123457

  printf("%%o를 사용한 결과 : %o\n", 123);            // 8진 정수, 출력값 : %o를 사용한 결과 : 173
  printf("%%x를 사용한 결과 : %x\n", 123);            // 16진 정수, 출력값 : %x를 사용한 결과 : 7b

  printf("%%g를 사용한 결과 : %g\n", 0.001234);       // 값에 따라 %f나 %e, 출력값 : %g를 사용한 결과 : 0.001234
  printf("%%g를 사용한 결과 : %g\n", 0.00001234);     // 값에 따라 %f나 %e, 출력값 : %g를 사용한 결과 : 1.234e-05
  printf("%%G를 사용한 결과 : %G\n", 0.000001234);    // 값에 따라 %f나 %E, 출력값 : %G를 사용한 결과 : 1.234E-06
}
```

## 서식 지정자의 동시 사용

여러 개의 서식 지정자를 동시에 사용하여 다른 데이터값을 한번에 출력할 수 있다.

이때 서식 지정자의 순서와 타입은 출력할 데이터의 순서나 타입과 일치해야 한다.

> 예제

```c
#include <stdio.h>

int main()
{
  printf("저장된 정수는 %d이며, 저장된 문자열은 %s입니다.\n", 123, "C언어");
    // 출력값 : 저장된 정수는 123이며, 저장된 문자열은 C언어입니다.
}
```

## 출력 필드의 폭 설정

서식 지정자의 `%`기호와 타입을 나타내는 영문자 사이에 숫자를 추가하여 출력되는 필드의 폭을 직접 설정할 수 있다.

내부의 숫자는 오른쪽 정렬이 기본값이며, 숫자 앞에 '-' 기호를 붙이면 왼쪽 정렬로 바뀐다.

또한, 숫자 앞에 '+'기호를 붙이면 숫자를 오른쪽 정렬한 상태에서 양수에는 '+' 기호를, 음수에는 '-' 기호를 붙여서 출력한다.

이때 소수 부분의 숫자는 출력되는 소수의 자릿수를 명시해야 한다.

> 예제

```c
#include <stdio.h>

int main()
{
  printf(" %%d를 사용한 결과 : |%d|\n", 123); // 출력값 : %d를 사용한 결과 : |123|

  printf(" %%7d를 사용한 결과 : |%7d|\n", 123);  // 출력값 : %7d를 사용한 결과 : |    123|

  printf(" %%+7d를 사용한 결과 : |%+7d|\n", 123);  // 출력값 : %+7d를 사용한 결과 : |   +123|

  printf(" %%-7d를 사용한 결과 : |%-7d|\n\n", 123);  // 출력값 : %-7d를 사용한 결과 : |123    |

  printf(" %%f를 사용한 결과 : |%f|\n", 1.23);  // 출력값 : %f를 사용한 결과 : |1.230000|

  printf(" %%.1f를 사용한 결과 : |%.1f|\n", 1.23);  // 출력값 : %.1f를 사용한 결과 : |1.2|

  printf(" %%7.2f를 사용한 결과 : |%7.2f|\n", 1.23);  // 출력값 : %7.2f를 사용한 결과 : |   1.23|

  printf("%%+7.2f를 사용한 결과 : |%+7.2f|\n", 1.23);  // 출력값 : %+7.2f를 사용한 결과 : |  +1.23|

  printf("%%-7.2f를 사용한 결과 : |%-7.2f|\n\n", 1.23);  // 출력값 : %-7.2f를 사용한 결과 : |1.23   |
}
```

## scanf() 함수

scanf() 함수 또한 C언어의 대표적인 표준 입력 함수로, 사용자로부터 다양한 데이터를 다양한 서식에 맞춰 입력받을 수 있게 한다.

scanf() 함수의 원형은 다음과 같다.

> 함수 원형

```C
#include <stdio.h>

int scanf(const char * restrict format, ...);
```

여기서 f는 printf()의 경우와 동일하다.

> 예제

```c
#include <stdio.h>

int main()
{
    int num01, num02;

    printf("첫 번째 정수를 입력하세요 : ");
    scanf("%d", &num01);

    printf("두 번째 정수를 입력하세요 : ");
    scanf("%d", &num02);

    printf("입력하신 두 정수의 합은 %d입니다.\n", num01 + num02);
    return 0;
}
// 실행 결과
첫 번째 정수를 입력하세요 : 10
두 번째 정수를 입력하세요 : 20
입력하신 두 정수의 합은 30입니다.
```

C언어에서 데이터를 입력받으려면 입력받고자 하는 데이터의 타입에 해당하는 크기의 메모리를 우선 할당받아야 한다.

이처럼 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 `변수(variable)`라고 한다.

앞선 예제에서 scanf() 함수에 포함된 `&`기호는 `주소 연산자(&)`라고 한다.

이 주소 연산자는 입력받은 데이터를 뒤에 나오는 변수에 저장하라는 의미이다.

## 서식 지정자의 동시 사용

여러 개의 서식 지정자를 동시에 사용하여, 여러 데이터를 서로 다른 서식으로 한 번에 입력받을 수 있다.

입력받는 데이터의 구분은 공백(줄 바꿈, 탭, 띄어쓰기 등)을 기준으로 삼는다. 또한 이때에도 서식 지정자의 순서, 변수의 순서등이 같아야 한다.

> 예제

```c
#include <stdio.h>

int main(void)
{
    int num01, num02;

    printf("두 개의 정수를 입력하세요 : ");
    scanf("%d %d", &num01, &num02);

    printf("입력하신 두 정수를 8진수로 나타내면 %o와 %o가 되고,\n", num01, num02);
    printf("입력하신 두 정수를 16진수로 나타내면 %x와 %x가 됩니다.\n", num01, num02);

    return 0;
}
// 실행 결과
두 개의 정수를 입력하세요 : 10 20
입력하신 두 정수를 8진수로 나타내면 12와 24가 되고,
입력하신 두 정수를 16진수로 나타내면 a와 14가 됩니다.
```

## double형 실수의 입력

scanf() 함수로 float형 실수를 입력받을 때는 서식 지정자로 '%f'를 사용하면 뙨다.

하지만 double형 실수를 입력받을 때는 printf() 함수에서처럼 '%f'를 사용하면 안 된다.

- 여기서 double형 이란??

        double형 실수란 실수형 변수 선언의 한 종류로써 float형과 더불어 사용된은 표현이다.
        float형보다 크기가 더 크며 소수점 이하 표현 자리수도 더 길다.

* float형(4바이트, 32비트, 소수점 이하 7자리까지 표현)

* double형(8바이트, 64비트, 소수점 이하 15자리까지 표현)

scanf() 함수로 double형 실수를 입력받을 때는 반드시 `%lf` 서식 지정자를 사용해야 정확한 값으로 입력받을 수 있다.

> 예제

```c
#include <stdio.h>

int main(void)

{
    float num01;
    double num02;

    printf("두 개의 실수를 입력하세요 : ");
    scanf("%f %f", &num01, &num02);
    printf("입력하신 두 실수는 %f와 %f입니다.\n", num01, num02);
    printf("입력받은 두 실수 중 두 번째 double형 변수에는 전혀 다른 값이 저장되었습니다.\n\n");

    printf("다시 한 번 두 개의 실수를 입력하세요 : ");
    scanf("%f %lf", &num01, &num02);
    printf("입력하신 두 실수는 %f와 %f입니다.\n", num01, num02);
    printf("이번에는 두 실수 모두 제대로 저장되었습니다.\n");
    return 0;
}
```

```C
// 실행 결과
두 개의 실수를 입력하세요 : 1.2 3.4
입력하신 두 실수는 1.200000와 0.000000입니다.
입력받은 두 실수 중 두 번째 double형 변수에는 전혀 다른 값이 저장되었습니다.

다시 한 번 두 개의 실수를 입력하세요 : 1.2 3.4
입력하신 두 실수는 1.200000와 3.400000입니다.
이번에는 두 실수 모두 제대로 저장되었습니다.
```

---

# 변수(Variable)

`변수(variable)`란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다.

즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 이렇게 저장된 값은 변경될 수 있다.

C언어에서 숫자 표현에 관련된 변수는 정수형 변수와 실수형 변수로 구분할 수 있다.

또한, 데이터가 저장된 메모리의 주소를 저장하고 처리하는 포인터 변수가 있다. 동시에 관련된 정보를 한 번에 묶어서 처리하는 사용자 정의 구조체 변수도 있다.

## 변수의 이름 생성 규칙

C언어에서는 변수의 이름을 비교적 자유롭게 지을 수 있다.

하지만 변수의 이름은 해당 변수에 저장될 데이터의 의미를 잘 나타내도록 짓는 것이 가장 좋다.

C언어에서 변수의 이름을 생성할 때에 반드시 지켜야 하는 규칙은 다음과 같다.

1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(\_)로만 구성된다.

2. 변수의 이름은 숫자로 시작될 수 없다.

3. 변수의 이름 사이에는 공백을 포함할 수 없다.

4. 변수의 이름으로 C언어에서 미리 정의된 키워드(keyword)는 사용할 수 없다.

> 🏷 변수명 생성 규칙 예시

| 변수의 이름이 올바른 경우 | 변수의 이름이 잘못된 경우 |                     잘못된 이유                      |
| :-----------------------: | :-----------------------: | :--------------------------------------------------: |
|          int tcp          |        int t!cp\*         | 변수 이름이 영문자,숫자, \_ 외에 특수문자 사용하였음 |
|        int school         |        int 6school        |            변수 이름이 숫자로 시작하였음             |
|       int tcpschool       |      int tcp school       |      변수 이름 tcp와 school 사이에 공백이 있음       |
|         int int2          |          int int          |       변수 이름에 int라는 키워드를 사용하였음        |

- C언어에서는 변수의 이름에 대소문자를 구분하므로 이 점에 주의해야 한다.

  📝 ex) int tcp 과 int Tcp 는 같은 변수가 아니다.

## C언어에서 사용되는 키워드(keyword)들

키워드(keyword)는 고유한 의미를 가지는 예약어이다. C언어에서는 32개의 키워드가 있으며, 이러한 키워드들은 미국표준협회 ANSI에서 지정한 키워드들 이다.

|          |        |          |        |          |          |         |
| :------: | :----: | :------: | :----: | :------: | :------: | :-----: |
|   auto   |  beak  |   case   |  char  |  const   | continue | default |
|    do    | double |   else   |  enum  |  extern  |  float   |   for   |
|   goto   |   if   |   int    |  long  | register |  return  |  short  |
|  signed  | sizeof |  static  | struct |  switch  | typedef  |  union  |
| unsigend |  void  | volatile | while  |

## 변수와 메모리 구조

변수는 기본적으로 메모리의 주소(address)를 기억하는 역할을 한다.

메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자이다.

즉, 메모리 주소란 메모리 공간에서의 정확한 위치를 식별하기 위한 고유 주소를 의미한다.

변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 된다.

따라서 변수는 데이터가 저장된 메모리의 주소뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 한다.

<img src=http://tcpschool.com/lectures/img_c_variable.png>

< 메모리 상에 변수가 저장되는 방식.img>

위 그림처럼 하나의 메모리 공간에는 8개의 비트로 이루어진 1바이트의 데이터가 저장된다.

따라서 메모리의 주소 또한 1바이트씩 증가되며, 낮은 주소부터 차례대로 데이터가 저장되는 방식이다.

위의 그림에서 변수의 길이가 총 4개의 메모리 공간을 포함하므로, 해당 변수에는 4바이트의 데이터가 저장되어 있다.

이때 변수의 이름은 첫 번째 메모리 주소인 0x10만을 가리키게 된다.

따라서 길이는 4이며, 변수가 어떤 형태로 구성되는지도 알아야만 해당 변수에서 데이터를 올바르게 참조할 수 있다.

## 변수의 선언

C언어에서는 변수를 사용하기 전에 반드시 먼저 해당 변수를 저장하기 위한 메모리 공간을 할당받아야 한다.

이렇게 해당 변수만을 위한 메모리 공간을 할당받는 행위를 변수의 선언이라고 부른다.

만약 선언되지 않은 변수를 사용하려고 하면, C 컴파일러는 오류를 발생시킨다.

C언어에서 변수를 선언하는 방법은 다음과 같이 두 가지 방법이 있다.

1. 변수의 선언만 하는 방법
2. 변수의 선언과 동시에 초기화하는 방법

## 변수의 선언만 하는 방법

이 방법은 먼저 변수를 선언하여 메모리 공간만을 할당받고, 나중에 변수를 초기화하는 방법이다.

C언어에서 변수를 선언하는 방법은 다음과 같다.

> 문법

```c
타입 변수이름;
```

> 📝 예제

```c
int num;
...
num = 20;
```

위의 예제처럼 정수를 저장하기 위해 메모리 공간을 할당받으면, 반드시 해당 타입의 데이터만을 저장해야 한다.

그러지 않고 다른 타입의 데이터를 젖아할 경우 저장된 데이터에 변형 및 손실이 일어날 수 있다.

변수의 초기화란 해당 변수를 사용할 수 있도록 초기값을 설정하는 행위이다.

초기화되지 않은 변수에는 아무런 의미 없는 쓰레깃 값만이 들어가 있다.

> 📝 예제

```c
int num;
printf("%d", num);
```

위의 예제에서 변수 num은 선언만 했을 뿐 아직 초기화되지 않았다.

하지만 printf() 함수에서 변수 num을 사용해 해당 변수에 저장된 값을 출력하려고 하고 있다.

이러한 경우 c 컴파일러는 오류를 발생시키지 않겠지만, 프로그램은 사용자가 의도하지 않은 결과를 출력할 것이다.

따라서 C언어에서는 초기화되지 않은 변수는 절대로 사용하면 안된다.

## 변수의 선언과 동시에 초기화하는 방법

그렇기 때문에 C언어에서 변수는 선언과 동시에 그 값을 초기화할 수 있다.

또한, 선언하고자 하는 변수들의 타입만 같다면 여러 변수를 동시에 선언할 수도 있다.

> 문법

1. 타입 변수이름[, 변수이름];
2. 타입 변수이름 = 초깃값[, 변수이름 = 초깃값];

> 📝 예제

```c
int num01, num02;
double num03 = 1.23, num04 = 4.56;
```

- 🚩 선언하고자 하는 변수의 타입이 서로 다르면 동시에 선언이 불가능하다.

# 상수(Constant)

상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미한다.

하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 상수에 저장된 데이터는 변경할 수 없다는 점이다.

상수는 때문에 표현 방식에 따라 다음의 케이스들로 나뉘게 된다.

1. 리터럴 상수(literal constant)

2. 심볼릭 상수(symbolic constant)

## 리터럴 상수(literal constant)

리터럴 상수(literal constant)는 변수와 달리 데이터가 저장된 메모리 공간을 가리키는 이름을 가지고 있지 않다.

C언어에서는 적절한 메모리 공간을 할당받기 위해선 기본적으로 변수던 상수던 타입을 지녀야 한다.

리터럴 상수는 타입에 따라 크게 3가지로 구분할 수 있다.

1. 정수형 리터럴 상수 // 123, -456과 같이 아라비아 숫자와 부호로 직접 표현되는 상수

2. 실수형 리터럴 상수 // 3.14, -45.6과 같이 소수 부분을 가지는 아라비아 숫자로 표현되는 상수

3. 문자형 리터럴 상수 // 'a', 'Z'와 같이 따옴표('')로 감싸진 문자로 표현되는 상수

## 심볼릭 상수(symbolic constant)

심볼릭 상수는 변수와 마찬가지로 이름을 지니는 상수이다.

그렇기 때문에 심볼릭 상수는 반드시 선언과 동시에 초기화되어야 한다.

심볼릭 상수는 `const` 키워드를 사용하거나, 매크로를 이용하여 선언할 수 있다.

> 📝 예제

```c
const int MAX = 10; // const 키워드를 이용한 심볼릭 상수

#define MAX 10;     // #define 선행처리 지시자를 이용한 심볼릭 상수
```

# 기본 타입

C언어에서 타입(data tpye)이란 해당 데이터가 메모리에 어떻게 저장되고, 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 역할을 한다.

따라서 C언어는 여러 형태의 타입을 미리 작성하여 제공하는데 이들을 `기본 타입`이라고 부른다.

기본타입은 크게 `정수형`, `실수형`, `문자형` 타입 3가지로 나눌 수 있다.

## 정수형 타입

C언어에서 정수란 부호를 가지고 있고, 소수 부분이 없는 수를 의미한다.

정수형 데이터에 unsigned 키워드를 추가하면, 부호를 나타내는 최상위 비트(MSB = Most Significant Bit)까지도 크기를 나타내는 데 사용할 수 있다.

- 🚩 최상위 비트(MSB, Most Significant Bit)란?

        최상위 비트(MSB, Most Significant Bit)란 1바이트를 구성하는 8개의 비트 중 최고값을 갖는 비트를 의미한다.

위의 말이 무슨 말이냐 하면 char와 int의 signed 정수형 변수에서는 최상위 비트(MSB)가 부호 비트이다.

최상위 비트가 1이면 음수이고 0이면 양수이다. 그러나 unsigned을 사용하면 음수를 사용하지 않겠다는 의미 이므로 이 부호 비트까지 크기를 나타내는 데 이용할 수 있다는 의미이다.

그렇기 때문에 이러한 unsigned 정수는 음수를 표현할 수는 없게 되지만, 0을 포함한 양의 정수는 두 배 더 많이 표현할 수 있게 된다.

음의 정수까지도 표현할 수 있는 signed 키워드는 모든 타입에서 기본적으로 생략하여 사용할 수 있다.

|  정수형 타입   | 할당되는 메모리의 크기 |       데이터의 표현 범위        |
| :------------: | :--------------------: | :-----------------------------: |
| (signed) short |        2 바이트        |        - 32,768 ~ 32,767        |
| unsigned short |        2 바이트        |          - 0 ~ 65,535           |
|  (signed) int  |        4 바이트        | - 2,147,483,648 ~ 2,147,483,647 |
|  unsigned int  |        4 바이트        |       - 0 ~ 4,294,967,296       |
| (signed) long  |        4 바이트        | - 2,147,483,648 ~ 2,147,483,647 |
| unsigned long  |        4 바이트        |       - 0 ~ 4,294,967,296       |

정수형 데이터의 타입을 결정할 때에는 반드시 내가 사용하고자 하는 데이터의 최대 크기를 고려해야 한다.

해당 타입이 표현할 수 있는 벙뮈를 벗어난 데이터를 저장하면, 오버플로우가 발생해 값이 전혀 다르게 될 수 있기 때문이다.

## 오버플로우(overflow)란 ?

오버플로우(overflow)란 해당 타입이 표현할 수 있는 최대 범위보다 큰 수를 저장할 때 발생하는 현상을 가리킨다.

오버플로우가 발생하면 최상위 비트(MSB)를 벗어난 데이터가 인접 비트를 덮어쓰므로, 잘못된 결과를 얻을 수 있다.

반대의 경우로 `언더플로우(underflow)`가 있는데 이는 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생하는 현상을 가리킨다.

> 📝 예제

```c
int num = 2147483647; // int형 타입이 저장할 수 있는 최댓값인 231 - 1
printf("변수 num에 저장된 값은 %d입니다.\n", num);

num = 2147483648;     // int형 타입이 저장할 수 없는 숫자인 231
printf("변수 num에 저장된 값은 %d입니다.\n", num);
```

```c
// 실행결과
변수 num에 저장된 값은 2147483647입니다.

변수 num에 저장된 값은 -2147483648입니다.
```

두 번째 실행 결과를 살펴보면, 변수 num에 양수를 대입했지만 음수로 저장된 것을 확인할 수 있다.

이처럼 오버플로우가 발생하면 전혀 예상치 못한 결과를 얻을 수 있으므로, 데이터를 저장할 때는 언제나 해당 데이터 타입의 최대 크기까지 고려해야 한다.

## 실수형 타입

C언어에서 실수란 소수부나 지수가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다.

하지만 컴퓨터에서 실수를 표현하는 방식은 반드시 오차가 발생하는 기술적 한계를 지닌다.

이러한 실수형 데이터의 오차는 C언어뿐만 아니라 모든 프로그래밍 언어에서 발생하는 공통된 문제이다.

| 실수형 타입 | 할당되는 메모리의 크기 |       데이터의 표현 범위       |
| :---------: | :--------------------: | :----------------------------: |
|    float    |        4 바이트        |  (3.4 X 10-38) ~ (3.4 X 1038)  |
|   double    |        8 바이트        | (1.7 X 10-308) ~ (1.7 X 10308) |
| long double |   double형과 동일함    |       double형과 동일함        |

> 📝 예제

```c
float num01 = 3.1415926535897932;  // float 타입의 유효 자릿수는 소수점 6자리
printf("변수 pi에 저장된 값은 %.20f입니다.\n", num01);

double num02 = 3.1415926535897932; // double 타입의 유효 자릿수는 소수점 16자리
printf("변수 pi에 저장된 값은 %.20f입니다.\n", num02);
```

```c
//실행 결과
변수 num01에 저장된 값은 3.14159274101257324219입니다.

변수 num02에 저장된 값은 3.14159265358979311600입니다.
```

위의 예제에서 변수 num01에는 소수점 6자리까지만 정확한 값이 저장되어 있고, 소수점 7자리부터는 틀린 값이 저장되어 있다.

또한, 변수 num02에는 소수점 15자리까지만 정확한 값이 저장되어 있고, 소수점 16자리부터는 틀린 값이 저장되어 있는 것을 확인할 수 있다.

이처럼 실수형 데이터의 타입을 결정할 때는 표현 범위 이외에도 유효 자릿수를 반드시 고려해야 한다.

| 실수형 타입 | 지수의 길이 | 가수의 길이 | 유효 자릿수 |
| :---------: | :---------: | :---------: | :---------: | ----------------------------------- |
|    float    |   8 비트    |   23 비트   |  소수 부분  | 6자리까지 오차없이 표현할 수 있음.  |
|   double    |   11 비트   |   52 비트   |  소수 부분  | 15자리까지 오차없이 표현할 수 있음. |

과거에는 실수를 표현할 때 float형을 많이 사용했었다고 하는데 요근래에는 하드웨어의 발달로 인한 메모리 공간의 증가로 현재에는 double형을 가장 많이 사용한다.

## 문자형 타입

C언어에서 문자형 데이터란 문자 하나를 표현할 수 있는 타입을 의미한다.

컴퓨터는 2진수밖에 인식하지 못하므로, 문자도 숫자로 표현해야 컴퓨터가 인식할 수 있다.

이러한 약속 중에서 가장 많이 사용되는 것이 바로 아스키코드(ASCII)이다.

아스키코드(ASCII)는 영문 대소문자를 사용하는 7비트의 문자 인코딩 방식이다.

아스키코드는 문자를 7비트로 표현하므로, 총 128개의 문자를 표현할 수 있다.

## 아스키코드(ASCII)의 구성

아스키코드의 구성은 다음과 같다.

- 출력할 수 없는 33개의 문자

- 출력할 수 있는 52개의 영문 대소문자, 10개의 숫자, 32개의 특수 문자와 1개의 공백 문자

|  문자형 타입  | 할당되는 메모리의 크기 |       데이터의 표현 범위       |
| :-----------: | :--------------------: | :----------------------------: |
| (signed) char |        1 바이트        | 2<sup>7</sup> ~ 2<sup>-7</sup> |
| unsigned char |        2 바이트        |       0 ~ 2<sup>-8</sup>       |

다음 예제는 char형 변수에 저장된 문자를 여러 서식 지정자를 사용해 출력하는 예제이다.

> 📝 예제

```c
char ch = 'a';
printf("변수 ch에 저장된 값은 %c입니다.\n", ch);
//변수 ch에 저장된 값은 a입니다.
printf("변수 ch에 저장된 값은 %d입니다.\n", ch);
//변수 ch에 저장된 값은 97입니다.
```

위의 예제에서 서식 지정자 '%c'를 사용하여 출력한 결과는 제대로 문자 'a'가 출력된다.

하지만 서식 지정자 '%d'를 사용하여 출력한 결과는 97이라는 숫자로 출력된다.

즉, 이것은 문자가 C++ 내부적으로는 아스키코드에 해당하는 숫자로 저장되어 있음을 보여준다.

# 타입 변환(Type conversion)

C언어에서 다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다.

그렇기 때문에 서로 다른 타입을 같은 타입으로 바꿔줘야 한다. 이러한 행위를 타입 변환(Type conversion)이라 한다.

일반적으로 표현 범위가 좁은 타입에서 표현 범위가 더 넓은 타입으로의 타입 변환은 큰 문제가 되지 않는다.

하지만 반대의 경우인 표현 범위가 좁은 타입으로의 타입 변환에서는 데이터의 손실이 발생한다.

타입 변환은 크게 다음과 같이 두 가지 방식으로 나눌 수 있다.

1. 묵시적 타입 변환(자동 타입 변환)

2. 명시적 타입 변환(강제 타입 변환)

## 묵시적 타입 변환(자동 타입 변환, implicit type conversion)

`묵시적 타입 변환`은 대입 연산이나 산술 연산에서 C 컴파일러가 자동으로 실행해주는 타입 변환을 말한다.

C언어에서는 대입 연산 시 `연산자의 오른쪽에 존재하는 데이터`의 타입이 연산자의 왼쪽에 존재하는 데이터의 타입으로 묵시적 타입 변환이 진행된다.

또한, 산술 연산에서는 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환이 진행된다.

> 📝 예제

아래 예제들은 대입 연산에서 일어나는 묵시적 타입 변환의 사례들이다.

```c
char ch = 200;
int num01 = 3.14;
double num02 = 5;

printf("   ch에 저장된 값은 %d입니다.\n", ch);
// ch에 저장된 값은 -56입니다.

printf("num01에 저장된 값은 %d입니다.\n", num01);
// num01에 저장된 값은 3입니다.

printf("num02에 저장된 값은 %f입니다.\n", num02);
// num02에 저장된 값은 5.000000입니다.
```

위의 예제에서는 char형 변수에 char형 변수가 표현할 수 있는 범위를 넘는 데이터를 저장한다.

따라서 전달된 데이터의 상위 비트가 자동으로 삭제되어 데이터의 손실이 발생한다.

또한, int형 변수에 실수를 저장했기 때문에 소수 부분이 자동으로 삭제되어 데이터의 손실이 발생한다.

하지만 double형 변수에 int형 데이터를 저장하는 것은 데이터가 double형으로 자동 타입 변환되지만, 데이터의 손실은 발생하지 않는다.

> 📝 예제

다음 예제는 산술 연산에서 일어나는 묵시적 타입 변환을 보여준다.

```c
double result01 = 5 + 3.14;
double result02 = 5.0f + 3.14;

printf("result01에 저장된 값은 %f입니다.\n", result01);
// result01에 저장된 값은 8.140000입니다.

printf("result02에 저장된 값은 %f입니다.\n", result02);
// result02에 저장된 값은 8.140000입니다.
```

위의 예제에서 첫 번째 연산은 int형 데이터와 double형 데이터의 산술 연산이다.

따라서 데이터의 손실이 최소화되도록 int형 데이터가 double형 데이터로 자동 타입 변환된다.

두 번째 연산은 float형 데이터와 double형 데이터의 산술 연산이다.

위와 마찬가지로 데이터의 손실이 최소화되도록 float형 데이터가 double형 데이터로 자동 타입 변환된다.

이렇게 컴파일러가 자동으로 수행하는 타입 변환은 언제나 데이터의 손실이 최소화되는 방향으로 이루어집니다.

따라서 C 컴파일러는 다음과 같은 순서대로 자동 타입 변환을 수행하게 된다.

> ✅ 컴파일러 순서

```
char 형 → short 형 → int 형 → long 형 → float 형 → double 형 → long double 형
```

## 명시적 타입 변환(강제 타입 변환, explicit type conversion)

명시적 타입 변환은 사용자가 타입 캐스트(type cast) 연산자를 사용하여 강제적으로 수행하는 타입 변환을 가리킨다.

변환하고자 하는 데이터의 앞에 괄호(())를 추가하고, 그 안에 변환할 타입을 적으면 된다.

C언어에서는 이 괄호(())를 타입 캐스트(type cast) 연산자라고 한다.

> 📝 예제

```c
int num01 = 1;
int num02 = 4;

double result01 = num01 / num02;
double result02 = (double)num01 / num02;

printf("result01에 저장된 값은 %f입니다.\n", result01);
// result01에 저장된 값은 0.000000입니다.

printf("result02에 저장된 값은 %f입니다.\n", result02);
//  result02에 저장된 값은 0.250000입니다.
```

위의 예제에서 첫 번째 연산의 결괏값은 0.000000으로 출력된다.

그 이유는 산술 연산에 대한 결괏값의 타입은 피연산자의 타입과 언제나 일치하기 때문이다.

즉 int형 데이터끼리의 산술 연산에 대한 결괏값은 언제나 int형 데이터로 나온다.

따라서 두 번째 연산에서처럼 하나의 피연산자를 명시적으로 double형으로 지정해야만 정확한 결괏값을 얻을 수 있다.

# 연산자(operator)

연산자(operator)란 프로그램의 산술식이나 연산식을 표현하고 처리하기 위해 제공되는 다양한 기호를 의미한다.

C언어에서는 여러 종류의 연산을 위해 다양한 연산자를 제공하고 있다.

## 산술 연산자(arithmetic operator)

산술 연산자는 사칙연산을 다루는 기본적이면서도 가장 많이 사용되는 연산자다.

산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

- 🚩 항이란 해당 연산의 실행이 가능하기 위해 필요한 값이나 변수를 의미한다. 따라서 이항 연산자란 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자를 의미한다.

> 🏷 산술 연산자 표

| 산술 연산자 |                               설명                                |
| :---------: | :---------------------------------------------------------------: |
|      +      |            왼쪽의 피연산자에 오른쪽의 피연산자를 더함             |
|      -      |            왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌             |
|     \*      |            왼쪽의 피연산자에 오른쪽의 피연산자를 곱함             |
|      /      |            왼쪽의 피연산자를 오른쪽의 피연산자로 나눔             |
|      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함 |

> 📝 예제

```c
int num01 = 10;
int num02 = 4;

printf("+ 연산자에 의한 결괏값은 %d입니다.\n", num01 + num02); // + 연산자에 의한 결괏값은 14입니다.
printf("- 연산자에 의한 결괏값은 %d입니다.\n", num01 - num02); // - 연산자에 의한 결괏값은 6입니다.
printf("* 연산자에 의한 결괏값은 %d입니다.\n", num01 * num02); // * 연산자에 의한 결괏값은 40입니다.
printf("/ 연산자에 의한 결괏값은 %d입니다.\n", num01 / num02); // / 연산자에 의한 결괏값은 2입니다.
printf("% 연산자에 의한 결괏값은 %d입니다.\n", num01 % num02); // % 연산자에 의한 결괏값은 2입니다.
```

## 연산자의 우선순위(operator precedence)와 결합 방향(associativity)

연산자의 우선순위는 수식 내에 여러 연산자가 함께 등장할 때, 어느 연산자가 먼저 처리될 것인가를 결정한다.

다음 그림은 가장 높은 우선순위를 가지고 있는 괄호(()) 연산자를 사용하여 연산자의 처리 순서를 변경하는 것을 보여준다.

## 대입 연산자(assignment operator)

대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽이다.

또한, 앞서 살펴본 산술 연산자와 결합한 다양한 복합 대입 연산자가 존재하다.

| 대입 연산자 |                                        설명                                         |
| :---------: | :---------------------------------------------------------------------------------: |
|      =      |                    왼쪽의 피연산자에 오른쪽의 피연산자를 대입함                     |
|     +=      | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입함 |
|     -=      | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입함 |
|     \*=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입함 |
|     /=      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입함 |
|     %=      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함 |

> 📝 예제

```c
int num01 = 7;
int num02 = 7;
int num03 = 7;

num01 = num01 - 5;
num02 -= 5;
num03 =- 5;

printf("- 연산자에 의한 결괏값은 %d입니다.\n", num01);  // -  연산자에 의한 결괏값은 2입니다.
printf("-= 연산자에 의한 결괏값은 %d입니다.\n", num02); // -= 연산자에 의한 결괏값은 2입니다.
printf("=- 연산자에 의한 결괏값은 %d입니다.\n", num03); // =- 연산자에 의한 결괏값은 -5입니다.
```

- 🚩 위의 예제에서 num03 =- 5 연산은 단순히 -5를 변수 num03에 대입(=)하는 연산이 되었다.
  이처럼 복합 대입 연산자에서 연산자의 순서는 매우 중요하므로 주의를 기울여야 한다.

## 증감 연산자(increment and decrement operator)

증감 연산자는 피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용하는 연산자이다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자다.

증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라진다.

> 🏷 증감 연산자 표

| 증감 연산자 |                            설명                            |
| :---------: | :--------------------------------------------------------: |
|     ++x     |  먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함   |
|     x++     | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴 |
|     --x     |  먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함   |
|     x--     | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴 |

> 📝 예제

```c
#include <stdio.h>

int main()
{
    int num01 = 7;
    int num02 = 7;
    int result01, result02;

    result01 = (++num01) - 5;
    result02 = (num02++) - 5;

    printf("전위 증가 연산자에 의한 결괏값은 %d이고, 변수의 값은 %d로 변했습니다.\n", result01, num01);
    // 전위 증가 연산자에 의한 결괏값은 3이고, 변수의 값은 8로 변했습니다.
    printf("후위 증가 연산자에 의한 결괏값은 %d이고, 변수의 값은 %d로 변했습니다.\n", result02, num02);
    // 후위 증가 연산자에 의한 결괏값은 2이고, 변수의 값은 8로 변했습니다.
}
```

위의 예제에서 첫 번째 연산은 변수 num01의 값을 먼저 1 증가시킨 후에 나머지 연산을 수행한다.

하지만 두 번째 연산에서는 먼저 모든 연산을 마친 후에 변수 num02의 값을 1 증가시킨다.

따라서 변수 num02의 증가는 관련된 연산에 아무런 영향도 미치지 않는다.

## 증감 연산자의 연산 순서

증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라진다.

다음 예제는 증감 연산자의 연산 순서를 살펴보기 위한 예제이다.

> 📝 예제

```c
#include <stdio.h>

int main()
{
    int x = 10;
    int y = x-- + 5 + --x;

    printf("변수 x의 값은 %d이고, 변수 y의 값은 %d입니다.\n", x, y);
    // 변수 x의 값은 8이고, 변수 y의 값은 23입니다.
}
```

연산 과정을 대충 살펴보면 꽤나 복잡하게 느껴진다.

허나 하나하나 뜯어서 보면 그렇게 복잡하지 않음을 알 수 있다.

1. 우선 x--는 연산을 진행하고 연산자의 값을 빼기 때문에 10 + 5를 진행하고 x의 값을 1 뺴준다(x = 9)

2. 그후에 오는 --x는 우선 연산자의 값(x = 9 - 1을 빼고 연산을 진행하기 때문에 10 + 5 + --x(x = 8)이 되서 23이 된다.

## 비교 연산자(comparison operator)

비교 연산자는 `피연산자 사이의 상대적인 크기를 판단`하는 연산자다.

`비교 연산자`는 왼쪽의 피연산자와 오른쪽의 피연산자를 비교하여, 어느 쪽이 더 큰지, 작은지, 또는 서로 같은지를 판단한다.

비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽(->)이다.

> 🏷 비교 연산자 표

| 비교 연산자 |                               설명                               |
| :---------: | :--------------------------------------------------------------: |
|     ==      |     왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1을 반환함      |
|     !=      |   왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 1을 반환함   |
|      >      |     왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 1을 반환함      |
|     >=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 1을 반환함 |
|      <      |    왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 1을 반환함     |
|     <=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 1을 반환함 |

- 🚩 C언어에서 `거짓(false)`은 0이며, 0이 아닌 모든 것은 `참(true)`으로 인식된다. 즉 위의 표에서 1을 반환하는 것은 참(True)을 반환하는 것으로 봐도된다.

> 📝 예제

```c
#include <stdio.h>

int main()
{
  int num01 = 3;
  int num02 = 7;

  printf("== 연산자에 의한 결괏값은 %d입니다.\n", num01 == num02); // == 연산자에 의한 결괏값은 0입니다.

  printf("<= 연산자에 의한 결괏값은 %d입니다.\n", num01 <= num02);  /// <= 연산자에 의한 결괏값은 1입니다.
}
```

## 논리 연산자(logical operator)

논리 연산자는 주어진 논리식을 판단하여, 참(true)과 거짓(false)을 결정하는 연산자이다.

AND 연산과 OR 연산은 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

NOT 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽이다.

> 🏷 논리 연산자(AND, OR, NOT)

| 논리 연산자 |                               설명                               |
| :---------: | :--------------------------------------------------------------: | --- | -------------------------------------------------------- |
|     &&      |         논리식이 모두 참이면 1을 반환함. (논리 AND 연산)         |
|      `      |                                                                  | `   | 논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산) |
|      !      | 논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산) |

> 🏷 논리 연산자 진리표

|     A     |     B     |  A && B   | A ㅣㅣ B(OR) |    !A     |
| :-------: | :-------: | :-------: | :----------: | :-------: |
| 1 (true)  | 1 (true)  | 1 (true)  |   1 (true)   | 0 (false) |
| 1 (true)  | 0 (false) | 0 (false) |   1 (true)   | 0 (false) |
| 0 (false) | 1 (true)  | 0 (false) |   1 (true)   | 1 (true)  |
| 0 (false) | 0 (false) | 0 (false) |  0 (false)   | 1 (true)  |

> 📝 예제

```c
#include <stdio.h>

int main()
{
    int num01 = 3;
    int num02 = -7;
    int result01, result02;

    result01 = (num01 > 0) && (num01 < 5);
    result02 = (num02 < 0) || (num02 > 10);

    printf("&& 연산자에 의한 결괏값은 %d입니다.\n", result01);
    // && 연산자에 의한 결괏값은 1입니다.
    printf("|| 연산자에 의한 결괏값은 %d입니다.\n", result02);
    // || 연산자에 의한 결괏값은 1입니다.
    printf(" ! 연산자에 의한 결괏값은 %d입니다.\n", !result02);
    //  ! 연산자에 의한 결괏값은 0입니다.
}
```

## 비트 연산자(bitwise operator)

비트 연산자는 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자이다.

또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용한다.

> 🏷비트 연산자 표

| 비트 연산자 |                                        설명                                         |
| :---------: | :---------------------------------------------------------------------------------: |
|      &      |               대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)                |
|      l      |           대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)            |
|      ^      |               대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)               |
|      ~      |               비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산)               |
|     <<      |          지정한 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산)           |
|     >>      | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |

다음 그림은 비트 `AND 연산자(&)`의 동작을 나타낸다.

비트 AND 연산자는 대응되는 두 비트가 모두 1일 때만 1을 반환하며, 다른 경우는 모두 0을 반환한다.

<img src=http://tcpschool.com/lectures/img_php_bitwise_and.png>

다음 그림은 비트 `OR 연산자(|)`의 동작이다.

비트 OR 연산자는 대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 두 비트가 모두 0일 때만 0을 반환한다.

<img src=http://tcpschool.com/lectures/img_php_bitwise_or.png>

다음 그림은 비트` XOR 연산자(^)`의 동작을 나타낸다.

이처럼 비트 XOR 연산자는 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환합니다.

<img src=http://tcpschool.com/lectures/img_php_bitwise_xor.png>

다음 그림은 비트 `NOT 연산자(~)`의 동작을 나타낸다.

이처럼 비트 NOT 연산자는 해당 비트가 1이면 0을 반환하고, 0이면 1을 반환한다.

<img src=http://tcpschool.com/lectures/img_php_bitwise_not.png>

> 📝 예제

```c
#include <stdio.h>

int main()
{
  int num01 = 15; int num02 = 8;

  printf(" ~ 연산자에 의한 결괏값은 %d입니다.\n", ~num01);     // 1의 보수
  //  ~ 연산자에 의한 결괏값은 -16입니다.
  printf("<< 연산자에 의한 결괏값은 %d입니다.\n", num02 << 1); // 곱하기 2
  // << 연산자에 의한 결괏값은 16입니다.
  printf(">> 연산자에 의한 결괏값은 %d입니다.\n", num02 >> 1); // 나누기 2
  // >> 연산자에 의한 결괏값은 4입니다.
}
```

## 기타 연산자

## 삼항 연산자(ternary operator)

이 연산자는 C언어에서도 유일하게 피연산자를 세 개나 가지는 조건 연산자이다.

자바스크립트에서도 사용하는 연산자인데 C언어에서 파생된 듯 하다.

> ✅ 문법

```c
  조건식 ? 반환값1 : 반환값2
```

물음표(?) 앞의 조건식에 따라 결괏값이 참(true)이면 반환값1을 반환하고, 결괏값이 거짓(false)이면 반환값2를 반환한다.

반환값에는 값뿐만 아니라 수식, 함수 호출 등 여러 가지 형태의 명령문이 올 수 있다.

> 📝 예제

```c
int num01 = 15;
int num02 = 8;
int result;

result = (num01 > num02) ? num01 : num02;
printf("둘 중에 더 큰수는 %d입니다.\n", result);  // 둘 중에 더 큰수는 15입니다.
```

삼항 연산자는 짧은 if / else 문 대신에 사용할 수 있으며, 코드를 간결하게 작성할 수 있도록 도와준다.

## 쉼표 연산자

`쉼표(,) 연산자`는 얼핏 연산자가 아닌 것처럼 보이지만 다양한 용도로 사용되는 연산자입니다.

이 연산자는 어떠한 연산을 수행하는 것이 아니라 다음과 같은 상황에서 사용됩니다.

- 두 연산식을 하나의 연산식으로 나타내고자 할 때

- 둘 이상의 인수를 함수로 전달하고자 할 때

> 📝 예제

```c
int num01 = 15, num02 = 8;

printf("첫 번째 수는 %d이고, 두 번째 수는 %d입니다.\n", num01, num02);  // 첫 번째 수는 15이고, 두 번째 수는 8입니다.
```

위의 예제에서 쉼표 연산자는 둘 이상의 변수를 동시에 선언하기 위해서 사용되었다.

또한, printf() 함수에서는 둘 이상의 인수를 동시에 printf() 함수로 전달하기 위해서 사용되었다.

## sizeof 연산자

사용자의 컴퓨터 환경에 따라 타입에 할당되는 메모리의 크기가 달라질 수 있다.

sizeof 연산자는 단항 연산자로 피연산자의 크기를 바이트 단위로 반환한다.

이 연산자는 피연산자로 타입뿐만 아니라 변수나 상수를 전달받을 수도 있다.

sizeof 연산자에 변수나 상수가 피연산자로 전달되면, 해당 변수나 상수에 해당하는 타입의 크기를 반환해 준다.

> 📝 예제

```c
#include <stdio.h>

int main()
{
  int num01 = 15;
  int num02 = 8;

  printf(" num01의 크기는 %d입니다.\n", sizeof(num01)); //  num01의 크기는 4입니다.
  printf(" num02의 크기는 %d입니다.\n", sizeof(num02)); //  num01의 크기는 4입니다.
}
```

## 포인터 연산자

C언어에서 포인터와 연관되어 사용되는 연산자는 다음과 같다.

1. 주소 연산자(&)

2. 참조 연산자(\*)

`주소 연산자(&)`는 변수의 이름 앞에 사용하여, 해당 변수의 주소값을 반환한다.

`'&'기호`는 `앰퍼샌드(ampersand)`라고 읽으며, `번지 연산자`라고도 불린다.

`참조 연산자(*)`는 포인터의 이름이나 주소 앞에 사용하여, 포인터에 가리키는 주소에 저장된 값을 반환한다.

C언어에서 `*기호`는 사용하는 위치에 따라 다양한 용도로 사용된다.

이항 연산자로 사용하면 곱셈 연산으로 사용되며, 포인터의 선언 시나 메모리에 접근할 때도 사용된다.

# 제어문

## 제어문(control flow statements)

C 프로그램은 절차적 프로그램(procedural program) 또는 명령형 프로그램(Impretative program)에 속한다.

C 프로그램에는 수많은 명령문이 포함되어 있으며, 이 명령문은 처음부터 끝까지 순서대로 실행된다.

따라서 원하는 결과를 얻기 위해서는 프로그램의 이러한 순차적인 흐름을 제어해야만 한다.

이때 사용하는 명령문을 제어문이라고 하며, 이러한 제어문에는 조건문, 반복문 등이 있다.

이러한 제어문에 속하는 명령문들은 `중괄호{}`로 둘러싸여 있으며, 이러한 중괄호 영역을 `블록(block)`이라고 한다.

# 조건문(conditional statements)

조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.

조건문 중에서도 가장 기본이 되는 명령문은 바로 if 문이다.

C언어에서 사용하는 대표적인 조건문의 형태는 다음과 같다.

1. if 문

2. if / else 문

3. if / else if / else 문

4. switch 문

## if문

if 문은 조건식의 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않는다.

if 문을 순서도로 표현하면 다음 그림과 같다.

<img src=http://tcpschool.com/lectures/img_js_if.png>

C언어에서 if 문의 문법은 다음과 같다.

> ✅ 문법

```c
if (조건식)

{
    조건식의 결과가 참일 때 실행하고자 하는 명령문;
}
```

위의 코드에서 블록에 속한 명령문은 `중괄호({})`를 기준으로 오른쪽으로 들여쓰기가 되어 있는 것을 볼 수 있다.

> 📝 예제

```c
int num = 3;

if (num < 5)
{
    printf("입력하신 수는 5보다 작습니다.\n");
}
if (num == 5)
{
    printf("입력하신 수는 5입니다.\n");
}
if (num > 5)
{
    printf("입력하신 수는 5보다 큽니다.\n");
}
// 실행 결과
입력하신 수는 5보다 작습니다.
```

if 문을 3번 연속해서 사용하여, 사용자가 입력한 수와 숫자 5를 비교하여 그 결괏값을 출력하는 예제이다.

🚩 if 문에서 실행될 명령문이 한 줄 뿐이라면 중괄호({})를 생략할 수 있다.

## if / else 문

if 문과 함께 사용하는 else 문은 if 문과는 반대로 주어진 조건식의 결과가 거짓(false)이면 주어진 명령문을 실행한다.

if / else 문을 순서도로 표현하면 다음 그림과 같다.

<img src=http://tcpschool.com/lectures/img_js_else.png>

> ✅ 문법

```c
if (조건식)
{
    조건식의 결과가 참일 때 실행하고자 하는 명령문;
}
else
{
    조건식의 결과가 거짓일 때 실행하고자 하는 명령문;
}
```

> 📝 예제

else 문을 사용하면 앞선 if문의 예제를 좀 더 직관적으로 표현할 수 있다.

```c
#include <stdio.h>

int main()
{
  int num = 5;

  if (num < 5)
  {
      printf("입력하신 수는 5보다 작습니다.\n");
  }
  else
  {
      if (num == 5)
      {
          printf("입력하신 수는 5입니다.\n");
      }
      else
      {
          printf("입력하신 수는 5보다 큽니다.\n");
      }
  }
}
// 실행 결과
입력하신 수는 5입니다.
```

- 🚩 else 문에서도 실행될 명령문이 한 줄뿐이라면 `중괄호({})`를 생략할 수 있다.

## if / else if / else 문

`else if 문`은 if 문처럼 조건식을 가질 수 있기 때문에 중첩된 if 문을 좀 더 간결하게 표현할 수 있도록 해준다.

하나의 조건문 안에서 if 문과 else 문은 단 한 번만 사용될 수 있다.

하지만 else if 문은 여러 번 사용될 수 있어서 복잡한 조건도 표현할 수 있다.

if / else if / else 문을 순서도로 표현하면 다음 그림과 같다.

<img src=http://tcpschool.com/lectures/img_js_elseif.png>

> ✅ 문법

```c
if (조건식1)
{
    조건식1의 결과가 참일 때 실행하고자 하는 명령문;
}
else if (조건식2)
{
    조건식2의 결과가 참일 때 실행하고자 하는 명령문;
}
else
{
    조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;
}
```

> 📝 예제

else if 문을 사용하면 앞선 if else 예제를 더욱 간결하게 표현할 수 있다.

```c
#include <stdio.h>

int main()
{
  int num = 7;

  if (num < 5)
  {
      printf("입력하신 수는 5보다 작습니다.\n");
  }
  else if (num == 5)
  {
      printf("입력하신 수는 5입니다.\n");
  }
  else
  {
      printf("입력하신 수는 5보다 큽니다.\n");
  }
}
// 실행 결과
입력하신 수는 5보다 큽니다.
```

- 🚩 else if 문에서도 실행될 명령문이 한 줄뿐이라면 `중괄호({})`를 생략할 수 있다.

## 삼항 연산자에 의한 조건문

C언어에서는 if / else 문을 앞서 배운 삼항 연산자를 이용하여 간단히 표현할 수 있다.

## switch 문

`switch 문`은 if / else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문이다.

이러한 `switch 문`은 if / else 문보다 가독성이 더 좋으며, 컴파일러가 최적화를 쉽게 할 수 있어 속도 또한 빠른 편이다.

하지만 switch 문의 조건 값으로는 `int형으로 승격할 수 있는(integer promotion) 값`만이 사용될 수 있다.

즉, C언어에서는 `char형`, `short형`, `int형 변수`나 `리터럴`과 나중에 배우게 될 `열거체`까지 사용할 수 있다.

따라서 if / else 문보다는 사용할 수 있는 상황이 적은 편이다.

> ✅ 문법

```c
switch (조건 값)

{
    case 값1:
        조건 값이 값1일 때 실행하고자 하는 명령문;
        break;
    case 값2:
        조건 값이 값2일 때 실행하고자 하는 명령문;
        break;
    ...
    default:
        조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;
        break;
}
```

default 절은 조건 값이 위에 나열된 어떠한 case 절에도 해당하지 않을 때 실행된다.

이 구문은 반드시 존재해야 하는 것은 아니며 필요할 때에만 선언할 수 있다.

- 🚩 default 절의 위치가 반드시 switch 문의 맨 마지막일 필요는 없다.

> 📝 예제

```c
#include <stdio.h>

int main()
{
  int num = 2;

  switch (num)
  {
      case 1:
          printf("입력하신 수는 1입니다.\n");
          break;
      case 2:
          printf("입력하신 수는 2입니다.\n");
          break;
      case 3:
          printf("입력하신 수는 3입니다.\n");
          break;
      case 4:
          printf("입력하신 수는 4입니다.\n");
          break;
      case 5:
          printf("입력하신 수는 5입니다.\n");
          break;
      default:
          printf("1부터 5까지의 수만 입력해 주세요!");
          break;
  }
}
// 실행 결과
입력하신 수는 2입니다.
```

각 case 절 및 default 절은 반드시 `break 키워드`를 포함하고 있어야 한다.

`break 키워드`는 조건 값에 해당하는 case 절이나 default 절이 실행된 뒤에 전체 switch 문을 빠져나가게 해준다.

만약에 `break 키워드`가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행될 것이다.

> 📝 예제

다음 예제는 앞서 살펴본 예제에서 break 키워드를 모두 삭제한 예제이다.

```c
#include <stdio.h>

int main()
{
  int num = 2;
  switch (num)
  {
      case 1:
          printf("입력하신 수는 1입니다.\n");
      case 2:
          printf("입력하신 수는 2입니다.\n");
      case 3:
          printf("입력하신 수는 3입니다.\n");
      case 4:
          printf("입력하신 수는 4입니다.\n");
      case 5:
          printf("입력하신 수는 5입니다.\n");
      default:
          printf("1부터 5까지의 수만 입력해 주세요!");
  }
}
// 실행 결과
입력하신 수는 2입니다.
입력하신 수는 3입니다.
입력하신 수는 4입니다.
입력하신 수는 5입니다.
1부터 5까지의 수만 입력해 주세요!
```

위의 예제처럼 `break 키워드`가 없으면, 조건 값에 해당하는 case 절뿐만 아니라 그 이후에 등장하는 모든 case 절과 default 절이 전부 실행됨을 알 수 있다.

다음 예제는 조건 값으로 여러 개의 `char형 문자`를 검사하는 예제이다.

```c
#include <stdio.h>

int main()
{
  char ch = 'a';
  switch (ch)
  {
      case 'a':
      case 'A':
          printf("이 학생의 학점은 A입니다.\n");
          break;
      case 'b':
      case 'B':
          printf("이 학생의 학점은 B입니다.\n");
          break;
      case 'c':
      case 'C':
          printf("이 학생의 학점은 C입니다.\n");
          break;
      case 'd':
      case 'D':
          printf("이 학생의 학점은 D입니다.\n");
          break;
      case 'f':
      case 'F':
          printf("이 학생의 학점은 F입니다.\n");
          break;
      default:
          printf("학점을 정확히 입력해 주세요!(A, B, C, D, F)");
          break;
  }
}
// 실행 결과
이 학생의 학점은 A입니다.
```

# - 반복문(iteration statements)

반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문이다.

프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나이다.

C언어에서 사용되는 대표적인 반복문의 형태는 다음과 같다.

1. while 문

2. do / while 문

3. for 문

## while문

while 문은 특정 조건을 만족할 때까지 계속해서 주어진 명령문을 반복 실행한다.

C언어에서 while 문의 문법은 다음과 같다.

> ✅ 문법

```c
while (조건식)

{
    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}
```

<img src=http://tcpschool.com/lectures/img_c_while.png>

`while 문`은 우선 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행한다.

이렇게 내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단하게 된다.

이렇게 표현식의 검사를 통해 반복해서 실행되는 반복문을 `루프(loop)`라고 한다.

```c
#include <stdio.h>

int main()
{
  int i = 0;
  int num = 5;

  while (i < num)
  {
      printf("while 문이 %d 번째 반복 수행중입니다.\n", i + 1);
      i++; // 이 부분을 삭제하면 무한 루프에 빠지게 됨
  }
  printf("while 문이 종료된 후 변수 i의 값은 %d입니다.\n", i);
}
// 실행 결과
while 문이 1 번째 반복 수행중입니다.
while 문이 2 번째 반복 수행중입니다.
while 문이 3 번째 반복 수행중입니다.
while 문이 4 번째 반복 수행중입니다.
while 문이 5 번째 반복 수행중입니다.
while 문이 종료된 후 변수 i의 값은 5입니다.
```

`while 문` 내부에 조건식의 결과를 변경하는 명령문이 존재하지 않을 때는 프로그램이 영원히 반복되게 된다.

이것을 `무한 루프(infinite loop)`에 빠졌다고 한다.

반복문에서는 조건식이 거짓일 때 반복문이 종료 되지만, 무한루프는 조건식이 항상 참이기 때문에 반복문이 종료되지 않고 무한히 실행되는 반복문을 의미한다. 무한 루프에 빠진 프로그램은 영원히 종료되지 않는다.

무한 루프는 특별히 의도한 경우가 아니라면 반드시 피해야 하는 상황이다.

따라서 while 문을 작성할 때는 조건식의 결과가 어느 순간 거짓(false)을 갖도록 조건식의 결과를 변경하는 명령문을 반드시 포함시켜야 한다.

위의 예제에서 조건식의 결과를 변경하는 명령문인 i++를 제거하면, 변수 i의 값은 언제나 0이기 때문에 무한 루프에 빠지게 된다.

## do / while문

while 문은 루프에 진입하기 전에 먼저 조건식부터 검사한다.

하지만 do / while 문은 먼저 루프를 한 번 실행한 후에 조건식을 검사한다.

즉, do / while 문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행한다.

> ✅ 문법

```c
do {
    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
} while (조건식);
```

<img src=http://tcpschool.com/lectures/img_c_dowhile.png>

> 📝 예제

```c
#include <stdio.h>

int main()
{
  int i = 0;
  int num = 3;

  do {
      printf("do / while 문이 %d 번째 반복 수행중입니다.\n", i + 1);
      i++;
  } while (i > num);

  printf("do / while 문이 종료된 후 변수 i의 값은 %d입니다.\n", i);
}
// 실행 결과
do / while 문이 1 번째 반복 수행중입니다.
while 문이 종료된 후 변수 i의 값은 1입니다.
```

위의 예제가 만약 while 문이었다면 단 한 번의 출력도 없었을 것이다.

하지만 do / while 문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행해 준다.

## for 문

`for 문`은 while 문과는 달리 자체적으로 초기식, 조건식, 증감식을 모두 포함하고 있는 반복문이다.

따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있습니다.

> ✅ 문법

```c
for (초기식; 조건식; 증감식)
{
    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}
```

<img src=http://tcpschool.com/lectures/img_c_for.png>

이때 for 문을 구성하는 초기식, 조건식, 증감식은 각각 생략될 수 있다.

for 문을 사용하면 앞선 예제의 while 문을 더욱 더 간결하게 표현할 수 있다.

> 📝 예제

```c
#include <stdio.h>

int main()
{
  int i;
  int num = 7;

  for (i = 0; i < num; i++)
  {
      printf("for 문이 %d 번째 반복 수행중입니다.\n", i + 1);
  }
  printf("for 문이 종료된 후 변수 i의 값은 %d입니다.\n", i);
}
// 실행 결과
for 문이 1 번째 반복 수행중입니다.
for 문이 2 번째 반복 수행중입니다.
for 문이 3 번째 반복 수행중입니다.
for 문이 4 번째 반복 수행중입니다.
for 문이 5 번째 반복 수행중입니다.
for 문이 6 번째 반복 수행중입니다.
for 문이 7 번째 반복 수행중입니다.
for 문이 종료된 후 변수 i의 값은 7입니다.
```

## 기타 제어문

## 루프의 제어

일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행한다.

하지만 `continue문`과 `break문`은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 해준다.

## continue 문

continue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 한다.

보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용된다.

> 📝 예제

다음 예제는 1부터 100까지의 정수 중에서 3의 배수를 제외하고 출력하는 예제이다.

```c
#include <stdio.h>

int main()
{
  int i;
  int except_num = 3;

  for (i = 1; i <= 100; i++)
  {
      if (i % except_num == 0)
      {
          continue;
      }
      printf("%d ", i);
  }
}
// 실행 결과
1
2
4
5
7
...
97
98
100
```

위 예제의 출력이 저러한 형태를 가지는 것은 변수 i의 값이 3의 배수인 경우에는 continue 문을 이용하여 for 문의 printf() 함수 부분을 건너뛰고 있기 때문이다.

## break문

break 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행한다.

즉 루프 내에서 조건식의 판단 결과에 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용한다.

> 📝 예제

구구단에서 5단까지 각 단의 수만큼만 출력하는 예제이다.

```c
#include <stdio.h>

int main()
{
  int i, j;

  for (i = 2; i <= 5; i++)
  {
      for (j = 1; j <= 9; j++)
      {
          printf("%d * %d = %d\n", i, j, i * j);
          if (i == j)
          {
              printf("\n");
              break;
          }
      }
  }
}
```

```c
// 실행 결과
2 * 1 = 2
2 * 2 = 4

3 * 1 = 3
3 * 2 = 6
3 * 3 = 9

4 * 1 = 4
4 * 2 = 8
4 * 3 = 12
4 * 4 = 16

5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
```

위의 예제는 두 개의 for 문을 중첩해서 사용하여 구구단을 출력하고 있다.

이때 내부의 for 문은 변수 i와 j의 값이 같아지면, break 문을 호출하여 내부의 for 문을 빠져나간다.

따라서 구구단의 각 단이 해당 단의 수만큼만 출력될 수 있다.

## goto 문

goto 문은 프로그램의 흐름을 지정된 레이블(label)로 무조건 변경시키는 명령문이다.

goto 문은 다른 제어문과는 달리 아무런 조건 없이 프로그램의 흐름을 옮겨준다.

따라서 가장 손쉽게 사용할 수 있지만, 반면에 프로그램의 흐름을 매우 복잡하게 만들기도 한다.

이러한 단점 때문에 현재는 디버깅 이외에는 거의 사용되지 않는다.

---

# C언어 함수

## 함수란?

프로그래밍에서 `함수(function)`란 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 프로그램 코드의 집합으로 정의할 수 있다.

C 프로그램은 이러한 함수들로 구성되며, 포함된 함수들을 사용하여 프로그램의 목적을 달성하게 된다.

C언어에서 함수는 크게 `표준 함수`와 `사용자 정의 함수`로 구분할 수 있다.

## 함수를 사용하는 이유

함수를 사용하는 가장 큰 이유는 바로 반복적인 프로그래밍을 피할 수 있기 때문이다.

프로그램에서 특정 작업을 여러 번 반복해야 할 때는 해당 작업을 수행하는 함수를 작성하면 된다.

그리고서 프로그램이 필요할 때마다 작성한 함수를 호출하면 해당 작업을 반복해서 수행할 수 있다.

또한, 프로그램을 여러 개의 함수로 나누어 작성하면, 모듈화로 인해 전체적인 코드의 가독성이 좋아진다.

그리고 프로그램에 문제가 발생하거나 기능의 변경이 필요할 때에도 손쉽게 유지보수를 할 수 있다.

- 🚩 함수의 크기에 대해서 정확히 명시된 규칙은 없으나, 대략 하나의 기능을 하나의 함수로 만드는 것이 가장 좋다.

## 함수의 정의

C언어에서 사용자 정의 함수를 정의하는 방법은 다음 그림과 같다.

<img src=http://tcpschool.com/lectures/img_c_function_structure.png>

1. 반환 타입(return type) : 함수가 모든 작업을 마치고 반환하는 데이터의 타입을 명시한다.

2. 함수 이름 : 함수를 호출하기 위한 이름을 명시한다.

3. 매개변수 목록(parameters) : 함수 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시한다.

4. 함수 몸체 : 함수의 고유 기능을 수행하는 명령문의 집합이다.

함수 호출 시에는 여러 개의 인수를 전달할 수 있지만, 함수가 반환할 수 있는 값은 1개를 넘지 못한다.

또한, 함수의 특성에 따라 인수나 반환값이 하나도 없는 함수도 존재할 수 있다.

> 📝 예제

다음 예제에서는 인수로 전달받은 두 수 중에서 더 큰 수를 반환하는 `bigNum()함수`를 정의하여 사용한다.

```c
#include <stdio.h>

int bigNum(int num01, int num02) // 함수의 정의
{
    if (num01 >= num02)
    {
        return num01;
    }
    else
    {
        return num02;
    }
}

int main(void)  // 위에서 정의한 함수 활용
{
    int result;
    result = bigNum(3, 5); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    result = bigNum(3, 1); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    result = bigNum(7, 5); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    return 0;
}
// 실행 결과
두 수 중 더 큰수는 5입니다.
두 수 중 더 큰수는 3입니다.
두 수 중 더 큰수는 7입니다.
```

## 함수의 원형 선언

C언어에서 함수를 정의할 때는 그 위치가 매우 중요하다.

> 📝 예제

```c
#include <stdio.h>

int main(void)
{
    int result;
    result = bigNum(3, 5); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    result = bigNum(3, 1); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    result = bigNum(7, 5); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    return 0;
}
int bigNum(int num01, int num02) // 함수의 정의
{
    if (num01 >= num02)
    {
        return num01;
    }
    else
    {
        return num02;
    }
}
// 실행 결과 ( 에러 발생 )
warning: implicit declaration of function ‘bigNum’ [-Wimplicit-function-declaration]
    6 |     result = bigNum(3, 5); // 함수의 호출
      |              ^~~~~~
```

C언어에서는 가장 먼저 main() 함수가 컴파일러에 의해 컴파일된다.

위의 예제에서 컴파일러는 main()함수에 등장하는 bigNum()함수를 아직 알지 못하기 때문에 컴파일 오류를 발생시킨다.

따라서 컴파일러에 bigNum() 함수는 나중에 정의되어 있다고 알려줘야 한다.

그 역할을 하는 것이 바로 `함수의 원형(prototype)선언`이다.

위와 같이 차례대로 한 번에 컴파일하는 방식을 `단일 패스(one pass)컴파일 방식`이라고 한다.

하지만 하드웨어의 발달로 컴파일러에 따라 여러 번에 걸쳐 컴파일하는 `다중 패스(multi-pass)방식`이 많아지고 있다.

다중 패스 방식의 컴파일러에서는 함수의 원형을 선언하지 않아도 컴파일 오류를 발생시키지 않는다.

하지만 오래된 컴파일러는 대부분 단일 패스 방식으로 컴파일하므로, C 표준에서는 여전히 함수의 원형을 정의하고 있다.

`함수의 원형 선언`은 다음과 같은 방식으로 선언된다.

> ✅ 문법

```
반환타입 함수이름(매개변수타입);
```

> 📝 예제

다음 예제는 앞서 살펴본 예제에 함수의 원형 선언을 추가한 예제이다.

이렇게 함수의 원형은 main() 함수 앞에 미리 선언되어야 한다.

```c
#include <stdio.h>

int bigNum (int, int); // 함수의 원형 선언

int main(void)
{
    int result;

    result = bigNum(3, 5); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    result = bigNum(3, 1); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    result = bigNum(7, 5); // 함수의 호출
    printf("두 수 중 더 큰수는 %d입니다.\n", result);
    return 0;
}

int bigNum(int num01, int num02) // 함수의 정의
{
    if (num01 >= num02)
    {
        return num01;
    }
    else
    {
        return num02;
    }
}
// 실행 결과
두 수 중 더 큰수는 5입니다.
두 수 중 더 큰수는 3입니다.
두 수 중 더 큰수는 7입니다.
```

실행 결과 오류 없이 정상 작동함을 알 수 있다.

## 변수의 유효 범위(variable scope)

C언어에서는 변수의 선언 위치에 따라 해당 변수의 `유효 범위`, `메모리 반환 시기`, `초기화 여부`, `저장되는 장소` 등이 변경된다.

C언어에서 변수는 위와 같은 특징들을 기준으로 다음과 같이 나눌 수 있다.

1. 지역 변수(local variable)

2. 전역 변수(global variable)

3. 정적 변수(static variable)

4. 레지스터 변수(register variable)

## 메모리의 구조

컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공한다.

C 프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같다.

1. 코드(code) 영역

2. 데이터(data) 영역

3. 스택(stack) 영역

4. 힙(heap) 영역

## 지역 변수(local variable)

지역 변수란 '블록' 내에서 선언된 변수를 의미한다.

지역 변수는 변수가 선언된 블록 내에서만 유효하며, 블록이 종료되면 메모리에서 사라진다.

이러한 지역 변수는 메모리상의 `스택(stack)영역`에 저장되며, 초기화하지 않으면 의미 없는 값(쓰레기값)으로 초기화된다.

함수의 `매개변수` 또한 함수 내에서 정의되는 `지역 변수로 취급`된다.

> 📝 예제

```c
#include <stdio.h>

void local(void);

int main(void)
{
    int i = 5;
    int var = 10;

    printf("main() 함수 내의 지역 변수 var의 값은 %d입니다.\n", var);
    if (i < 10)
    {
        local();
        int var = 30;
        printf("if 문 내의 지역 변수 var의 값은 %d입니다.\n", var);
    }
    printf("현재 지역 변수 var의 값은 %d입니다.\n", var);
    return 0;
}

void local(void)
{
    int var = 20;
    printf("local() 함수 내의 지역 변수 var의 값은 %d입니다.\n", var);
}
// 실행 결과
main() 함수 내의 지역 변수 var의 값은 10입니다.
local() 함수 내의 지역 변수 var의 값은 20입니다.
if 문 내의 지역 변수 var의 값은 30입니다.
현재 지역 변수 var의 값은 10입니다.
```

위의 예제에서 `변수 var`는 한 번은 main() 함수 내에서, 또 한 번은 if 문에서, 마지막은 local() 함수 내에서 선언된다.

이처럼 같은 이름의 변수 var은 모두 다른 중괄호({}) 영역에서 선언되었으며, 이러한 중괄호 영역을 `블록(block)`이라고 합니다.

이렇게 `변수의 유효 범위`는 `변수가 선언된 블록을 기준`으로 설정되며, `해당 블록이 끝나면 모든 지역 변수는 메모리에서 사라지게 된다.`

- 🚩 위의 예제에서처럼 변수의 이름으로 같은 이름을 여러 번 사용하는 것은 구문 상 에러를 발생시키지는 않지만, 바람직하지 못한 방식이므로 지양하는것이 좋다.
- 🚩 한 블록 내에서 같은 이름의 변수를 또다시 선언하려고 하면 컴파일러는 오류를 발생시킨다.

## 전역 변수(global variable)

`전역 변수`란 함수의 외부에서 선언된 변수를 의미한다.

`전역 변수`는 프로그램의 어디에서나 접근할 수 있으며, 프로그램이 종료되어야만 메모리에서 사라진다.

이러한 `전역 변수`는 메모리상의 데이터(data) 영역에 저장되며, 직접 초기화하지 않아도 0으로 자동 초기화된다.

> 📝 예제

```c
#include <stdio.h>

void local(void);

int var; // 전역 변수 선언

int main(void)
{
    printf("전역 변수 var의 초깃값은 %d입니다.\n", var);
    int i = 5;
    int var = 10; // 지역 변수 선언
    printf("main() 함수 내의 지역 변수 var의 값은 %d입니다.\n", var);
    if (i < 10)
    {
        local();
        printf("현재 변수 var의 값은 %d입니다.\n", var); // 지역 변수에 접근
    }
    printf("더 이상 main() 함수에서는 전역 변수 var에 접근할 수가 없습니다.\n");
    return 0;
}

void local(void)
{
    var = 20; // 전역 변수의 값 변경
    printf("local() 함수 내에서 접근한 전역 변수 var의 값은 %d입니다.\n", var);
}

// 실행 결과
전역 변수 var의 초기값은 0입니다.
main() 함수 내의 지역 변수 var의 값은 10입니다.
local() 함수 내에서 접근한 전역 변수 var의 값은 20입니다.
현재 변수 var의 값은 10입니다.
더 이상 main() 함수에서는 전역 변수 var에 접근할 수가 없습니다.
```

위의 예제에서 전역 변수 var와 같은 이름의 지역 변수 var가 main() 함수 내부에서 선언된다.

이 지역 변수가 선언되기 전까지는 main() 함수에서도 전역 변수 var에 접근할 수 있다.

하지만 지역 변수 var가 선언된 후에는 main() 함수에서 전역 변수 var로 접근할 방법이 없어진다.

왜냐하면, 블록 내에서 선언된 지역 변수는 같은 이름의 전역 변수를 덮어쓰기 때문이다.

- 🚩 따라서 이처럼 전역 변수와 같은 이름으로 지역 변수를 선언하는 것은 좋지 않다.

또한, 여러 개의 파일로 구성된 프로그램에서 외부 파일의 전역 변수를 사용하기 위해서는 extern 키워드를 사용해 다시 선언해야 줘야한다.

## 정적 변수(static variable)

C언어에서 `정적 변수`란 `static 키워드로 선언한 변수`를 의미한다.

이렇게 선언된 `정적 변수`는 `지역 변수`와 `전역 변수`의 특징을 모두 가지게 된다.

함수 내에서 선언된 정적 변수는 전역 변수처럼 단 한 번만 초기화되며(초기화는 최초 실행 시 단 한번만 수행됨), 프로그램이 종료되어야 메모리상에서 사라진다.

또한, 이렇게 선언된 `정적 변수`는 지역 변수처럼 해당 함수 내에서만 접근할 수 있다.

> 📝 예제

```c
#include <stdio.h>

void local(void);
void staticVar(void);

int main(void)
{
    int i;

    for (i = 0; i < 3; i++)
    {
        local();
        staticVar();
    }
    return 0;
}

void local(void)
{
    int count = 1;
    printf("local() 함수가 %d 번째 호출되었습니다.\n", count);
    count++;
}

void staticVar(void)
{
    static int static_count = 1;  // ① 라인
    printf("staticVar() 함수가 %d 번째 호출되었습니다.\n", static_count);
    static_count++;
}

// 실행 결과
local() 함수가 1 번째 호출되었습니다.
staticVar() 함수가 1 번째 호출되었습니다.
local() 함수가 1 번째 호출되었습니다.
staticVar() 함수가 2 번째 호출되었습니다.
local() 함수가 1 번째 호출되었습니다.
staticVar() 함수가 3 번째 호출되었습니다.
```

위의 예제는 지역 변수로 선언된 count와 정적 변수로 선언된 static_count를 서로 비교하는 예제이다.

지역 변수인 count는 함수의 호출이 끝날 때마다 메모리상에서 사라진다.

하지만 정적 변수인 static_count는 함수의 호출이 끝나도 메모리상에서 사라지지 않고, 다음 함수 호출 때 이전의 데이터를 그대로 가지고 있다.

정적 변수 static_count의 초기화를 수행하는 ①번 라인의 코드는 최초로 실행될 때 단 한 번만 수행되며, 두 번째부터는 수행되지 않는다.

또한, static_count는 전역 변수와는 달리 자신이 선언된 staticVar() 함수 이외의 영역에서는 호출할 수 없다.

## 레지스터 변수(register variable)

`레지스터 변수`란 지역 변수를 선언할 때 `register 키워드`를 붙여 선언한 변수를 의미한다.

이렇게 선언된 레지스터 변수는 CPU의 레지스터(register) 메모리에 저장되어 빠르게 접근할 수 있게 된다.

하지만 컴퓨터의 레지스터는 매우 작은 크기의 메모리이므로, 이 영역에 변수를 선언하기 힘든 경우도 많다.

그럴 때 C 컴파일러는 해당 변수를 그냥 지역변수로 선언하게 된다.

> 🏷 변수의 종류

|   변수 종류   |  키워드  |    선언 위치     |    유효 범위     |
| :-----------: | :------: | :--------------: | :--------------: |
|   지역 변수   |   auto   | 함수/블록의 내부 | 함수/블록의 내부 |
|   전역 변수   |  extern  |   함수의 외부    |  프로그램 전체   |
|   정적 변수   |  static  | 함수/블록의 내부 | 함수/블록의 내부 |
| 레지스터 변수 | register | 함수/블록의 내부 | 함수/블록의 내부 |

|   변수 종류   | 메모리 소멸 시기 |      초깃값      |        저장 장소         |
| :-----------: | :--------------: | :--------------: | :----------------------: |
|   지역 변수   |   함수 종료시    | 초기화되지 않음. |     스택(stack) 영역     |
|   전역 변수   | 프로그램 종료시  | 0으로 초기화됨.  |    데이터(data) 영역     |
|   정적 변수   | 프로그램 종료시  | 0으로 초기화됨.  |    데이터(data) 영역     |
| 레지스터 변수 |   함수 종료시    | 초기화되지 않음. | CPU의 레지스터(register) |

# - 재귀 호출(recursive call)

`함수`란 하나의 작업을 수행하기 위해 독립적으로 설계된 프로그램 코드의 집합이다.

C 프로그램은 이러한 함수들로 구성되며, 포함된 함수들을 사용하여 프로그램의 목적을 달성하게 된다.

`재귀 호출(recursive call)`이란 함수 내부에서 함수가 자기 자신을 또다시 호출하는 행위를 의미한다.

이러한 재귀 호출은 자기가 자신을 계속해서 호출하므로, 끝없이 반복되게 된다.

따라서 함수 내에 재귀 호출을 중단하도록 조건이 변경될 명령문을 반드시 포함해야 한다.

프로그래밍을 처음 접하는 사람들은 이러한 재귀 호출이 왜 필요한가에 대해 이해하기 힘들 수도 있다.

하지만 재귀 호출은 알고리즘이나 자료 구조론에서는 매우 중요한 개념 중 하나이다.

또한, 재귀 호출을 사용하면 복잡한 문제도 매우 간단하게 논리적으로 접근하여 표현할 수 있다.

## 재귀 호출의 개념

재귀 호출의 개념을 파악하기 위해서 우선 재귀 호출을 사용하지 않고 1부터 n까지의 합을 구하는 함수를 만들어 보자.

> 📝 예제

```c
int sum(int n) {
    int i;
    int result = 0;

    for (i = 1; i <= n; i++)
    {
        result += i;
    }
    return result;
}
```

위의 예제에서 sum() 함수는 재귀 호출을 사용하지 않고 만든 함수다.

이러한 함수는 그냥 봐서는 그 목적을 바로 알 수 없으며, 코드를 해석해야 무슨 목적으로 만든 함수인지 알 수 있다.

즉 변수 i와 result는 왜 정의됐으며, for 문은 왜 사용되었는지 바로 알 수가 없다.

---

이제부터 재귀 호출을 사용하여 1부터 n까지의 합을 구하는 rSum() 함수를 만들어 보자

우선 1부터 4까지의 합을 구하는 알고리즘은 다음과 같다.

1. 1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 됩니다.

2. 1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 됩니다.

3. 1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 됩니다.

4. 1부터 1까지의 합은 그냥 1입니다.

위와 같이 논리적인 재귀 알고리즘을 구상하고 나면, 그것을 토대로 의사 코드를 작성할 수 있다.

위의 알고리즘을 `의사 코드(pseudo code)`로 작성하면 다음과 같다.

> 🏷 의사 코드

```
시작
    1. n이 1이 아니면, 1부터 (n-1)까지의 합에 n을 더한 값을 반환함.
    2. n이 1이면, 그냥 1을 반환함.
끝
```

- 🚩 `의사 코드(pseudo code)`란 특정 프로그래밍 언어의 문법에 맞춰 작성된 것이 아닌, 일반적인 언어로 알고리즘을 표현한 코드를 의미한다.

작성한 의사코드를 재귀호출을 이요한 예제로 구현해 보자.

```c
#include <stdio.h>

int rSum(int);

int main(void)
{
	int n = 5;

	printf("1부터 %d까지의 합은 %d입니다.\n", n, rSum(n));
	return 0;
}

int rSum(int n)
{
	if (n == 1)					// n이 1이면, 그냥 1을 반환함.
	{
		return 1;
	}
	return n + rSum(n-1);	// n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환함.
}
// 실행 결과
1부터 5까지의 합은 15입니다.
```

위의 예제에서 if 문이 존재하지 않으면, 이 프로그램은 실행 직후 스택 오버플로우(stack overflow)에 의해 종료된다.

> 스택 오버플로우(stack overflow)란?

      스택 오버플로우(stack overflow)는 메모리 구조 중 스택(stack) 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생한다.

따라서 if 문처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다.

이처럼 재귀 호출은 다양한 알고리즘을 표현한 의사 코드를 그대로 코드로 옮길 수 있게 해주고 직관적인 프로그래밍을 하는 데 많은 도움을 준다.

그러나 재귀 호출은 비재귀 호출보다 실행 시간이 오래 걸리는 단점을 가지고 있다.

> 재귀의 장, 단점

- 👍 재귀호출의 장점 : 코드의 간결함

- 👎 재귀호출의 단점 : 무한 재귀호출의 위험성, 성능 상의 문제

---

# - 1차원 배열(array)

## 배열 이란?

`배열(array)`은 같은 타입의 변수들로 이루어진 유한 집합으로 정의된다.

배열을 구성하는 각각의 값을 `배열 요소(element)`라고 하며, 배열에서의 위치를 가리키는 숫자는 `인덱스(index)`라고 한다.

C언어에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있다.

배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조다.

배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있다.

하지만 현실적으로 이해하기가 쉬운 2차원 배열까지가 많이 사용된다.

## 1차원 배열

1차원 배열은 가장 기본적인 배열로 다음과 같은 문법에 따라 선언된다.

> ✅ 문법

```
타입 배열이름[배열길이];
```

타입은 배열 요소로 들어가는 변수의 타입을 명시한다.

배열 이름은 배열이 선언된 후에 배열로 접근하기 위해 사용된다.

배열의 길이는 해당 배열이 몇 개의 배열 요소를 가지게 되는지 명시한다.

- 🚩 C언어에서는 배열을 선언만 하고 초기화하지 않으면, 각 배열 요소에 아무런 의미를 가지지 않는 쓰레기값이 저장되어 있게 된다. 따라서 초기화되지 않은 배열은 사용하지 않도록 주의를 기울여야 한다.

> 📝 예제

```c
#include <stdio.h>

int main(void)
{
  int i;
  int sum = 0;
  int grade[3];        // 길이가 3인 int형 배열 선언

  /* 배열의 초기화 */
  grade[0] = 85;       // 국어 점수
  grade[1] = 65;       // 영어 점수
  grade[2] = 90;       // 수학 점수

  for (i = 0; i < 3; i++)
  {
      sum += grade[i]; // 인덱스를 이용한 배열의 접근
  }
  printf("국영수 과목 총 점수 합계는 %d점이고, 평균 점수는 %f점입니다.\n", sum, (double)sum/3);
}
// 실행 결과
국영수 과목 총 점수 합계는 240점이고, 평균 점수는 80.000000점입니다.
```

위의 예제에서 길이가 3인 int형 배열을 선언했다.(int grade[3];)

또한, 0부터 시작하는 `인덱스(index)`를 이용하면 각각의 배열 요소에 따로 접근할 수 있다.

다음 그림은 위의 예제에서 사용된 배열 grade가 메모리 상에서 어떻게 저장되는지를 보여준다.

<Img src=http://tcpschool.com/lectures/img_c_onedimensional_array.png>

의 그림처럼 언제나 배열의 이름은 배열의 첫 번째 요소와 같은 주소를 가리키고 있다.

## 배열의 선언과 동시에 초기화 하는 방법

C언어에서는 변수와 마찬가지로 배열도 선언과 동시에 초기화할 수 있다.

다음과 같이 `중괄호({})`를 사용하여 초깃값을 나열한 것을 초기화 리스트라고 한다.

> ✅ 문법

```
타입 배열이름[배열길이] = {배열요소1, 배열요소2, ...};
```

단, 초기화 리스트의 타입과 배열의 타입은 반드시 일치해야 한다.

만약에 초기화 리스트의 개수가 배열의 총 길이보다 적으면, 배열의 앞에서부터 차례대로 초기화된다.

이때 초기화되지 못한 나머지 배열 요소는 모두 0으로 자동 초기화된다.

초기화 리스트의 개수가 배열의 길이보다 길 경우에는 아래 배열의 특징에서 따로 다루도록 한다.

다음 예제는 앞선 예제와 같은 배열을 선언과 동시에 초기화하는 예제이다.

> 📝 예제

```c
int i;
int sum = 0;
int grade[3] = {85, 65, 90}; // 길이가 3인 int형 배열의 선언과 동시에 초기화

for (i = 0; i < 3; i++)
{
    sum += grade[i];
}
printf("국영수 과목 총 점수 합계는 %d이고, 평균 점수는 %f입니다.\n", sum, (double)(sum/3));
// 실행 결과
국영수 과목 총 점수 합계는 240이고, 평균 점수는 80.000000입니다.
```

## 배열의 길이 자동 설정

C언어에서는 초기화 리스트에 맞춰 자동으로 배열의 길이를 설정할 수도 있다.

다음과 같이 배열의 길이를 따로 입력하지 않은 배열은 초기화 리스트의 배열 요소의 개수에 맞춰 자동으로 배열의 길이가 설정된다.

> ✅ 문법

```
타입 배열이름[] = {배열요소1, 배열요소2, ...};
```

다음 예제에서 int형 배열 arr의 길이는 자동으로 3으로 설정됨과 동시에 초기화 리스트에 의해 초기화된다.

> 📝 예제

```c
int arr[] = {1, 2, 3};
```

## 배열의 특징

C언어에서 배열은 다음과 같은 특징을 가진다.

1. 배열의 길이를 선언할 때에는 반드시 상수를 사용해야 한다.

2. 배열 요소의 인덱스는 언제나 0부터 시작한다.

3. C 컴파일러는 배열의 길이를 전혀 신경 쓰지 않는다.

> 📝 예제

```c
#include <stdio.h>

int main(void)
{
  int i;
  int sum = 0;
  int grade[3] = {85, 65, 90}; // grade[0], grade[1], grade[2]만 선언 및 초기화
  grade[3] = 100;              // grade[3]를 선언하지 않고 초기화 진행

  for (i = 0; i < 4; i++)      // grade[3]도 수식에 포함
  {
      sum += grade[i];
  }
  printf("국영수 과목 총 점수 합계는 %d이고, 평균 점수는 %f입니다.\n", sum, (double)sum/3);
}
// 실행 결과
국영수 과목 총 점수 합계는 340이고, 평균 점수는 113.333333입니다.
```

위의 예제에서는 크기가 3인 int형 배열 grade를 선언하고 있다.

즉, 배열 grade의 배열 요소는 grade[0], grade[1], grade[2]만이 존재한다.

하지만 존재하지도 않는 grade[3]이라는 배열 요소의 초기화를 진행하고, 반복문을 통해 수식에서도 이용한다.

이때 C 컴파일러는 오류는커녕 수식에서까지 이 배열 요소를 이용하여 결과를 출력한다.

하지만 이 결과는 개발자가 전혀 의도하지 않은 결과물이며, 이러한 프로그램은 종종 예상치 못한 결과를 내주기도 한다.

- 🚩위와 같이 C언어에서는 컴파일러가 일일이 배열의 길이 등을 검사하여 오류를 출력해 주지 않는다. 따라서 C언어로 프로그래밍할 때에는 이런 계산을 언제나 개발자가 직접 신경 써야 한다.

## 배열이 차지하는 메모리의 크기

C언어에서 배열을 복사하거나 배열 요소에 특정 작업을 하고 싶을 때는 해당 배열이 차지하는 메모리의 크기를 정확히 알고 있어야만 한다.

배열이 차지하는 총 `메모리의 크기`는 다음 수식을 사용하여 구할 수 있다.

> ✅ 메모리의 크기 수식

```
배열이 차지하는 메모리의 크기 = 배열의 길이 X sizeof(타입)
```

배열의 길이를 알고 싶을 때에는 다음 수식을 사용하여 구할 수 있다.

> ✅ 배열의 길이 수식

```
배열의 길이 = sizeof(배열 이름) / sizeof(배열 이름[0])
```

- 🚩 위의 수식에서 배열 이름[0]은 해당 배열의 타입을 표현하기 위해서 사용되었다.

> 📝 예제

다음 예제는 앞서 살펴본 수식을 이용하여 배열의 길이는 구하는 예제이다.

```c
#include <stdio.h>

int main(void)
{
  int grade[] = {85, 65, 90};                     // 배열의 길이를 명시하지 않음
  int arr_len = sizeof(grade) / sizeof(grade[0]); // 배열의 길이를 구하는 공식

  printf("배열 arrGrade의 길이는 %d입니다.\n", arr_len);
}
// 실행 결과
배열 grade의 길이는 3입니다.
```

# - 다차원 배열(multi-dimensional array)

`다차원 배열`이란 `2차원 이상의 배열`을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.

즉, 2차원 배열은 배열 요소로 1차원 배열을 가지는 배열이며, 3차원 배열은 배열 요소로 2차원 배열을 가지는 배열이고, 4차원 배열은 배열 요소로 3차원 배열을 가지는 배열인 것이다.

## 2차원 배열(two dimensional array)

2차원 배열이란 배열의 요소로 1차원 배열을 가지는 배열이다.

C언어에서는 2차원 배열을 나타내는 타입을 따로 제공하지 않는다.

대신에 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있다.

2차원 배열은 다음과 같은 문법에 따라 선언할 수 있다.

> ✅ 문법

```c
타입 배열이름[열의길이][행의길이];
```

타입은 배열 요소로 저장되는 변수의 타입을 설정한다.

배열 이름은 배열이 선언된 후에 배열에 접근하기 위해 사용된다.

다음 그림은 2차원 배열을 이해하기 쉽도록 도식적으로 표현한 그림이다.

<img src=http://tcpschool.com/lectures/img_c_array23.png>

하지만 컴퓨터의 메모리는 위와 같은 입체적 공간이 아닌 `선형 공간`이므로 실제로는 다음 그림과 같이 저장된다.

<img src=http://tcpschool.com/lectures/img_c_twodimensional_array.png>

> 📝 예제

```c
#include <stdio.h>

int main(void)
{
	int arr01[6] = {10, 20, 30, 40, 50, 60};
	int arr02[2][3] = {10, 20, 30, 40, 50, 60};

	printf("arr01의 배열 요소의 값\n");
	printf("%d %d %d %d %d %d\n", arr01[0], arr01[1], arr01[2], arr01[3], arr01[4], arr01[5]);
	printf("arr02의 배열 요소의 값\n");
	printf("%d %d %d %d %d %d\n", arr02[0][0], arr02[0][1], arr02[0][2], arr02[1][0], arr02[1][1], arr02[1][2]);
	return 0;
}
// 실행 결과
arr01의 배열 요소의 값
10 20 30 40 50 60
arr02의 배열 요소의 값
10 20 30 40 50 60
```

## 배열의 선언과 동시에 초기화하는 방법

1차원 배열과 마찬가지로 2차원 배열도 선언과 동시에 초기화할 수 있다.

2차원 배열은 1차원 배열과는 달리 여러 방식으로 초기화할 수 있다.

1. 1차원 배열의 초기화 형태를 따르는 방식

2. 배열의 모든 요소를 초기화하는 방식

3. 배열의 일부 요소만을 초기화하는 방식

### 1차원 배열의 초기화 형태를 따르는 방식

C언어에서는 2차원 배열을 1차원 배열의 초기화 형태로도 초기화할 수 있다.

> ✅ 문법

```c
타입 배열이름[열의길이][행의길이] = {배열요소[0][0], 배열요소[0][1], ..., 배열요소[1][0], 배열요소[1][1], ..., 배열요소[2][0], 배열요소[2][1], ...};
```

이 방식으로는 2차원 배열의 배열 요소[0][0]부터 차례대로 초기화된다.

만약에 초기화하는 배열 요소의 개수가 배열의 총 길이보다 적으면, 나머지 배열 요소는 모두 0으로 초기화된다.

### 배열의 모든 요소를 초기화하는 방식

C언어에서는 2차원 배열의 모든 요소를 초기화할 수 있다.

> ✅ 문법

```c
타입 배열이름[열의길이][행의길이] =
{
    {배열요소[0][0], 배열요소[0][1], ...},
    {배열요소[1][0], 배열요소[1][1], ...},
    {배열요소[2][0], 배열요소[2][1], ...},
    ...
};
```

이 방식은 앞서 살펴본 1차원 배열의 초기화 형태를 따르는 방식과 결과는 똑같다.

하지만 좀 더 직관적으로 2차원 배열의 모습을 알 수 있으므로 보통 이 방식을 가장 많이 사용한다.

> 📝 예제

다음 예제는 앞서 살펴본 두 가지 방식을 각각 사용하여 배열을 선언하고 초기화하는 예제이다.

```c
#include <stdio.h>

int main(void)
{
	int arr01[2][3] = {10, 20, 30, 40, 50,60};
	int arr02[2][3] = {
		{10, 20, 30},
		{40, 50, 60}
	};

	printf("arr01의 배열 요소의 값\n");
	printf("%d %d %d %d %d %d\n", arr01[0][0], arr01[0][1], arr01[0][2], arr01[1][0], arr01[1][1], arr01[1][2]);
	printf("arr02의 배열 요소의 값\n");
	printf("%d %d %d %d %d %d\n", arr02[0][0], arr02[0][1], arr02[0][2], arr02[1][0], arr02[1][1], arr02[1][2]);
	return 0;
}
// 실행 결과
arr01의 배열 요소의 값
10 20 30 40 50 60
arr02의 배열 요소의 값
10 20 30 40 50 60
```

### 배열의 일부 요소만을 초기화하는 방식

C언어에서는 2차원 배열의 일부 요소만을 초기화할 수도 있다.

이 방식으로는 다음 예제와 같이 2차원 배열의 원하는 배열 요소만을 초기화할 수 있다.

이때 초기화하지 않은 배열 요소는 모두 0으로 자동 초기화된다.

> 📝 예제

```c
#include <stdio.h>

int main(void)
{
	int i, j, arr_col_len, arr_row_len;
	int arr[3][4] = {
		{10, 20},
		{30, 40, 50, 60},
		{0, 0, 70, 80}
	};

	arr_col_len = sizeof(arr[0]) / sizeof(arr[0][0]);				// 2차원 배열의 열의 길이를 계산함
	arr_row_len = (sizeof(arr) / arr_col_len) / sizeof(arr[0][0]);	// 2차원 배열의 행의 길이를 계산함

	/* 2차원 배열의 출력 */
	for (i = 0; i < arr_row_len; i++)
	{
		for (j = 0; j < arr_col_len; j++)
		{
			printf("%4d", arr[i][j]);
		}
		printf("\n");
	}

	return 0;
}
// 실행 결과
10  20   0   0
30  40  50  60
 0   0  70  80
```

위의 예제에서 2차원 배열 열의 길이를 구할 때 사용하는 수식은 다음과 같다.

> ✅ 열의 길이 수식

```c
arr_col_len = sizeof(arr[0]) / sizeof(arr[0][0]); // 2차원 배열의 열의 길이를 계산함
```

열의 길이는 sizeof(arr[0])으로 먼저 2차원 배열 한 행의 길이를 구한 후에, 그 값을 배열 타입의 크기로 나누어서 구한다.

열의 길이를 이용하면 2차원 배열 행의 길이도 구할 수 있다.

> ✅ 행의 길이 수식

```c
arr_row_len = (sizeof(arr) / arr_col_len) / sizeof(arr[0][0]); // 2차원 배열의 행의 길이를 계산함
```

### 배열의 길이 자동 설정

1차원 배열과 마찬가지로 2차원 배열도 배열의 길이를 명시하지 않고, 자동으로 배열의 길이를 설정할 수 있다.

단, 열의 길이는 생략할 수 있지만, 행의 길이는 반드시 명시해야 한다.

> 📝 예제

다음 예제는 앞선 예제에서 열의 길이를 생략한 예제로, 같은 결과를 출력한다.

```c
#include <stdio.h>

int main(void)
{
	int i, j, arr_col_len, arr_row_len;
	int arr[][4] = {
		{10, 20},
		{30, 40, 50, 60},
		{0, 0, 70, 80}
	};

	arr_col_len = sizeof(arr[0]) / sizeof(arr[0][0]);				// 2차원 배열의 열의 길이를 계산함
	arr_row_len = (sizeof(arr) / arr_col_len) / sizeof(arr[0][0]);	// 2차원 배열의 행의 길이를 계산함

	/* 2차원 배열의 출력 */
	for (i=0; i<arr_row_len; i++)
	{
		for (j=0; j<arr_col_len; j++)
		{
			printf("%4d", arr[i][j]);
		}
		printf("\n");
	}

	return 0;
}
// 실행 결과
10  20   0   0
30  40  50  60
 0   0  70  80
```

---

# 포인터

## 주소값의 이해

데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미한다.

C언어에서는 이러한 주소값을 1바이트 크기의 메모리 공간으로 나누어 표현한다.

예를 들어, int형 데이터는 4바이트의 크기를 가지지만, int형 데이터의 주소값은 시작 주소 1바이트만을 가리킨다.

<img src=http://tcpschool.com/lectures/img_c_address.png>

## 포인터란?

C언어에서 `포인터(pointer)`란 `메모리의 주소값을 저장하는 변수`이며, `포인터 변수`라고도 부른다.

char형 변수가 문자를 저장하고, int형 변수가 정수를 저장하는 것처럼 `포인터`는 `주소값을 저장`한다.

> 📝 예제

```c
int n = 100;   // 변수의 선언
int *ptr = &n; // 포인터의 선언
```

다음 그림은 변수와 포인터가 메모리에 어떻게 저장되는지를 보여주는 예제이다.

<img src=http://tcpschool.com/lectures/img_c_pointer_memory.png>

## 포인터 연산자

C언어에서 포인터와 연관되어 사용되는 연산자는 다음과 같다.

1. 주소 연산자(&)

2. 참조 연산자(\*)

### 주소 연산자(&)

`주소 연산자`는 변수의 이름 앞에 사용하여, 해당 변수의 주소값을 반환한다.

`&기호`는 `앰퍼샌드(ampersand)`라고 읽으며, `번지 연산자`라고도 불린다.

### 참조 연산자(\*)

`참조 연산자`는 포인터의 이름이나 주소 앞에 사용하여, 포인터에 가리키는 주소에 저장된 값을 반환한다.

C언어에서 `'*'기호`는 사용하는 위치에 따라 다양한 용도로 사용된다.

이항 연산자로 사용하면 곱셈 연산으로 사용되며, 포인터의 선언 시나 메모리에 접근할 때도 사용된다.

## 포인터의 선언

C언어에서 포인터는 다음 문법에 따라 선언한다.

> ✅ 문법

```c
타입 *포인터이름;
```

타입이란 포인터가 가리키고자 하는 변수의 타입을 명시한다.

포인터 이름은 포인터가 선언된 후에 포인터에 접근하기 위해 사용된다.

포인터를 선언한 후 `참조 연산자(*)`를 사용하기 전에 포인터는 반드시 먼저 초기화되어야 한다.

그렇지 않으면 의도하지 않은 메모리의 값을 변경하게 되기 때문이다.

따라서 C 컴파일러는 초기화하지 않은 포인터에 참조 연산자를 사용하면 오류를 발생시킨다.

따라서 다음과 같이 포인터의 선언과 동시에 초기화를 함께 하는 것이 좋다.

> ✅ 문법

```c
타입* 포인터이름 = &변수이름;
또는
타입* 포인터이름 = 주소값;
```

## 포인터의 참조

C언어에서 선언된 포인터는 참조 연산자(\*)를 사용하여 참조할 수 있다.

> 📝 예제

다음 예제는 포인터의 주소값과 함께 포인터가 가리키고 있는 주소값의 데이터를 참조하는 예제이다.

```c
int x = 7;        // 변수의 선언
int* ptr = &x;    // 포인터의 선언
int* pptr = &ptr; // 포인터의 참조
```

<img src=http://tcpschool.com/lectures/img_c_pointer_reference.png>

>

```c
#include <stdio.h>

int main(void)
{
	int num01 = 1234;
	double num02 = 3.14;

	int* ptr_num01 = &num01;
	double* ptr_num02 = &num02;

	printf("포인터의 크기는 %d입니다.\n", sizeof(ptr_num01));   // ①번 라인
	printf("포인터 ptr_num01이 가리키고 있는 주소값은 %#x입니다.\n", ptr_num01);  // ②번 라인
	printf("포인터 ptr_num02가 가리키고 있는 주소값은 %#x입니다.\n", ptr_num02);  // ③3번 라인
	printf("포인터 ptr_num01이 가리키고 있는 주소에 저장된 값은 %d입니다.\n", *ptr_num01);
	printf("포인터 ptr_num02가 가리키고 있는 주소에 저장된 값은 %f입니다.\n", *ptr_num02);
	return 0;
}
// 실행 결과
포인터의 크기는 8입니다.
포인터 ptr_num01이 가리키고 있는 주소값은 0x8479c6c입니다.
포인터 ptr_num02가 가리키고 있는 주소값은 0x8479c70입니다.
포인터 ptr_num01이 가리키고 있는 주소에 저장된 값은 1234입니다.
포인터 ptr_num02가 가리키고 있는 주소에 저장된 값은 3.140000입니다.
```

위 예제의 ①번 라인에서는 `sizeof 연산자`를 사용하여 포인터 변수의 크기를 구하고 있다.

`포인터 변수`는 메모리에서 변수의 위치를 나타내는 주소를 다루는 변수이므로, 그 크기는 일반적으로 CPU에 따라 결정된다.

따라서 32비트 CPU에서는 1워드(word)의 크기가 4바이트이므로, 포인터 변수의 크기 또한 4바이트가 될 것이다.

하지만 이러한 포인터 변수의 크기는 컴파일러로 컴파일할 때 그 크기까지 직접 명시할 수 있다.

따라서 포인터 변수의 크기는 CPU의 종류와 컴파일할 때 사용된 컴파일러의 정책에 따라서 달라질 수 있다.

또한, ②번과 ③번 라인에서처럼 포인터가 가리키는 변수의 타입에 따라 포인터의 타입도 같이 바꿔주고 있다.

`포인터의 타입`은 참조 연산자(\*)를 통해 값을 참조할 때, 참조할 메모리의 크기를 알려주는 역할을 하기 때문입니다.

다음 그림은` char형 포인터`와 `int형 포인터`가 각각 메모리 상에서 해당 타입의 변수를 가리키는 것을 보여준다.

<img src=http://tcpschool.com/lectures/img_c_pointer_type.png>

`워드(word)`란 CPU가 한 번에 처리할 수 있는 데이터의 크기이다.

1바이트는 8비트이므로 32비트 시스템에서는 32비트 / 8비트 = 4, 즉 4바이트가 1워드(word)로 처리된다.

64비트 시스템에서는 64비트 / 8비트 = 8, 즉 8바이트가 1워드(word)로 처리된다.

## 포인터 연산

포인터는 값을 증가시키거나 감소시키는 등의 제한된 연산만을 할 수 있다.

C언어의 포인터 연산에는 다음과 같은 규칙이 있다.

1. 포인터끼리의 덧셈, 곱셈, 나눗셈은 아무런 의미가 없다.

2. 포인터끼리의 뺄셈은 두 포인터 사이의 상대적 거리를 나타낸다.

3. 포인터에 정수를 더하거나 뺄 수는 있지만, 실수와의 연산은 허용하지 않는다.

4. 포인터끼리 대입하거나 비교할 수 있다.

> 📝 예제

다음 예제는 타입에 따른 포인터 연산의 증가값을 비교하는 예제이다.

```c
#include <stdio.h>

int main(void)
{
	char* ptr_char = 0;
	int* ptr_int = NULL;
	double* ptr_double = 0x00;

	printf("포인터   ptr_char가 현재 가리키고 있는 주소값은 %#x입니다.\n", ptr_char);
	printf("포인터    ptr_int가 현재 가리키고 있는 주소값은 %#x입니다.\n", ptr_int);
	printf("포인터 ptr_double이 현재 가리키고 있는 주소값은 %#x입니다.\n", ptr_double);

	printf("포인터   ptr_char가 1 증가 후에 가리키고 있는 주소값은 %#x입니다.\n", ++ptr_char);
	printf("포인터    ptr_int가 1 증가 후에 가리키고 있는 주소값은 %#x입니다.\n", ++ptr_int);
	printf("포인터 ptr_double이 1 증가 후에 가리키고 있는 주소값은 %#x입니다.\n", ++ptr_double);
	return 0;

  // 실행 결과
  포인터   ptr_char가 현재 가리키고 있는 주소값은 0입니다.
  포인터    ptr_int가 현재 가리키고 있는 주소값은 0입니다.
  포인터 ptr_double이 현재 가리키고 있는 주소값은 0입니다.
  포인터   ptr_char가 1 증가 후에 가리키고 있는 주소값은 0x1입니다.
  포인터    ptr_int가 1 증가 후에 가리키고 있는 주소값은 0x4입니다.
  포인터 ptr_double이 1 증가 후에 가리키고 있는 주소값은 0x8입니다.
}
```

위의 예제에서 모든 포인터에 저장된 초기 주소값은 0x00 이다.

하지만 1을 증가시키는 포인터 연산 후 포인터가 가리키고 있는 주소는 각각의 포인터 타입에 따라 달라진다.

그 증가 폭은 포인터가 가리키는 변수의 타입의 크기와 같게 된다.

<img src =http://tcpschool.com/lectures/img_c_pointer_calculation.png>

예를 들어, int형 포인터의 증가폭은 int형 타입의 크기인 4바이트만큼 증가하게 된다.

이 법칙은 포인터의 뺄셈에서도 똑같이 적용된다.

> 📝 예제

다음 예제는 포인터끼리의 비교 연산과 대입 연산을 보여주는 예제이다.

```c
#include <stdio.h>

int main(void)
{
	int num01 = 10;
	int num02 = 20;
	int *ptr_num01 = &num01;
	int *ptr_num02 = &num02;

	if (ptr_num01 != ptr_num02)		// 포인터끼리의 비교 연산
	{
		printf("포인터 ptr_num01이 가리키고 있는 주소에 저장된 값은 %d입니다.\n", *ptr_num01);
		printf("포인터 ptr_num02가 가리키고 있는 주소에 저장된 값은 %d입니다.\n", *ptr_num02);
		printf("포인터 ptr_num01과 ptr_num02는 현재 다른 주소를 가리키고 있습니다.\n\n");
		ptr_num02 = ptr_num01;		// 포인터끼리의 대입 연산
	}

	printf("포인터 ptr_num01이 가리키고 있는 주소에 저장된 값은 %d입니다.\n", *ptr_num01);
	printf("포인터 ptr_num02가 가리키고 있는 주소에 저장된 값은 %d입니다.\n", *ptr_num02);

	if (ptr_num01 == ptr_num02)		// 포인터끼리의 비교 연산
	{
		printf("포인터 ptr_num01과 ptr_num02는 현재 같은 주소를 가리키고 있습니다.\n");
	}

	return 0;
}
// 실행 결과
포인터 ptr_num01이 가리키고 있는 주소에 저장된 값은 10입니다.
포인터 ptr_num02가 가리키고 있는 주소에 저장된 값은 20입니다.
포인터 ptr_num01과 ptr_num02는 현재 다른 주소를 가리키고 있습니다.

포인터 ptr_num01이 가리키고 있는 주소에 저장된 값은 10입니다.
포인터 ptr_num02가 가리키고 있는 주소에 저장된 값은 10입니다.
포인터 ptr_num01과 ptr_num02는 현재 같은 주소를 가리키고 있습니다.
```

## 인수 전달 방법

함수를 호출할 때에는 함수에 필요한 데이터를 인수(argument)로 전달해 줄 수 있다.

이렇게 함수에 인수를 전달하는 방법에는 크게 다음과 같이 두 가지 방법이 있다.

1. 값에 의한 전달(call by value)

2. 참조에 의한 전달(call by reference)

### 값에 의한 전달(call by value)

값에 의한 전달 방법은 인수로 전달되는 변수가 가지고 있는 값을 함수 내의 매개변수에 복사하는 방식이다.

이렇게 복사된 값으로 초기화된 매개변수는 인수로 전달된 변수와는 완전히 별개의 변수가 된다.

따라서 함수 내에서의 매개변수 조작은 인수로 전달되는 변수에 아무런 영향을 미치지 않는다.

> 📝 예제

```c
#include <stdio.h>

void local(int);

int main(void)
{
	int var = 10;
	printf("변수 var의 초기값은 %d입니다.\n", var);

	local(var);
	printf("local() 함수 호출 후 변수 var의 값은 %d입니다.\n", var);
	return 0;
}

void local(int num)
{
	num += 10;
}

// 실행 결과
변수 var의 초기값은 10입니다.
local() 함수 호출 후 변수 var의 값은 10입니다.
```

위의 예제에서 local() 함수의 매개변수 num는 인수로 변수 var의 값을 전달받는다.

따라서 함수 내에서 매개변수 num의 값을 아무리 변경하더라도 원래 인수로 전달된 변수 var의 값은 절대 변경되지 않는다.

## 참조에 의한 전달(call by reference)

참조에 의한 전달 방법은 인수로 변수의 값을 전달하는 것이 아닌, 해당 변수의 주소값을 전달한다.

즉 함수의 매개변수에 인수로 전달된 변수의 원래 주소값을 저장하는 것이다.

이 방식을 사용하면 인수로 전달된 변수의 값을 함수 내에서 변경할 수 있게 된다.

> 📝 예제

```c
#include <stdio.h>

void local(int*);

int main(void)
{
	int var = 10;
	printf("변수 var의 초기값은 %d입니다.\n", var);

	local(&var);
	printf("local() 함수 호출 후 변수 var의 값은 %d입니다.\n", var);
	return 0;
}

void local(int* num)
{
	*num += 10;
}

// 실행 결과
변수 var의 초기값은 10입니다.
local() 함수 호출 후 변수 var의 값은 20입니다.
```

위의 예제에서 local() 함수의 매개변수 num는 인수로 변수 var의 주소값을 전달받는다.

따라서 함수 내에서 매개변수 num의 값을 변경하면, 원래 인수인 변수 var의 값도 같이 변경된다.

## 포인터의 포인터

포인터의 포인터란 포인터 변수를 가리키는 포인터를 의미한다.

`참조 연산자(*)`를 두 번 사용하여 표현하며, `이중 포인터`라고도 부른다.

다음 그림은 포인터와 포인터의 포인터와의 동작 상 차이점을 보여주고 있다.

<img src=http://tcpschool.com/lectures/img_c_pointer_memory.png>

> 📝 예제

다음 예제는 포인터의 포인터를 선언하고, 포인터의 포인터를 이용한 접근 방법을 보여주고 있다.

```c
#include <stdio.h>

int main(void)
{
	int num = 10;				// 변수 선언
	int* ptr_num = &num;		// 포인터 선언
	int** pptr_num = &ptr_num;	// 포인터의 포인터 선언

	printf("변수 num가 저장하고 있는 값은 %d입니다.\n", num);
	printf("싱글 포인터  ptr_num가 가리키는 주소에 저장된 값은 %d입니다.\n", *ptr_num);
	printf("더블 포인터 pptr_num가 가리키는 주소에 저장된 포인터가 가리키는 주소에 저장된 값은 %d입니다.\n", **pptr_num);
	return 0;
}

// 실행 결과
변수 num가 저장하고 있는 값은 10입니다.
포인터 ptr_num가 가리키는 주소에 저장된 값은 10입니다.
포인터의 포인터 pptr_num가 가리키는 주소에 저장된 포인터가 가리키는 주소에 저장된 값은 10입니다.
```

## void 포인터(void pointer)

void 포인터는 일반적인 포인트 변수와는 달리 대상이 되는 데이터의 타입을 명시하지 않은 포인터다.

따라서 변수, 함수, 포인터 등 어떠한 값도 가리킬 수 있지만, 포인터 연산이나 메모리 참조와 같은 작업은 할 수 없다.

즉 void 포인터는 주소값을 저장하는 것 이외에는 아무것도 할 수 없는 포인터다.

또한, void 포인터를 사용할 때에는 반드시 `먼저 사용하고자 하는 타입`으로 `명시적 타입 변환 작업`을 거친 후에 사용해야 한다.

다음 예제는 void 포인터의 선언 및 void 포인터를 이용한 접근 방법을 보여주고 있다.

```c
#include <stdio.h>

int main(void)
{
	int num = 10;			// 변수 선언
	void* ptr_num = &num;	// void 포인터 선언

	printf("변수 num가 저장하고 있는 값은 %d입니다.\n", num);
	printf("void 포인터 ptr_num가 가리키는 주소에 저장된 값은 %d입니다.\n", *(int*)ptr_num);

	*(int*)ptr_num = 20;	// void 포인터를 통한 메모리 접근

	printf("void 포인터 ptr_num가 가리키는 주소에 저장된 값은 %d입니다.\n", *(int*)ptr_num);
	return 0;
}

// 실행 결과
변수 num가 저장하고 있는 값은 10입니다.
void 포인터 ptr_num가 가리키는 주소에 저장된 값은 10입니다.
void 포인터 ptr_num가 가리키는 주소에 저장된 값은 20입니다.
```

void 포인터는 사용할 때마다 명시적 타입 변환을 하고 난 뒤에 사용해야 한다.

## 함수 포인터(function pointer)

프로그램에서 정의된 함수는 프로그램이 실행될 때 모두 메인 메모리에 올라가게 된다.

이때 함수의 이름은 메모리에 올라간 함수의 시작 주소를 가리키는 `포인터 상수(constant pointer)`가 된다.

이렇게 함수의 시작 주소를 가리키는 포인터 상수를 `함수 포인터(function pointer)`라고 부른다.

함수 포인터의 포인터 타입은 함수의 반환값과 매개변수에 의해 결정된다.

즉 함수의 원형을 알아야만 해당 함수에 맞는 함수 포인터를 만들 수 있다.

> ✅ 함수 원형

```c
void func (int, int);
```

위와 같은 함수 원형을 가지는 함수에 대한 함수 포인터는 다음과 같다.

> ✅ 함수 포인터

```c
void (*ptr_func) (int, int);
```

- 🚩 함수 포인터 사용시 연산자의 우선순위 때문에 반드시 `*ptr_func 부분`을 괄호(())로 둘러싸야 한다.

## 널 포인터(null pointer)

0이나 NULL을 대입하여 초기화한 포인터를 `널 포인터(null pointer)`라고 한다.

`널 포인터`는 아무것도 가리키지 않는 포인터라는 의미다.

---

# 포인터와 배열의 관계

포인터와 배열은 매우 긴밀한 관계를 맺고 있으며, 어떤 부분에서는 서로를 대체할 수도 있다.

배열의 이름은 그 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같다.

따라서 배열의 다른 이름은 `포인터 상수(constant pointer)`이다.

- 🚩 `포인터 상수(constant pointer)`란 `포인터 변수`가 가리키고 있는 주소 값을 변경할 수 없는 포인터를 의미하며,
  `상수 포인터(pointer to constant)`란 상수를 가르키는 포인터를 의미한다.

> 📝 예제

```c
#include <stdio.h>

int main(void)
{
	int arr[3] = {10, 20, 30};	// 배열 선언
	int* ptr_arr = arr;			// 포인터에 배열의 이름을 대입함

	printf("배열의 이름을 이용하여 배열 요소에 접근 : %d %d %d\n", arr[0], arr[1], arr[2]);
	printf("    포인터를 이용하여 배열 요소에 접근 : %d %d %d\n", ptr_arr[0], ptr_arr[1], ptr_arr[2]);

	printf("배열의 이름을 이용한 배열의 크기 계산 : %d\n", sizeof(arr));
	printf("    포인터를 이용한 배열의 크기 계산 : %d\n", sizeof(ptr_arr));
	return 0;
}

// 실행 결과
배열의 이름을 이용하여 배열 요소에 접근 : 10 20 30
    포인터를 이용하여 배열 요소에 접근 : 10 20 30
배열의 이름을 이용한 배열의 크기 계산 : 12
    포인터를 이용한 배열의 크기 계산 : 8
```

위의 예제에서는 포인터에 배열의 이름을 대입한 후, 해당 포인터를 배열의 이름처럼 사용한다.

이처럼 C언어에서는 배열의 이름을 포인터처럼 사용할 수 있을 뿐만 아니라, 포인터를 배열의 이름처럼 사용할 수도 있다.

하지만 배열의 크기를 계산할 때에는 배열의 이름과 포인터 사이에 차이가 발생한다.

배열의 이름을 이용한 크기 계산에서는 배열의 크기가 int형 배열 요소 3개의 크기인 12바이트로 제대로 출력된다.

하지만 포인터를 이용한 크기 계산에서는 배열의 크기가 아닌 포인터 변수 자체의 크기가 출력되는 차이가 있다.

## 배열의 포인터 연산

다음 예제는 앞선 예제와는 반대로 배열의 이름을 포인터처럼 사용하는 예제다.

배열의 이름으로 포인터 연산을 수행하여 각각의 배열 요소에 접근다.

```c
#include <stdio.h>

int main(void)
{
	int arr[3] = {10, 20, 30};	// 배열 선언

	printf("        배열의 이름을 이용하여 배열 요소에 접근 : %d %d %d\n", arr[0], arr[1], arr[2]);
	printf("배열의 이름으로 포인터 연산을 해 배열 요소에 접근 : %d %d %d\n", *(arr+0), *(arr+1), *(arr+2));
	return 0;
}

// 실행 결과
          배열의 이름을 이용하여 배열 요소에 접근 : 10 20 30
배열의 이름으로 포인터 연산을 해 배열 요소에 접근 : 10 20 30
```

<img src=http://tcpschool.com/lectures/img_c_array_name.png>

> ✅ 공식

```c
// arr이 배열의 이름이거나 포인터이고 n이 정수일 때,
arr[n] == *(arr + n)
```

위의 공식은 1차원 배열뿐만 아니라 다차원 배열에서도 언제나 성립한다.

- 🚩 배열에 관계된 연산을 할 때는 언제나 배열의 크기를 넘어서는 접근을 하지 않도록 주의해야 한다.

  포인터 연산을 이용하여 계산하다가 배열의 크기를 넘어서는 접근을 하는 경우, C 컴파일러는 어떠한 오류도 발생시키지 않는다.

  다만 잘못된 결과만을 반환하므로 C언어로 프로그래밍할 때에는 언제나 배열의 크기에도 주의해야 한다.

## 포인터 배열

`포인터 배열`이란 `배열 요소로 포인터 변수를 가지는 배열`을 의미한다.

즉, `포인터 변수를 저장할 수 있는 배열`을 의미한다.

> 📝 예제

다음 예제는 세 개의 int형 포인터 변수를 저장할 수 있는 포인터 배열을 선언하는 예제이다.

```c
#include <stdio.h>

int main(void)
{
	int i, arr_len;
	int num01 = 10, num02 = 20, num03 = 30;
	int* arr[3] = {&num01, &num02, &num03};	// int형 포인터 배열 선언

	arr_len = sizeof(arr)/sizeof(arr[0]);
	for (i = 0; i < arr_len; i++)
	{
		printf("%d\n", *arr[i]);
	}

	return 0;
}

// 실행 결과
10
20
30
```

다음 그림은 위의 예제에서 사용된 포인터 배열이 메모리 상에서 어떻게 동작하는지를 보여준다.

<img src=http://tcpschool.com/lectures/img_c_pointer_array.png>

## 배열 포인터

`배열 포인터`란 배열을 가리킬 수 있는 포인터를 의미한다.

앞서 `배열의 이름`은 그 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같다고 했다.

이렇게 배열 이름이 있는데도 따로 배열 포인터를 정의하여 사용하는 이유는 2차원 이상의 배열을 가리킬 때 포인터를 통해 배열과 같은 인덱싱을 할 수 있도록 하기 위함이다.

즉, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용한다.

따라서 배열 포인터는 1차원 배열에서는 아무런 의미가 없으며, 2차원 이상의 배열에서만 의미를 가진다.

<img src=http://tcpschool.com/lectures/img_c_array_pointer.png>

위의 그림에서 보면 2차원 배열의 배열 이름 arr는 부분 배열 arr[0]와 같은 곳을 가리킨다.

2차원 배열의 배열 이름으로 포인터 연산을 하면 배열의 행 단위로 이동하게 된다.

즉, (arr+1)은 arr[1]과 같은 곳을 가리키게 된다.

> 📝 예제

다음 예제는 2차원 배열에서 각 부분 배열의 시작 주소가 가리키는 메모리에 저장된 데이터를 출력하는 예제다.

```c
#include <stdio.h>

int main(void)
{
	int arr[2][3] =
	{
		{10, 20, 30},
		{40, 50, 60}
	};

	printf("%d\n", *arr[0]);
	printf("%d\n", *arr[1]);
	return 0;
}
// 실행 결과
10
40
```

2차원 배열에서는 포인터 연산 시 증가하는 값이 행의 길이에 따라 차이를 보이게 된다.

2차원 배열의 행의 길이란 부분 배열의 크기를 의미하며, 다음 수식으로 구할 수 있다.

> ✅ 수식

```
sizeof(arr[0]) / sizeof(타입)
```

> 📝 예제

다음 예제에서 포인터 연산 시 증감하는 값의 크기는 int형 타입의 크기인 4바이트에 배열 행의 길이인 3를 곱한 12바이트가 된다.

```c
int arr[2][3];
```

따라서 위의 예제에서 배열 이름 arr의 타입은 정확하게 다음과 같이 정의할 수 있다.

1. 배열의 이름 arr는 int형 데이터를 가리키는 배열 포인터다.

2. 이 배열 포인터는 포인터 연산 시 증감하는 값의 크기가 12바이트다.

> 📝 예제

따라서 위의 예제에서 배열 arr를 가리키는 배열 포인터는 다음과 같이 선언할 수 있다.

```c
int (*pArr)[3];
```

또한, 위 예제의 배열 포인터는 다음과 같은 배열들을 가리킬 수 있다.

> 📝 예제

```c
int arr01[2][3];
int arr02[3][3];
int arr03[4][3];
...
```

다음 예제는 배열 포인터를 사용하여 배열과 같은 인덱싱 방법으로 배열 요소를 참조하는 예제다.

```c
#include <stdio.h>

int main(void)
{
	int arr[2][3] = 			// 배열의 선언
	{
		{10, 20, 30},
		{40, 50, 60}
	};
	int (*pArr)[3] = arr;		// 배열 포인터의 선언

	printf("%d\n", arr[1][1]);	// 배열 이름으로 참조
	printf("%d\n", pArr[1][1]);	// 배열 포인터로 참조
	return 0;
}
// 실행 결과
50
50
```

## 포인터 배열과 배열 포인터의 구분

앞선 예제의 배열 포인터에서 괄호(())를 생략하면 전혀 다른 의미가 된다.

> 📝 예제

```c
1. int (*pArr)[3];
2. int* pArr[3];
```

위의 예제 중에서 첫 번째는 int형 데이터를 저장할 수 있는 2차원 배열을 가리키는 배열 포인터다.

하지만 두 번째는 int형 데이터를 가리킬 수 있는 포인터 변수를 모아 놓은 배열을 가리키는 포인터 배열이 된다.

따라서 괄호의 유무가 중요하며, 포인터 배열과 배열 포인터 사이의 차이점을 정확히 이해하고 넘어가야 한다.

## main() 함수의 인수 전달

main() 함수는 프로그램이 실행되면 제일 먼저 자동으로 호출되는 함수다.

이러한 main() 함수도 함수이기 때문에 인수를 전달받을 수도 있고, 반환값을 가질 수도 있다.

C언어의 main() 함수의 원형은 다음과 같다.

> ✅ 원형

```c
void(또는 int) main(int argc, char *argv[]);
```

C언어의 main() 함수의 첫 번째 인수는 int형 변수인 argc로 main() 함수에 인수로 전달되는 문자열의 개수를 명시한다.

두 번째 인수는 char형 포인터 배열인 argv로 main() 함수에 인수로 전달된 각각의 문자열이 저장된 배열을 가리킨다.
 