# 자바스크립트(JavaScript)란?

자바스크립트(JavaScript)는 객체(object) 기반의 스크립트 언어이다.

HTML로는 웹의 내용을 작성하고, CSS로는 웹을 디자인하며, 자바스크립트로는 웹의 동작을 구현한다.

자바스크립트는 주로 웹 브라우저에서 사용되나, Node.js와 같은 프레임워크를 사용하면 서버 측 프로그래밍에서도 사용할 수 있다.

현재 컴퓨터나 스마트폰 등에 포함된 대부분의 웹 브라우저에는 자바스크립트 인터프리터가 내장되어 있다.

역사에 대해서는 대충 넘어가도록 하자.

# 자바스크립트의 특징

자바스크립트가 가지고 있는 언어적 특징은 다음과 같다.

1. 자바스크립트는 객체 기반의 스크립트 언어
2. 자바스크립트는 동적이며, 타입을 명시할 필요가 없는 인터프리터 언어
3. 자바스크립트는 객체 지향형 프로그래밍과 함수형 프로그래밍을 모두 표현할 수 있다.

> 인터프리터 언어란?

C언어와 같은 언어는 소스 파일을 작성한 후, 해당 파일을 컴파일(compile)하여 사용자가 실행할 수 있는 실행 파일(.exe)로 만들어 사용한다.

하지만 인터프리터 언어는 이러한 컴파일 작업을 거치지 않고, 소스 코드를 바로 실행할 수 있는 언어를 의미한다.

자바스크립트는 웹 브라우저에 포함된 자바스크립트 인터프리터가 소스 코드를 직접 해석하여 바로 실행해준다.

# 자바와 자바스크립트

공부하기 전에도 해깔려 했듯이 자바와 자바스크립트는 그 이름만 놓고 보면 서로 관련이 있는 언어로 생각되기 쉽다.

그러나 두 언어는 서로 직접적인 관련은 없으며, 비슷한 점보다는 다른 점이 훨씬 많다.

문법상 비슷한 부분이 많다고 하는데 이는 두 언어의 문법이 모두 C언어를 기반으로 만들어졌기 때문이라고 한다.

- 자바
  컴파일 언어
  타입 검사를 엄격하게 함
  클래스(class) 기반의 객체 지향 언어

- 자바스크립트
  인터프리터 언어
  타입을 명시하지 않음
  프로토타입(prototype) 기반의 객체 지향 언어

# 자바스크립트 소개

자바스크립트를 사용하면 웹 프로그래밍에서 다음과 같은 일들이 가능하다.

- 자바스크립트는 HTML의 `'내용'`, `'속성'`, `'스타일'`을 변경할 수 있다.

# 자바스크립트 문법

> 프로그램(Program)이란 ?

프로그램은 컴퓨터가 실행할 수 있는 명령(instruction)으로 이루어진다.

컴퓨터 프로그래밍에서 컴퓨터가 실행할 수 있는 명령들을 실행문(statement)이라고 부른다.

즉, 프로그램이란 특정 결과를 얻기 위해서 컴퓨터에 의해 실행되는 실행문의 집합이라고 할 수 있다.

## 자바스크립트 문법

자바스크립트의 실행문은 세미콜론(;)으로 구분된다.

ex)

```js
var x = 10;

var result = x + 3;
```

또한 자바스크립트는 대소문자를 구분한다.

자바스크립트에서 변수나 함수의 이름, 예약어 등을 작성하거나 사용할 때에는 대소문자를 정확히 구분해서 사용해야 한다.

ex)

```js
var javascript = 10; // 변수 javascript와 JavaScript는 서로 다른 두 개의 변수로 인식됨.

var JavaScript = 20;

Var Script = 30; // 변수의 선언은 var 키워드로만 할 수 있으면 Var는 동작하지 않음.
```

# 리터럴(Literal)

리터럴은 직접 표현되는 값 그 자체를 의미한다.

리터럴의 종류는 다음 예제를 통해 알아보자.

ex)

```js
12; // 숫자 리터럴
("JavaScript"); // 문자열 리터럴
("안녕하세요"); // 문자열 리터럴
true; // 불리언 리터럴
```

# 식별자(identifier)

식별자는 변수나 함수의 이름을 작성할 때 사용하는 이름을 의미한다.

자바스크립트에서 식별자는 영문자(대소문자), 숫자, 언더스코어(\_) 또는 달러($)만을 사용할 수 있다.

> 기억해야할 포인트

- 자바스크립트에서 식별자는 숫자와 식별자의 구별을 빠르게 할 수 있도록 숫자로는 시작할 수 없다.

- 자바스크립트는 유니코드(unicode) 문자셋을 사용한다.

## 식별자 저장 방식

자바스크립트에서는 식별자를 작성할 때 다음과 같은 작성 방식을 사용할 수 있다.

1. Camal Case 방식

2. Underscore Case 방식

> Camal Case 방식

Camel Case 방식이란 식별자가 여러 단어로 이루어질 경우에 첫 번째 단어는 모두 소문자로 작성하고, 그다음 단어부터는 첫 문자만 대문자로 작성하는 방식이다.

> Underscore Case 방식

Underscore Case 방식은 식별자를 이루는 단어들을 소문자로만 작성하고, 그 단어들은 언더스코어(\_)로 연결하는 방식이다.

자바스크립트에서는 식별자를 작성할 때 관행적으로 Camal Case 방식을 많이 사용한다.

ex)

```js
var firstVar = 10;           // Camel Case 방식
function my_first_func {     // Underscore Case 방식
    var firstLocalVar = 20;  // Camel Case 방식
}
```

> 기억해야할 포인트

- 자바스크립트에서 하이픈(-)은 뺄셈을 위해 예약된 키워드이므로, 식별자를 작성할 때는 사용할 수 없다.

# 키워드

자바스크립트에서는 몇몇 단어들을 특별한 용도로 사용하기 위해 미리 예약하고 있다.

이렇게 미리 예약된 단어들을 키워드(keyword) 또는 예약어(reserved word)라고 한다.

이러한 키워드들은 프로그램 내에서 식별자로 사용할 수 없다.

ex)

```js
var firstVar = 10;      // var는 변수의 정의를 위해 예약된 키워드이다.
function myFirstFunc {  // function은 함수의 정의를 위해 예약된 키워드이다.

    var secondVar = 20; // var는 변수의 정의를 위해 예약된 키워드이다.
}
```

# 주석(comment)

주석(comment)이란 코드 내에 삽입된 일종의 설명문이다.

주석은 작성자나 다른 개발자가 나중에 코드를 수정할 때 참고할 수 있으며, 웹 페이지 개발 시 디버깅에도 사용된다.

이러한 주석은 자바스크립트 코드의 어느 부분에라도 작성할 수 있으며, 웹 브라우저의 동작에는 전혀 영향을 미치지 않는다.

자바스크립트 주석은 다음과 같은 두 가지 형식을 지원한다.

```js
1. 한 줄 주석 : // 주석문

2. 여러 줄 주석 : /* 주석문 */
```

ex)

```js
var x = 10;
// var y = 20; 한 줄의 주석문 : 이 부분은 실행되지 않는다.

/*
x = x + y;
여러 줄의 주석문 :
이 부분 또한 실행되지 않는다.
*/
document.getElementById("text").innerHTML = x;
```

다음은 자바스크립트에서 여러 줄 주석 안에 또 다른 주석을 삽입하는 예제이다.

ex)

```js
/* 여러 줄
    // 이렇게 두 줄 주석 안에 또 다른 한 줄 주석을 삽입할 수 있다.
주석 예제 . */
```

위의 예제처럼 자바스크립트에서는 여러 줄 주석 내부에 또 다른 한 줄 주석을 삽입할 수 있다.

하지만 여러 줄 주석 내부에 또 다른 여러 줄 주석을 삽입할 수는 없다.

ex)

```js
/* 여러 줄
    /* 또 다른 여러 줄 주석 예제 */
주석 예제. */
```

위의 예제처럼 여러 줄 주석 안에 또 다른 여러 줄 주석을 삽입하게 되면, 삽입한 주석의 종료를 알려주는 기호(_/)를 첫 번째 주석이 자신의 종료를 알려주는 기호(_/)로 인식하게 된다.

따라서 위의 예제에서 세 번째 라인은 주석으로 정상 인식되지 않으며, Uncaught SyntaxError가 발생하여 실행중이던 스크립트는 중지될 것이다.

그러므로 자바스크립트에서 여러 줄 주석은 절대로 중첩해서 사용해서는 안 된다.

# 자바스크립트 출력

자바스크립트는 여러 방법을 통해 결과물을 HTML 페이지에 출력할 수 있다. 그 방법에는 여러가지가 있는데 다음과 같다.

1. window.alert() 메소드

2. HTML DOM 요소를 이용한 innerHTML 프로퍼티

3. document.write() 메소드

4. console.log() 메소드

---

## windows.alert() 메소드

자바스크립트에서 가장 간단하게 데이터를 출력할 수 있는 방법은 window.alert() 메소드를 이용하는 것이다.

window.alert() 메소드는 브라우저와는 별도의 대화 상자를 띄워 사용자에게 데이터를 전달해준다.

ex)

```js
<script>
  function alertDialogBox(){" "}
  {alert("확인을 누를 때까지 다른 작업을 할 수 없다.")}
</script>
```

[실습링크]("http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_output_01")

- window 객체의 모든 메소드나 프로퍼티를 사용할 때는 window라는 접두사를 생략할 수 있다.

## HTML DOM 요소를 이용한 innerHTML 프로퍼티

실제 자바스크립트 코드에서 출력을 위해 가장 많이 사용되는 방법은 HTML DOM 요소를 이용한 innerHTML 프로퍼티를 이용하는 방법이다.

우선 document 객체의 getElementByID()나 getElementsByTagName() 등의 메소드를 사용하여 HTML 요소를 선택한다.

그리고서 innerHTML 프로퍼티를 이용하면 선택된 HTML 요소의 내용(content)이나 속성(attribute)값 등을 손쉽게 변경할 수 있다.

ex)

```js
<script>
  var str = document.getElementById("text"); str.innerHTML = "이 문장으로
  바뀌었습니다!";
</script>
```

[실습링크]("http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_output_02")

---

## document.write() 메소드

document.write() 메소드는 웹 페이지가 로딩될 때 실행되면, 웹 페이지에 가장 먼저 데이터를 출력한다.

따라서 document.write() 메소드는 대부분 테스트나 디버깅을 위해 사용된다.

ex)

```js
<script>document.write(4 * 5);</script>
```

실습링크 : http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_output_03

하지만 웹 페이지의 모든 내용이 로딩된 후에 document.write() 메소드가 실행되면, 웹 페이지 내에 먼저 로딩된 모든 데이터를 지우고 자신의 데이터를 출력하게 된다.

따라서 document.write() 메소드를 테스트 이외의 용도로 사용할 때에는 충분히 주의해서 사용해야 한다.

ex)

```js
<button onclick="document.write(4 * 5)">버튼을 눌러보세요!</button>
```

[실습 링크]("http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_output_04")

---

## console.log()메소드

console.log() 메소드는 웹 브라우저의 콘솔을 통해 데이터를 출력하거나 IDE의 터미널에 출력하기도 한다.

대부분의 주요 웹 브라우저에서는 F12를 누른 후, 메뉴에서 콘솔을 클릭하면 콘솔 화면을 사용할 수 있다.

이러한 콘솔 화면을 통한 데이터의 출력은 좀 더 자세한 사항까지 출력되므로, 디버깅하는데 많은 도움을 준다.

ex)

```js
<p>F12를 눌러서 콘솔 화면을 열면 결과를 확인할 수 있습니다.</p>

<script>
    console.log(4 * 5);
</script>
```

실습링크 : http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_output_05

# 자바스크립트 적용

HTML 문서에 자바스크립트 코드를 적용하는 방법에는 다음과 같은 방법이 있다.

1. 내부 자바스크립트 코드로 적용
2. 외부 자바스크립트 파일로 적용

## 내부 자바스크립트 코드

자바스크립트 코드는 `<script>`태그를 사용하여 HTML 문서 안에 삽입할 수 있다.

```html
<!-- 문법 -->
<script>
  document.getElementById("text").innerHTML = "여러분을 환영합니다!";
</script>
```

이렇게 삽입된 자바스크립트 코드는 HTML 문서의 `<head>`태그나 `<body>`태그, 또는 양쪽 모두에 위치할 수 있다.

다음 예제는 HTML 문서의 <head>태그에 자바스크립트 코드를 삽입한 예제이다.

```js
<head>
    <meta charset="UTF-8">
    <title>JavaScript Apply</title>
    <script>
        function printDate() {
            document.getElementById("date").innerHTML = Date();
        }
    </script>
</head>
```

[실습링크]("http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_apply_01")

자바스크립트 코드를 <head>태그에 삽입하나 <body>태그에 삽입하나 동작상의 차이는 없다.

```js
<body>
    <p>자바스크립트를 이용하면 현재 날짜와 시간 정보에도 손쉽게 접근할 수 있어요!</p>
    <button onclick="printDate()">현재 날짜와 시간 표시하기!</button>
    <p id="date"></p>
    <script>
        function printDate() {
            document.getElementById("date").innerHTML = Date();
        }
    </script>
</body>
```

## 외부 자바스크립트 파일

자바스크립트 코드는 HTML 문서의 내부뿐만 아니라 외부 파일로 생성하여 삽입할 수도 있다.

외부에 작성된 자바스크립트 파일은 .js 확장자를 사용하여 저장한다.

해당 자바스크립트 파일을 적용하고 싶은 모든 웹 페이지에 `<script>`태그를 사용해 외부 자바스크립트 파일을 포함하면 된다.

```js
// example.js 라는 파일이라고 가정
function printDate() {
  document.getElementById("date").innerHTML = Date();
}
```

ex)

```html
<head>
  <meta charset="UTF-8" />
  <title>JavaScript Apply</title>
  <script src="/examples/media/example.js"></script>
</head>
```

[실습링크]("http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_intro_apply_03")

외부 자바스크립트 파일을 사용하면 웹의 내용을 담당하는 HTML 코드로부터 웹의 동작을 구현하는 자바스크립트 코드를 분리할 수 있다.

이렇게 하면 HTML 코드와 자바스크립트 코드를 각각 읽기도 편해지고, 유지 보수도 쉬워진다.

또한, 외부 자바스크립트 파일은 웹 브라우저가 미리 읽어 올 수 있어 웹 페이지의 로딩 속도 또한 빨라지는 장점이 있다.

# 자바스크립트의 기본 타입

타입(data type)이란 프로그램에서 다룰 수 있는 값의 종류를 의미한다.

자바스크립트에서는 여러 가지 형태의 타입을 미리 정의하여 제공하고 있으며, 이것을 기본 타입이라고 정의한다.

자바스크립트의 기본 타입은 크게 `원시 타입`과 `객체 타입`으로 구분할 수 있다.

> 원시 타입

1. 숫자(number)
2. 문자열(string)
3. 불리언(boolean)
4. 심볼(symbol) : ECMAScript 6부터 제공됨
5. undefined

> 객체 타입

6. 객체(object)

EX )

```js
var num = 10; // 숫자
var myName = "홍길동"; // 문자열
var str; // undefined
```

# 숫자(number)

자바스크립트는 다른 언어와는 달리 정수와 실수를 따로 구분하지 않고, 모든 수를 실수 하나로만 표현한다.

또한, 매우 큰 수나 매우 작은 수를 표현할 경우에는 e 표기법을 사용할 수 있다.

EX )

```js
var firstNum = 10; // 소수점을 사용하지 않은 표현
var secondNum = 10.0; // 소수점을 사용한 표현
var thirdNum = 10e6; // 10000000
var fourthNum = 10e-6; // 0.00001
```

# 문자열(string)

자바스크립트에서 문자열은 큰따옴표("")나 작은따옴표('')로 둘러싸인 문자의 집합을 의미한다.

큰따옴표는 작은따옴표로 둘러싸인 문자열에만 포함될 수 있으며, 작은따옴표는 큰따옴표로 둘러싸인 문자열에만 포함될 수 있다.

EX )

```js
var firstStr = "이것도 문자열."; // 큰따옴표를 사용한 문자열
var secondStr = "이것도 문자열."; // 작은따옴표를 사용한 문자열
var thirdStr = "나의 이름은 '김아무개'다."; // 작은따옴표는 큰따옴표로 둘러싸인 문자열에만 포함될 수 있음.
var fourthStr = '나의 이름은 "김가무개"다.'; // 큰따옴표는 작은따옴표로 둘러싸인 문자열에만 포함될 수 있음.
```

자바스크립트에서는 숫자와 문자열을 더할 수도 있다.

이럴 경우에 자바스크립트는 숫자를 문자열로 자동 변환하여, 두 문자열을 연결하는 연산을 수행한다.

EX )

```JS
var num = 10;
var str = "JavaScript";
document.getElementById("result").innerHTML = (num + str); // 10JavaScript
```

[실습링크](http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_datatype_basic_03)

# 불리언(Boolean)

불리언 값은 참(true)과 거짓(false)을 표현한다.

자바스크립트에서 불리언 값은 예약어인 true와 false를 사용하여 나타낼 수 있다.

EX)

```JS
var firstNum = 10;
var secondNum = 11;
document.getElementById("result").innerHTML = (firstNum == secondNum); // false
```

[실습링크](http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_datatype_basic_04)

# 심볼(symbol)

심볼 타입은 ECMAScript 6부터 새롭게 추가된 타입이다.

심볼은 유일하고 변경할 수 없는 타입으로, 객체의 프로퍼티를 위한 식별자로 사용할 수 있다.

EX )

```JS
var sym = Symbol("javascript");  // symbol 타입
var symObj = Object(sym);        // object 타입
```

[실습링크](http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_datatype_basic_05)

- 심볼은 여전히 잘 이해가 안가는 파트. + 심볼 타입은 익스플로러에선 지원하지 않는다.

# typeof 연산자

typeof 연산자는 피연산자의 타입을 반환하는 피연산자가 단 하나뿐인 연산자이다.

EX)

```JS
typeof 10;        // number 타입
typeof "문자열";  // string 타입
typeof true;      // boolean 타입
typeof undefined; // undefined 타입
typeof null;      // object 타입
```

# null과 undefined

자바스크립트에서 null이란 object 타입이며, 아직 '값'이 정해지지 않은 것을 의미한다.

또한, undefined란 null과는 달리 '타입'이 정해지지 않은 것을 의미한다.

따라서 자바스크립트에서 undefined는 초기화되지 않은 변수나 존재하지 않는 값에 접근할 때 반환된다.

EX )

```js
var num; // 초기화하지 않았으므로 undefined 값을 반환함.
var str = null; // object 타입의 null 값
typeof secondNum; // 정의되지 않은 변수에 접근하면 undefined 값을 반환함.
```

null과 undefined는 동등 연산자(==)와 일치 연산자(===)로 비교할 때 그 결괏값이 다르므로 주의해야 한다.

null과 undefined는 타입을 제외하면 같은 의미지만, 타입이 다르므로 일치하지는 않는다.

EX )

```js
null == undefined; // true
null === undefined; // false
```

# 객체(object)

자바스크립트의 기본 타입은 객체(object)이다.

객체(object)란 실생활에서 우리가 인식할 수 있는 사물로 이해할 수 있다.

객체는 여러 프로퍼티(property)나 메소드(method)를 같은 이름으로 묶어놓은 일종의 집합체라고 보면 편하다.

EX )

```js
var dog = { name: "해피", age: 3 }; // 객체의 생성

// 객체의 프로퍼티 참조
document.getElementById("result").innerHTML =
  "강아지의 이름은 " + dog.name + "이고, 나이는 " + dog.age + "살 입니다.";
```

# 타입 변환

자바스크립트는 타입 검사가 매우 유연한 언어이다.

자바스크립트의 변수는 타입이 정해져 있지 않으며, 같은 변수에 다른 타입의 값을 다시 대입할 수도 있다.

EX )

```js
var num = 20; // Number 타입의 20
num = "이십"; // String 타입의 "이십"
var num; // 한 변수에 여러 번 대입할 수는 있지만, 변수의 재선언은 할 수 없다. 재선언문은 무시된다.
```

# 묵시적 타입 변환(implicit type conversion)

자바스크립트는 특정 타입의 값을 기대하는 곳에 다른 타입의 값이 오면, 자동으로 타입을 변환하여 사용한다.

즉, 문자열 값이 오길 기대하는 곳에 숫자가 오더라도 자바스크립트는 알아서 숫자를 문자열로 변환하여 사용한다는 의미이다.

EX )

```js
10 + "문자열"; // 문자열 연결을 위해 숫자 10이 문자열로 변환됨.
"3" * "5"; // 곱셈 연산을 위해 두 문자열이 모두 숫자로 변환됨.
1 - "문자열"; // NaN
```

위의 세 번째 예제에서 뺄셈 연산을 위해 문자열이 숫자로 변환되어야 하나, 해당 문자열은 두 번째 예제의 문자열과는 달리 숫자로 변환될 수 없는 문자열이다.

따라서 의미에 맞게 자동으로 타입을 변환할 수 없으므로, 자바스크립트는 NaN 값을 반환한다.

> NaN이란?

```
NaN은 Not a Number의 축약형으로, 정의되지 않은 값이나 표현할 수 없는 값이라는 의미를 가진다.

이러한 NaN은 Number 타입의 값으로 0을 0으로 나누거나, 숫자로 변환할 수 없는 피연산자로 산술 연산을 시도하는 경우에 반환되는 읽기 전용 값을 의미한다.
```

# 명시적 타입 변환(explicit type conversion)

자바스크립트에서는 묵시적 타입 변환을 많이 사용하지만, 명시적으로 타입을 변환할 방법도 제공한다.

명시적 타입 변환을 위해 자바스크립트가 제공하는 전역 함수는 다음과 같다.

1. Number()
2. String()
3. Boolean()
4. Object()
5. parseInt()
6. parseFloat()

EX )

```js
Number("10"); // 숫자 10
String(true); // 문자열 "true"
Boolean(0); // 불리언 false -> 1은 True
Object(3); // new Number(3)와 동일한 결과로 숫자 3
```

# 숫자를 문자열로 변환

숫자를 문자열로 변환하는 가장 간단한 방법은 String() 함수를 사용하는 것이다.

null과 undefined를 제외한 모든 타입의 값이 가지고 있는 toString() 메소드를 사용할 수도 있다.

숫자(Number) 객체는 숫자를 문자열로 변환하는 다음과 같은 메소드를 별도로 제공한다.

1. toExponential()
2. toFixed()
3. toPrecision()

|     메소드      |                                            설명                                            |
| :-------------: | :----------------------------------------------------------------------------------------: |
| toExponential() | 정수 부분은 1자리, 소수 부분은 입력받은 수만큼 e 표기법을 사용하여 숫자를 문자열로 변환함. |
|    toFixed()    |                소수 부분을 입력받은 수만큼 사용하여 숫자를 문자열로 변환함.                |
|  toPrecision()  |               입력받은 수만큼 유효 자릿수를 사용하여 숫자를 문자열로 변환함.               |

`메소드(method)`란 객체의 프로퍼티 값으로 함수를 갖는 프로퍼티를 의미한다.

지금 해당 개념에 대해가지치기를 하다보면 밑도끝도 없어지니 나중에 자세히 다뤄보자.

# 불리언 값을 문자열로 변환

불리언 값을 문자열로 변환하는 방법에는 String() 함수와 toString() 메소드를 사용하는 방법이 있다.

EX )

```js
String(true); // 문자열 "true"
false.toString(); // 문자열 "false"
```

# 날짜를 문자열이나 숫자로 변환

날짜를 문자열로 변환하는 방법에는 String() 함수와 toString() 메소드를 사용하는 방법이 있다.

자바스크립트에서 날짜(Date) 객체는 문자열과 숫자로 모두 변환할 수 있는 유일한 타입이다.

날짜(Date) 객체는 날짜를 숫자로 변환하는 다음과 같은 메소드를 별도로 제공한다.

1. getDate()
2. getDay()
3. getFullYear()
4. getMonth()
5. getTime()
6. getHours()
7. getMinutes()
8. getSeconds()
9. getMilliseconds()

|      메소드       |                                      설명                                      |
| :---------------: | :----------------------------------------------------------------------------: |
|     getDate()     |                     날짜 중 일자를 숫자로 반환함. (1 ~ 31)                     |
|     getDay()      |            날짜 중 요일을 숫자로 반환함. (일요일 : 0 ~ 토요일 : 6)             |
|   getFullYear()   |                  날짜 중 연도를 4자리 숫자로 반환함. (yyyy년)                  |
|    getMonth()     |               날짜 중 월을 숫자로 반환함. (1월 : 0 ~ 12월 : 11)                |
|     getTime()     | 1970년 1월 1일부터 현재까지의 시간을 밀리초(millisecond) 단위의 숫자로 반환함. |
|    getHours()     |                      시간 중 시를 숫자로 반환함. (0 ~ 23)                      |
|   getMinutes()    |                      시간 중 분을 숫자로 반환함. (0 ~ 59)                      |
|   getSeconds()    |                      시간 중 초를 숫자로 반환함. (0 ~ 59)                      |
| getMilliseconds() |        시간 중 초를 밀리초(millisecond) 단위의 숫자로 반환함. (0 ~ 999)        |

EX )

```js
String(Date()); // Mon May 16 2016 19:35:25 GMT+0900
Date().toString(); // Mon May 16 2016 19:35:25 GMT+0900
var date = new Date(); // Date 객체 생성
date.getFullYear(); // 2016
date.getTime(); // 1463394925632 -> 1970년 1월 1일부터 현재까지의 시간을 밀리초 단위의 숫자로 반환함.
```

# 문자열을 숫자로 변환

문자열을 숫자로 변환하는 가장 간단한 방법은 Number() 함수를 사용하는 것이다.

자바스크립트는 문자열을 숫자로 변환해 주는 두 개의 전역 함수를 별도로 제공한다.

1. parseInt()
2. parseFloat()

|     함수     |                     설명                     |
| :----------: | :------------------------------------------: |
|  parseInt()  | 문자열을 파싱하여 특정 진법의 정수를 반환함. |
| parseFloat() |  문자열을 파싱하여 부동 소수점 수를 반환함.  |

# 불리언 값을 숫자로 변환

불리언 값을 숫자로 변환하는 방법에는 Number() 함수를 사용하는 방법이 있다.

EX )

```js
Number(true); // 숫자 1
Number(false); // 숫자 0
```

# 변수

변수(variable)란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 그 값이 변경될 수 있다.

자바스크립트에서는 var 키워드를 사용하여 변수를 선언한다.

자바스크립트에서는 선언되지 않은 변수를 사용하려고 하거나 접근하려고 하면 오류가 발생한다.

단, 선언되지 않은 변수를 초기화할 경우에는 자동으로 선언을 먼저 한 후 초기화를 진행한다.

## EX )

```js
var month; // month라는 이름의 변수 선언
date = 25; // date라는 이름의 변수를 묵시적으로 선언
```

선언된 변수는 나중에 초기화할 수도 있고, 선언과 동시에 초기화할 수도 있다.

```js
var month; // 변수의 선언
var date = 25; // 변수의 선언과 동시에 초기화
month = 12; // 변수의 초기화
```

쉼표(,) 연산자를 이용하여 여러 변수를 동시에 선언하거나 초기화할 수도 있다.

```js
var month, date; // 여러 변수를 한 번에 선언
var hours = 7,
  minutes = 15; // 여러 변수를 선언과 동시에 초기화
(month = 10), (date = 5); // 여러 변수를 한 번에 초기화
```

# 변수의 타입과 초깃값

자바스크립트의 변수는 타입이 정해져 있지 않으며, 같은 변수에 다른 타입의 값을 다시 대입할 수도 있다.

이렇게 한 변수에 다른 타입의 값을 여러 번 대입할 수는 있지만, 한 번 선언된 변수를 재선언할 수는 없다.

```js
var num = 10; // 변수의 선언과 함께 초기화
num = [10, 20, 30]; // 배열 대입
var num; // 이 재선언문은 무시됨.
```

두 번째 예제인 배열(array)이란 여러 값들로 이루어진 하나의 집합을 의미한다.

그리고 자바스크립트에서 선언만 되고 초기화하지 않은 변수는 undefined 값을 갖는다.

```js
var num; // undefined
num = 10; // 10
```

# 변수의 이름

자바스크립트에서 변수는 이름을 가지고 식별하므로, 변수의 이름은 `식별자(identifier)`이다.

변수의 이름은 영문자(대소문자), 숫자, 언더스코어(\_) 또는 달러($)로만 구성된다.

또한, 숫자와의 구분을 빠르게 하려고 숫자로는 시작할 수 없다.

이러한 변수의 이름은 대소문자를 구분하며, 자바스크립트 언어에서 예약된 키워드는 이름으로 사용할 수 없다.

# 연산자(operator)

자바스크립트는 여러 종류의 연산을 위한 다양한 연산자(operator)를 제공하고 있다.

# 산술 연산자(arithmetic operator)

산술 연산자는 사칙연산을 다루는 가장 기본적이면서도 많이 사용하는 연산자이다.

산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

> 항이란 ?

```
항이란 해당 연산의 실행이 가능하기 위해 필요한 값이나 변수를 의미한다.
따라서 이항 연산자란 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자를 의미한다.
```

| 산술 연산자 |                                    설명                                    |
| :---------: | :------------------------------------------------------------------------: |
|      +      |             왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 더함.              |
|      -      |             왼쪽 피연산자의 값에서 오른쪽 피연산자의 값을 뺌.              |
|     \*      |             왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 곱함.              |
|      /      |            왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눔.             |
|      %      | 왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 나머지를 반환함. |

## EX )

```js
var x = 10,
  y = 4;
document.write(x + y); // 14
document.write(x - y); // 6
document.write(x * y); // 40
document.write(x / y); // 2.5
document.write(x % y); // 2
```

# 연산자의 우선순위(operator precedence)와 결합 방향(associativity)

연산자의 우선순위는 수식 내에 여러 연산자가 함께 등장할 때, 어느 연산자가 먼저 처리될 것인가를 결정한다.

다음 그림은 가장 높은 우선순위를 가지고 있는 괄호(()) 연산자를 사용하여 연산자의 처리 순서를 변경하는 것을 보여준다.

<img src = "http://tcpschool.com/lectures/img_js_precedence.png">

연산자의 결합 방향은 수식 내에 우선순위가 같은 연산자가 둘 이상 있을 때, 먼저 어느 연산을 수행할 것인가를 결정한다.

<img src = "http://tcpschool.com/lectures/img_js_associativity.png">

# 자바스크립트 연산자의 우선순위표

자바스크립트에서 연산자의 우선순위와 결합 방향은 다음과 같다.

| 우선순위 | 연산자 |                     설명                     |      결합 방향      |
| :------: | :----: | :------------------------------------------: | :-----------------: | --- |
|    1     |   ()   |                  묶음(괄호)                  |          -          |
|    2     |   .    |                  멤버 접근                   | 왼쪽에서 오른쪽으로 |
|          |  new   |             인수 있는 객체 생성              |          -          |
|    3     |   ()   |                  함수 호출                   | 왼쪽에서 오른쪽으로 |
|          |  new   |             인수 없는 객체 생성              | 오른쪽에서 왼쪽으로 |
|    4     |   ++   |               후위 증가 연산자               |          -          |
|          |   --   |               후위 감소 연산자               |          -          |
|    5     |   !    |               논리 NOT 연산자                | 오른쪽에서 왼쪽으로 |
|          |   ~    |               비트 NOT 연산자                | 오른쪽에서 왼쪽으로 |
|          |   +    |           양의 부호 (단항 연산자)            | 오른쪽에서 왼쪽으로 |
|          |   -    |           음의 부호 (단항 연산자)            | 오른쪽에서 왼쪽으로 |
|          |   ++   |               전위 증가 연산자               | 오른쪽에서 왼쪽으로 |
|          |   --   |               전위 감소 연산자               | 오른쪽에서 왼쪽으로 |
|          | typeof |                  타입 반환                   | 오른쪽에서 왼쪽으로 |
|          |  void  |                undefined 반환                | 오른쪽에서 왼쪽으로 |     |
|          | delete |               프로퍼티의 제거                | 오른쪽에서 왼쪽으로 |
|    6     |  \*\*  |               거듭제곱 연산자                | 오른쪽에서 왼쪽으로 |
|          |   \*   |                 곱셈 연산자                  | 왼쪽에서 오른쪽으로 |
|          |   /    |                나눗셈 연산자                 | 왼쪽에서 오른쪽으로 |
|          |   %    |                나머지 연산자                 | 왼쪽에서 오른쪽으로 |
|    7     |   +    |          덧셈 연산자 (이항 연산자)           | 왼쪽에서 오른쪽으로 |
|          |   -    |          뺄셈 연산자 (이항 연산자)           | 왼쪽에서 오른쪽으로 |
|    8     |   <<   |           비트 왼쪽 시프트 연산자            | 왼쪽에서 오른쪽으로 |
|          |   >>   |  부호 비트를 확장하면서 비트 오른쪽 시프트   | 왼쪽에서 오른쪽으로 |
|          |  >>>   | 부호 비트를 확장하지 않고 비트 오른쪽 시프트 | 왼쪽에서 오른쪽으로 |

나머진 대충 필요한 경우 나중에 알아보자.
궁금하면 여기 [링크](http://tcpschool.com/javascript/js_operator_arithmetic)를 참고하자.

# 대입 연산자(assignment operator)

대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽이다.

또한, 앞서 살펴본 산술 연산자와 결합한 다양한 복합 대입 연산자가 존재한다.

| 대입 연산자 |                                            설명                                            |
| :---------: | :----------------------------------------------------------------------------------------: |
|      =      |                       왼쪽 피연산자에 오른쪽 피연산자의 값을 대입함.                       |
|     +=      |  왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 더한 후, 그 결괏값을 왼쪽 피연산자에 대입함.  |
|     -=      |  왼쪽 피연산자의 값에서 오른쪽 피연산자의 값을 뺀 후, 그 결괏값을 왼쪽 피연산자에 대입함.  |
|     \*=     |  왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 곱한 후, 그 결괏값을 왼쪽 피연산자에 대입함.  |
|     /=      | 왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 결괏값을 왼쪽 피연산자에 대입함. |
|     %=      | 왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 나머지를 왼쪽 피연산자에 대입함. |

## EX )

```js
var x = 10,
  y = 10,
  z = 10;
x = x - 5;
y -= 5; // y = y - 5 와 같은 표현임.
z = -5; // z = -5 와 같은 표현임.
```

# 증감 연산자(increment and decrement operator)

증감 연산자는 피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자이다.

증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라진다.

| 증감 연산자 |                            설명                             |
| :---------: | :---------------------------------------------------------: |
|     ++x     |  먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.   |
|     x++     | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴. |
|     --x     |  먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.   |
|     x--     | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴. |

```js
var x = 10,
  y = 10;
document.write(++x - 3 + "<br>"); // x의 값을 우선 1 증가시킨 후에 3을 뺌.
document.write(x + "<br>"); // 11
document.write(y++ - 3 + "<br>"); // 먼저 y에서 3을 뺀 후에 y의 값을 1 증가시킴.
document.write(y); // 11
```

# 증감 연산자의 연산 순서

증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라진다.

## EX )

```js
var x = 10;
var y = x-- + 5 + --x;
// 처음에 10 + 5 -> 이후 x에서 1감소(9) 그다음 x에서 1감소(8) 그다음 x값 더함 10+5+8
// x = 8, y = 23
```

# 비교 연산자(comparison operator)

비교 연산자는 피연산자 사이의 상대적인 크기를 판단하여, 참(true)과 거짓(false)을 반환한다.

비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

| 비교 연산자 |                                      설명                                      |
| :---------: | :----------------------------------------------------------------------------: |
|     ==      |           왼쪽 피연산자와 오른쪽 피연산자의 값이 같으면 참을 반환함.           |
|     ===     |    왼쪽 피연산자와 오른쪽 피연산자의 값이 같고, 같은 타입이면 참을 반환함.     |
|     !=      |        왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않으면 참을 반환함.         |
|     !==     | 왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않거나, 타입이 다르면 참을 반환함. |
|      >      |        왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크면 참을 반환함.         |
|     >=      |    왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크거나 같으면 참을 반환함.    |
|      <      |       왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작으면 참을 반환함.        |
|     <=      |    왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작거나 같으면 참을 반환함.    |

자바스크립트에서 비교 연산자는 피연산자의 타입에 따라 두 가지 기준으로 비교를 진행한다.

1. 피연산자가 둘 다 숫자면, 해당 숫자를 서로 비교한다.
2. 피연산자가 둘 다 문자열이면, 문자열의 첫 번째 문자부터 알파벳 순서대로 비교한다.

## EX )

```js
var x = 3,
  y = 5;
var a = "abc",
  b = "bcd";

document.write(x > y); // y의 값이 x의 값보다 크므로 false 출력

document.write(a <= b); // 알파벳 순서상 'a'가 'b'보다 먼저 나오므로 'a'가 'b'보다 작음. true 출력

document.write(x < a); // x의 값은 숫자이고 a의 값은 문자열이므로 비교할 수 없음 false 출력
```

위의 세 번째 연산에서 변수 x의 값은 숫자이고, 변수 a의 값은 문자열이다.

비교 연산자 < 는 x의 값이 a의 값보다 작을 때만 참을 반환하고, 나머지 경우에는 전부 거짓을 반환하는 연산자이다.

따라서 타입이 서로 달라 비교할 수 없는 경우에는 참의 조건을 만족하게 하지 못하므로, 언제나 거짓(false)만을 반환하게 된다.

# 동등 연산자와 일치 연산자

`동등 연산자(==, equal)`와 `일치 연산자(===, strict equal)`는 모두 두 개의 피연산자가 서로 같은지를 비교해 준다.

연산자 모두 피연산자의 타입을 가리지는 않지만, 그 같음을 정의하는 기준이 조금 다르다.

`동등 연산자(==)`는 두 피연산자의 값이 서로 같으면 참(true)을 반환한다.

이때 두 피연산자의 타입이 서로 다르면, 비교를 위해 강제로 타입을 같게 변환한다.

하지만 `일치 연산자(===)`는 타입의 변환 없이 두 피연산자의 값이 같고, 타입도 같아야만 참(true)을 반환한다.

## EX )

```js
var x = 3,
  y = "3",
  z = 3;

document.write(x == y); // x와 y의 타입이 서로 다르므로 타입을 서로 같게 한 후 비교를 하므로 true 출력

document.write(x === y); // x와 y의 타입이 서로 다르므로 false 출력

document.write(x === z); // x와 z은 값과 타입이 모두 같으므로 true 출력
```

> `부등 연산자(!=)`와 `불일치 연산자(!==)`는 각각 동등 연산자와 일치 연산자의 비교와 정확히 반대로 동작한다.

# 논리 연산자(logical operator)

논리 연산자는 주어진 논리식을 판단하여, 참(true)과 거짓(false)을 반환한다.

`&& 연산자`와 `|| 연산자`는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 `왼쪽에서 오른쪽`이다.

`! 연산자`는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 `오른쪽에서 왼쪽`이다.

| 논리 연산자 |                                 설명                                 |
| :---------: | :------------------------------------------------------------------: | --- | --------------------------------------------------------- |
|     &&      |          논리식이 모두 참이면 참을 반환함. (논리 AND 연산)           |
|             |                                                                      |     | 논리식 중에서 하나라도 참이면 참을 반환함. (논리 OR 연산) |
|      !      | 논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (논리 NOT 연산) |

논리 연산자의 모든 동작의 진리표는 기본적인 부울대수 논리법과 동일하다.

## EX )

```JS
var x = 3, y = '3', z = 3;

console.log(x == y);  // x와 y의 타입이 서로 다르므로 타입을 서로 같게 한 후 비교를 하므로 true
console.log(x === y); // x와 y의 타입이 서로 다르므로 false
console.log(x === z);            // x와 z은 값과 타입이 모두 같으므로 true
```

> 기억할만한 포인트

```js
`부등 연산자(!=)`와 `불일치 연산자(!==)`는 각각 동등 연산자와 일치 연산자의 비교와 정확히 반대로 동작한다.
```

# 비트 연산자(bitwise operator)

비트 연산자는 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 수행한다.

또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용한다.

| 비트 연산자 |                                        설명                                         |
| :---------: | :---------------------------------------------------------------------------------: |
|      &      |               대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)                |
|      l      |           대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)            |
|      ^      |               대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)               |
|      ~      |               비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산)               |
|     <<      |           지정한 수만큼 비트를 전부 왼쪽으로 이동시킴. (left shift 연산)            |
|     >>      | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |
|     >>>     |     지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨.     |

> 비트 AND 연산자 (&)

다음 그림은 비트 AND 연산자(&)의 동작을 나타낸다.

이처럼 비트 AND 연산자는 대응되는 두 비트가 모두 1일 때만 1을 반환하며, 다른 경우는 모두 0을 반환한다.

<img src = http://tcpschool.com/lectures/img_php_bitwise_and.png>

> 비트 OR 연산자 (|)

다음 그림은 비트 OR 연산자(|)의 동작을 나타낸다.

비트 OR 연산자는 대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 두 비트가 모두 0일 때만 0을 반환한다.
<img src = http://tcpschool.com/lectures/img_php_bitwise_or.png>

> 비트 XOR 연산자(^)

다음 그림은 비트 XOR 연산자(^)의 동작을 나타낸다.
비트 XOR 연산자는 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환한다.

<img src=http://tcpschool.com/lectures/img_php_bitwise_xor.png>

> 비트 NOT 연산자(~)

다음 그림은 비트 NOT 연산자(~)의 동작을 나타낸다.

## EX )

다음 예제는 시프트 연산자(<<, >>)와 비트 NOT 연산자(~)의 예제이다.

```js
var x = 15,
  y = 8,
  z = 15;

console.log(x << 1); // 곱하기 2와 같으므로 15 * 2 = 30

console.log(y >> 1); // 나누기 2와 같으므로 8 / 2 = 4

console.log(~z); // 1의 보수와 같으므로 -(15+1) = -16
```

예제에서 첫 번째 연산은 비트를 전부 왼쪽으로 1비트씩 이동시키는 연산이다.

2진수에서 전부다 한칸씩 왼쪽으로 옮긴다는 의미는 기존 값에 2를 곱한 것과 같다.

반대로 두 번째 연산은 비트를 전부 오른쪽으로 1비트씩 이동시는 연산이다.

반대로 오른쪽으로 옮기는건 값을 2로 나누는것과 같게 된다.

# 기타 연산자

## 문자열 결합 연산자

자바스크립트에서 `덧셈(+) 연산자`는 피연산자의 타입에 따라 두 가지 다른 연산을 수행한다.

1. 피연산자가 둘 다 숫자이면, 산술 연산인 덧셈을 수행한다.

2. 피연산자가 하나라도 문자열이면, 문자열 결합을 수행한다.

### EX )

```js
var x = 3 + 4; // 피연산자가 둘 다 숫자이면 덧셈 연산을 수행함.

var y = "좋은 " + "하루 되세요!"; // 피연산자가 둘 다 문자열이면 문자열 결합 연산을 수행함.

var z = 12 + "월"; // 피연산자가 하나라도 문자열이면 문자열 결합 연산을 수행함.
```

> 기억해야할 포인트

```
앞에서 배웠듯이 피연산자가 하나는 문자열이고 다른 하나는 문자열이 아닐 때, 자바스크립트는 문자열이 아닌 피연산자를 자동으로 문자열로 변환한 후 문자열 결합을 수행한다.
```

# 삼항 연산자(ternary operator)

삼항 연산자는 유일하게 피연산자를 세 개나 가지는 조건 연산자이다.

> 문법

```js
표현식 ? 반환값1 : 반환값2;
```

물음표(?) 앞의 표현식에 따라 결괏값이 참이면 반환값1을 반환하고, 결괏값이 거짓이면 반환값2를 반환한다.

## EX )

```js
var x = 3,
  y = 5;

var result = x > y ? x : y; // x가 더 크면 x를, 그렇지 않으면 y를 반환함.
console.log("둘 중에 더 큰 수는 " + result + "입니다.");
```

삼항 연산자는 짧은 if / else 문 대신 사용할 수 있으며, 코드를 간결하게 만들어 준다.

# 쉼표 연산자

쉼표 연산자를 for 문에서 사용하면, 루프마다 여러 변수를 동시에 갱신할 수 있다.

## EX )

```js
// 루프마다 i의 값은 1씩 증가하고, 동시에 j의 값은 1씩 감소함.

for (var i = 0, j = 9; i <= j; i++, j--) {
  console.log("i의 값은 " + i + "이고, j의 값은 " + j + "이다.");
}
```

# delete 연산자

delete 연산자는 피연산자인 객체, 객체의 프로퍼티(property) 또는 배열의 요소(element) 등을 삭제해준다.

피연산자가 성공적으로 삭제되었을 경우에는 참(true)을 반환하고, 삭제하지 못했을 경우에는 거짓(false)을 반환한다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 `오른쪽에서 왼쪽`이다.

## EX )

```js
var arr = [1, 2, 3]; // 배열 생성

delete arr[2]; // 배열의 원소 중 인덱스가 2인 요소를 삭제함.

console.log(arr); // [1, 2, ]
// 배열에 빈자리가 생긴 것으로 undefined 값으로 직접 설정된 것은 아님.

console.log(arr[2]);
// 배열의 요소를 삭제하는 것이지 배열의 길이까지 줄이는 것은 아님.

console.log(arr.length);
```

# typeof 연산자

typeof 연산자는 피연산자의 타입을 반환한다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 `오른쪽에서 왼쪽`이다.

자바스크립트에서 많이 사용하는 값과 그 값에 대한 typeof 연산자의 결괏값은 다음과 같다.

|        값        | typeof 연산자의 결괏값 |
| :--------------: | :--------------------: |
|    숫자, NaN     |        "number"        |
|      문자열      |        "string"        |
|   true, false    |       "boolean"        |
|       null       |        "object"        |
|    undefined     |      "undefined"       |
|       함수       |       "function"       |
| 함수가 아닌 객체 |        "object"        |

## EX )

```js
typeof "문자열"; // string
typeof 10; // number
typeof NaN; // number
typeof false; // boolean
typeof undefined; // undefined
typeof new Date(); // object
typeof null; // object
```

# instanceof 연산자

instanceof 연산자는 피연산자인 객체가 특정 객체의 인스턴스인지 아닌지를 확인해 준다.

피연산자가 특정 객체의 인스턴스이면 참(true)을 반환하고, 특정 객체의 인스턴스가 아니면 거짓(false)을 반한다.

이 연산자는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

## EX )

```js
var str = new String("이것은 문자열입니다.");

str instanceof Object; // true
str instanceof String; // true
str instanceof Array; // false
str instanceof Number; // false
str instanceof Boolean; // false
```

인스턴스와 객체에 대한 추가적인 내용은 추후 객체를 다룰 때 알아보도록 하자.

# void 연산자

void 연산자는 피연산자로 어떤 타입의 값이 오던 상관없이 언제나 `undfined 값`만을 반환한다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽이다.

## EX )

<a href="javascript:void(0)">이 링크는 동작하지 않습니다.</a>

```js
<a href="javascript:void(0)">이 링크는 동작하지 않습니다.</a>
```

---

[실습링크](http://tcpschool.com/examples/tryit/tryhtml.php?filename=js_operator_etc_07)

위의 예제처럼 void 연산자는 정의되지 않은 원시 타입의 값을 얻기 위해 void(0)과 같은 형태로 종종 사용
