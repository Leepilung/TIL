# 코드스피츠73 - ES6+

# 서론

코드의 복잡성이 현업자와 공부하는 학생의 차이. 복잡성을 관리할 수 있는가 아닌가를 목표로 해야함.

> 프로그램이란 무엇인가?

어디서부터 프로그램일까?

컴퓨터 메모리에 적재된 이후에 실행되기 직전 상태부터 프로그램이라고 부른다.

예를 들어 엑셀.exe를 클릭해서 실행될 수 있게 메모리에 적재되있는 상태를 의미한다.

---

> 컴파일 언어

C나 C++ 자바 같은 컴파일 언어는 다음과 같은 과정을 가진다.

1. LANGUAGE CODE - LINT TIME
2. MACHINE LANGUAGE - COMPILE TIME
3. FILE
4. LOAD
5. RUN - RUN TIME
6. TERMINATE

이런 컴파일 언어의 흐름을 보면 우리는 우선 `LANGUAGE CODE`를 짜게된다.

사람에게 보다 친절하고 익숙한 언어를 짠 후 기계적 언어인 `MACHINE LAGNUGAE` 단계로 넘어간다. 사람의 언어 -> 기계의 언어로 변환하는 과정을 `컴파일` 이라고 한다.

이러한 프로그래밍 과정에서 도움을 받는 여러가지 방법이 있다.

`lANGUAGE CODE`를 짤때 나오는 텍스트만 보아도 문제가 있음을 알려주는 것을 `LINTING` or `LINT TIME`이라 부르고 이것을 지원하는 여러가지 툴이 있다.(아마 ESLINT등)

`MACHINE LANGUAGE`단에서 일어나는 `COMPILE ERROR`나 `RUN` 부분에서 일어나는 `RUN TIME ERROR`등 다양한 에러 단계가 있다.

위의 모든 에러 단계에 해당하지 않는 에러를 `컨텍스트 에러`라고 부른다.

실행 자체는 정상적으로 되지만 에러는 검출이 되지 않는다. 그렇기 때문에 `CONTEXT` 즉 사고 자체가 잘못된 에러라고 하여 컨텍스트 에러라고 부른다.

> 런타임 언어

JavaScript가 대표적이며 다음과 같은 과정을 가진다.

1. LANGUAGE CODE - LINT TIME
2. FILE
3. LOAD
4. MACHINE LANGUAGE
5. RUN - RUNTIME
6. TERMINATE

절차는 처음에는 컴파일 언어와 똑같다. 그다음 js파일로 저장되고 브라우저가 이를 로드한다.

브라우저가 로드했을때 js파일은 여전히 LANGUAGE CODE로 되어있는데 자기 스스로 기계적 언어인 MACHINE LANGUAGE로 알아서 변환한다.

이 과정에서 런타임 언어가 자동으로 수행하는 컴파일과 C언어와 같은 컴파일 언어의 컴파일은 큰 차이가 존재한다.

> `런타임 언어`와 `컴파일 언어`의 컴파일 차이

`컴파일 언어`는 COMPILE TIME에 우리가 작성한 모든 LANGUAGE CODE를 하나도 빠짐없이 해석하여 컴파일한다. 왜냐하면 LAGUAGE CODE와 MACHINE LANGUAGE의 전체 결과를 하나의 FILE로 만드려고 하기 때문이다.

그러나 `런타임 언어`는 JS파일을 100개 200개 만들어도 내가 지금 바라보고 있는 파일만을 컴파일한다.
전부 검사하지 않는다. 그러나 하나의 파일에서도 부분 부분만 MACHINE CODE로 바꿔놓고 나머진 해석을 하지 않는다. 그래서 부분부분 잘못된 코드가 있어도 그 코드가 호출되기 전까지 정상동작한다.

대부분의 RUN TIME 에러는 잡을 수 없다. 그래서 이부분을 보완하기 위한 수단들이 필요하다.

그래서 이를 해결하기 위해 컴파일 스타일로 강제하는 플랫폼들이 존재한다.(EX : Typescript)

또는 레이어별로 런타임을 격리시켜 나누는 방식이 있다(ex 격리(isolate)를 활용)

> 격리

격리하는 법을 인식하고 코드를 격리시키면서 짜는것이 굉장히 중요하다.

본인이 코드 하나를 짜더라도 어떤 의미와 어떤 역할을 갖고 어디까지 격리시킬 수 있는지를 인식하는 방향으로 공부하는 것이 중요하다.

# 자바스크립트의 구성요소

자바스크립트 엔진은 텍스트를 만나면 아래와 같은 방식으로 보게된다.

> WHITE SPACE 공백문자

공백을 나타내는 문자가 상당히 많다. 그렇기 때문에 자바스크립트에서 이를 미리 정의해두었다.

> LINE TERMINATORS 개행문자

> COMMENTS 개행문자

주석이 해당된다.

> KEYWORD 키워드

미리 약속되어 있어서 엔진이 이를 만나면 특정 행동을 수행하는 언어를 말 함.

> LITERALS 리터럴

리터럴이란 언어에서 정의한 더 이상 쪼갤 수 없는 값을 의미한다.

예를 들어 자바스크립트에서 37을 표현하려면 3, 7을 나누어서 표현해야한다. 그러나 여기서 3,7에서 더 쪼개어서 37을 표현할 수 없다. 그렇기 때문에 이를 숫자 리터럴이라고 부른다.

다음 예로는 부울린값 true를 들면, t,r,u,e라는 각각의 알파벳으로 쪼개어서 표현한다. 이러한 것들을 리터럴이라고 부른다

객체 리터럴, 함수 리터럴 등등 수 많은 리터럴을 포함한다.

> 공부할 때의 마음가짐

자만심을 버려야한다. 당연히 안다고 생각하고 넘어가는것 금지.

# 자바스크립트의 요소

자바스크립트는 크게 3가지 요소로 나뉜다.

1. STATEMENTS 문

   공문,식문,제어문

2. EXPRESSION 식

   값식, 연산식, 호출식

3. IDENTIFIER 식별자

   기본형, 참조형

식이란 하나의 값에 수용되는 것을 의미한다. 1 + 5 는 덧셈연산 식이데 6으로 수용된다. 즉 식은 값의 확장된 표현이라고 볼 수 있다.

하나의 값은 식이 될 수 있다.(ex: a, b, c ,1 ,2 ,3) 때문에 `값식(value expreesion)`이라고 부른다.

다음은 연산자를 이용한 식이 있다. 1 + 3은 산술 연산자를 사용한 연산식이라고 볼 수 있다. 이러한 연산자가 등장한 경우 `연산식`이라고 부른다.

다음은 함수를 호출하는 것또한 호출식이라고 볼 수 있다.

값식, 연산식, 호출식은 서로 사용할 수 있는 관계를 가지고 있고, 이들의 조합은 언제나 `하나의 값`으로 떨어진다.

그러나 `값`은 우리가 메모리에 저장시키지 않으면 휘발된다.

> 변수란?

1. 메모리 주소의 별명이다.
2. 자바스크립트에는 형(形)이 존재한다. 해당 값(데이터)에 대한 타입(type) 정보를 가지고 있다.

3을 a에 저장했다고 생각해보자

```js
let a = 3;
```

3이란 값은 a에 저장되어있다기 보단 컴퓨터 메모리 어딘가에 저장되어 있다. 우리는 그 복잡한 메모리 주소에 a라는 alias를 붙인 것이다.

그렇기 때문에 a는 그 메모리 주소를 찾아가 3이라는 값을 꺼내오는 것이다.

또한

```js
typeof a;
("number");
```

할 경우 변수는 메모리의 주소일 뿐만 아니라 해당 값에 대한 타입 정보또한 가지고 있다.

이러한 타입 정보를 데이터 타입(자료형)라고도 부른다.

메모리 주소 + 데이터 형을 포함시킨 두가지 의미를 담는 특별한 이름을 지정하는 행위를 `식별자(identifier)`라고 부른다.

식별자는 안에 담는 형태가 2가지가 올 수 있다.

첫번째는 a = 3 과 같은 값이 들어올 수 있다.

두번째는 참조가 들어온다. 참조란 다른 메모리의 주소가 들어오는 것을 의미한다.

그렇기 때문에 변수에 들어가는 것은 크게보면 값과 참조가 들어간다고 볼 수 있다.

그리고 값을 사용할땐 모든 값은 복사가 일어난다.

```js
a;
3;
let b = a; // 이 경우 a라는 메모리 주소를 옮겨준건지 3이라는 값을 옮겨준건지 알아볼 필요가 있다.

b;
3; // 이 경우에는 3이라는 값을 복사시켜줬다고 봐야한다.

a = 7; // 주소를 옮겨준 경우
7;
b; // b가 7이나와야 하지만 3이나왔다. 한마디로 메모리 블록을 2개 쓰는 복사라고 봐야한다.
3;
```

다음은 참조하는 경우이다.

```js
a = [1, 2, 3](3)[(1, 2, 3)];
b = a(3)[(1, 2, 3)];
a[0];
1;
a[0] = 7;
7;
b(3)[(7, 2, 3)];
```

이렇듯 변수에는 참조가 되는 것과 복사가 되는 것 2가지가 있다고 보면 된다.

    * 취업, 공부 이야기
    복잡성을 극복한 사람이라면 개발자로서 사회적 강자의 위치할 수 있다.

    체계적인 공부 하는 양을 전부다 기억해야 한다(그것도 매우 정확하게)

    범위적 공부가 아닌 공학 공부처럼 기초를 기반으로 층을 쌓는 방식으로 공부해야함. -> 결국 기존 전기 공부했던 방식과 동일함. 기초부터 튼튼히

    특히 CS가 더 나은점은 공리가 존재하지 않음. 기존 학문은 공리가 무너지면 근본이 무너지지만 cs는 그런 공리가 없다. 놀라운 부분인듯.

    또한 공부할때 개념을 공부함에 있어서 가급적 영어로 하는것이 좋음.(번역은 일관성이 떨어짐. 산술연산자 같은건 제외)

자바스크립트에서 `기본형(Primitive type)`을 제외한 나머지는 `전부 참조형(Reference Type)`이다. 기억하자.

> 변수

변수는 또 상수와 변수로 나뉜다.

변해야할 이유가 있을때에만 변수로

나머진 불변성(emueterbla)한 상수로 사용하는 것이 좋다.

if, return과 같은 STATEMENTS(문)은 값으로 활용되지 않는 자바스크립트 엔진이 해석하게 하기위한 힌트나 명령이라고 보면 된다. 그러나 다만 다소 절대적인 면이 있어서 힌트라고만 보기는 힘듦.

문에는 4가지 종류가 있다.

1. 공문(아무것도 없다.)

   근대 실사용되진 않음.

2. 식문(하나의 식은 하나의 문이 된다)

   ex) 3 + 5; // 3; 2; 5; 둘다 허용 (JAVA는 Context 에러뜸)

3. 제어문

4. 선언문

5. 단문(문장한개)
6. 중문({} 블록이라고 부름)

## SYNC FLOW

과정은 좌에서 우로 위에서 아래로 진행된다.

컴퓨터는 메모리에 적재되있는걸 우리의 관여와 무관하게 실행해버리는 노이만 머신의 특성을 갖고 있다.

이를 해결하기 위한 방법이 비동기성 방법이고 여러가지가 있다.

그러나 할당(Assignment)만이 우에서 좌로 진행됨. (수학때문임)

---

다음과 같은식은 좋지 못한식이다.

```js
3 + 5 / 2;
5.5;
```

수학의 사칙연산을 기반으로 하기 때문에 코딩에 집중하여 보자면 비 프로그래밍적이고 비 코딩적인 관점이다.

```js
plus(3, div(5, 2));
5.5;
```

다음과 같이 아무런 사전지식(사칙연산 과 같은)이 필요하지 않는 형식으로 짜는것이 좋다. 또한 연산자가 개입되는건 무조건적으로 괄호를 치는것이 좋다.

## SYNC FLOW CONTROL

SUB FLOW는 CLASS나 다른 함수들로 관리함.

ES6는 FLOW 중간에 중단시켰다가 다시 시작할 수 있음

FLOW가 한세트 진행되는걸 `루틴`이라고 부른다.

SUB FLOW는 여러번 진행될 수 있고 SUB FLOW의 루틴을 `서브루틴`이라고 부른다.

유사한 기능을 하는 구문이 여러가지 있는 이유는 인간의 복잡한 사고를 표현하기 위함임.

제어문을 어떻게 쓰고 어떤 문을 이용해서 우리가 알고있는 것을 표현하느냐가 중요함.

공백문자의 특징은 공백이 아무리 많아도 하나의 공백으로 취급함 (IF (조건식) 조건식과 IF 사이의 공백을 의미)

우선순위 연산자 ( `( )` 괄호를 의미)

# FLOW , 흐름 제어

> 번외

```
if, for와 같은 기본적인 흐름 제어문 만을 사용해서 기본적인 플로우를 잘 제어하는 것만으로도 좋은 프로그래머가 될 수 있다.
```

자바스크립트에서는

LABEL, BREAK, CONTINUE

와 같은 가장 기본적인 FLOW 제어 수단을 제공한다.

좌에서 우, 상에서 하로 흐르는 일방향적인 흐름을 특정위치로 점프시킬 수 있는 문법이 있다.

그 중 가장 고전적인 방법이 GOTO이다. 특정 위치로 점프시키는 것인데 예전에는 라인넘버로 점프시켰다.

그러나 요새 현대 코드에서는 코드의 길이가 매우 길어지기 때문에 줄 수는 그렇게 중요하지 않기 때문에 생긴 것이 바로 `LABEL`이다.

자바스크립트에서 LABEL은 변수의 식별자 규칙과 매우 유사한(조금은 다른) LABEL 식별자라는 규칙을 갖고있다.

이러한 식별자뒤에 콜론만 붙이면 코드의 어떠한 위치라도 전부 LABEL이 된다.

LABEL IDENTIFIER: <- 이형태처럼 만들면 LABEL이 만들어진다.

BREAK문은 현재 LABEL문에서 탈출하는데 사용된다. BREAK LABEL;과 같이 쓰면된다.

CONTINUE 또한 LABEL에서 탈출하는데 사용된다. CONTINUE LABEL;과 같이 쓰면 된다.

> 예제

```html
html파일 기본구조

<div id="log"></div>
```

```js
index.js 파일 구조
// javascript
const con = document.getElementbyId('log');
const log = (...args) => con.innerHTML += '<br" + agrs.join(' ');

log('a', 1, 'con');

ABC; -> LABEL임.

```

LABEL은 코드 아무대나 삽입할 수 있다. 그렇다면 LABEL은 어떻게 작동할까?

또한 LABEL은 동일한 이름으로 여러개를 만들 수 없다.

```js
ABC;
[
	ABC;
}
```

이러한 구문은 에러가 발생한다.

```js
ABC;
() => [
	ABC;
}
```

이렇게 하는 경우에는 에러가 발생하지 않는다. 왜냐하면 LABEL은 함수스코프이기 때문이다.

LABEL이 가르킬수 있는것을 LABEL RANGE라고 부른다.

```js
ABC
for (const i of [1,2,3,4]) {
    if (i === 3} break ABC;
    console.log(i)
}
```

이렇게하면 1,2만 출력되고 3일때는 점프시키면서 끝난다.
위의 구문과 아래구문은 차이가 없다. 여기서 ABC를 지워도 동일하게 동작한다.

```js

for (const i of [1,2,3,4]) {
    if (i === 3} break;
    console.log(i)
}
```

이건 `ITERATION SET`이라는 작동에 의해 구문안에서 자동으로 LABEL을 생성한 것이다.

`IDENTIFIER`에 `LABEL`이름이 없으면 자동 `LABEL`이 있는 경우애만 작동한다.

자동 LABEL은 언제 작동하느냐 -> `ITERATION SET`이라는 경우에 작동하는 것과 `LABEL SET`이라는 경우에 작동하는 것이 있다.

그리고 `ITERATION SET`에서는 `BREAK`와 `CONTINUE`를 사용해야한다고 배웠기 때문에 FOR문 안에서 LABEL 이름이 없는데 점프하는 것은 익숙하다.

특히 CONTINUE 문은 원래 이터레이션 셋에서밖에 작동하지 않는다.

EX )

```js
for (const i of [1,2,3,4,]) {
	if (i === 3) break;
	log(i);
}

abc: {
	log('a');
	break;
	loa('b');
}
log('c');
```

이 경우를 실행해보면 에러가뜬다. 왜냐하면 abc 구문에서 abc 자체가 이터레이션 셋이 아니기 때문이다.

그렇기 때문이 이를 해결하려면

```js
for (const i of [1, 2, 3, 4]) {
  if (i === 3) break;
  log(i);
}

abc: {
  log("a");
  break abc; // 이 부분
  loa("b");
}
log("c");
```

break문에 LABEL명을 기입해주는 것으로 해결되고 정상작동하게 된다.

현재 문법들은 아래로만 점프할 수 있다.(초창기에는 위아래로만 진행했는데 무한루프 위험성이 너무 높음)

우리가 함수를 호출하면 함수 몸통의 가장 위부터 실행된다. 어떠한 호출행위나 서브루틴에 빠지게 되더라도 그 서브루틴의 처음으로 보낸다.

그러나 `break` 즉 `label 점프`만이 아래로 보내는 유일한 예외이다.

요약하면 label 블록에서는 `continue`를 쓸 수 없다. `conitnue`를 사용하고 싶은 경우는 이터레이션 셋에서만 사용해야 한다.

break나 continue에서 break 문에 identifier를 생략하면 auto identifier가 생성되는데 이또한 이터레이션 셋에서만 일어난다.

---

스크립트 엔진은 파싱된 결과물을 가지고 실행함. 이 과정에서 대부분의 `문(STATESMENT)`들은 레코드로 바뀐다.

label , break, continue 같이 흐름제어에 관여하는 구문을 `컴플리션 레코드`라고 부른다.

# 함수 스코프

`LABEL 스코프`는 함수 스코프이다. 함수스코프 안에는 중첩된 이름 사용 불가.

같은 이름의 LABEL을 사용하려면 함수로 분기하여서 사용해야한다.

# 스코프

변수의 2가지 요소에 더불어서 중요한 요소가 있다. -> 변수는 영원히 존재하지않고 특정시점에서 사라짐. `라이프 싸이클` 이라고 부름.

접근 제어 -> 어떤 변수에는 누가 접근하고 안되고 하는 격벽을 세워 메모리를 보호하는 기능을 `스코프`라고 부른다.

우리가 일반적으로 함수를 만들면 스코프와 라이프 싸이클을 갖게된다.

자바스크립트에서는 `라이프싸이클`을 `스코프`라고 표현한다. 변수의 스코프에 따라 누가 접근할 수 있는지, 수명까지도 결정된다.

우리가 생각할 수 있는 변수에는 함수의 인자, 함수안에서 사용되는 지역 변수등이 있다. 36 110 0 0000 5389 5

## 자유변수

`자유 변수`란? -> 고유 명사. 함수나 인스턴스나 자기를 기준으로 자기가 원래 알 수있는 변수가 아닌 변수들을 전부 자유 변수라고 부른다.

    예를 들어 함수 개념에서 함수가 알 수있는 변수는 `지역변수`와 `인자`뿐이다. 이 둘을 뺴고는 `전부 자유변수`라고 생각하면 된다.

이러한 자유변수들이 사용될 수 있는 공간(블록)을 `클로저` 라고 부른다.

함수에서 함수를 감싸고있는 외부변수나 전역변수들은 함수 안에서 사용할 수 있다. 이 때 이 자유변수들의 `클로저`는 함수가 된다.

> EX)

```js
let a = 3;
const f = () => {
  log(a); // 이 a를 함수 const f에 대한 자유변수라고 부른다.
};
```

자바스크립트의 `스코프`라고 이해하는것도 좋지만 이러한 자유변수와 클로저를 이해하면 다른 모든 언어에서도 적용할 수 있다.

> EX 2)

```js
let a = 3;
const f = () => {
  let a = 5;
  log(a); // 이 경우 5가 출력됨.
};
```

이유는 자유변수의 우선순위가 낮기때문.

자유변수는 더 가까운쪽의 값을 우선적으로 채용함. 또한 자유변수가 더 많은 블록 스코프를 가질수록 우선순위가 낮아짐.

이렇게 이름이 같을때 바깥에 있는 자유변수가 안보이게 되는데 이 현상이 `쉐도잉`이다. 그런대 이 쉐도잉 효과가 똑같이 LABEL에서도 일어난다.

> EX3 )

```js
k : {
	let a = 3;
	const f = () => {
		let a = 5;
		k: {
			break;
			log(37);	// 이렇게하면 37이 실행되지 않음.
		}
		log(a); // 이 경우 5가 출력됨.
}
	f();
}
```

함수 바깥쪽으로는 점프가 불가능하다.

그렇다고 바깥에 전체를 감싼 k를 k1으로 바꾸고 const f 내부의 k의 break를 break k1으로 바꿔도 에러가 발생한다.

왜냐하면 스코프 내에서 k1을 인식하지 못하기 때문이다.

LABEL에 대한 파싱은 정적으로 한다. 때문에 에러사항이 있으면 Syntax Error가 발생하여 초기에 에러를 잡아버려 안정적이다.(RUNTIME ERROR가 아니라 검출이 조기에 되어 수정이 쉬움)

현대 언어들은 이러한 함수 스코프에 나와있는 LABEL을 블록 격벽 밖으로 못넘어가게 하는 역할을 하고 이것을 `LABEL SCOPE`라고 부른다.

ITERRATION SET 기준으로 익명이 존재한다. 있어도 되고 없어도 된다. 그러나 CONTINUE의 익명은 흉내낼 수 없다.

BREAK의 익명은 ITERATION SET 위에있는 LABEL이 그 다음번에 나오는 블록 바깥으로 탈출시키기 떄문에 똑같은데

CONITNUE의 익명은 블록내부의 시작으로 이동하기 때문에 흉내낼 수 없다.

# SWITCH

> EX )

```js
// javascript
const con = document.getElementbyId('log');
const log = (...args) => con.innerHTML += '<br" + agrs.join(' ');

switch (3) {
	case 3: break;
}
```

switch문 안의 중괄호는 중문이 아니다. 이 형식 자체가 위와 같은 형태이다. 여기서 중괄호는 중문의 중괄호가 아닌 switch의 특수 LABEL 블록을 의미한다.

> EX )

```js
switch (3) {
  case 3:
    a: {
    } // 이와 같이 case안에 LABEL을 다시만드는 형태도 허용된다.
  case 4:
    break;
  case 5:
  case 6:
  default:
}
```

switch 구문은 자바스크립트에서 동작하는 것과 다른언어에서 동작하는 것이 매우 다르다. 자바스크립트는 위에서 아래로 계산한다.

또한 switch 구문은 조건이 한정적이고 값이 다양한 경우 조건이 기술되고 값이 내려오는 방식으로 사용한다.

> EX ) 조건이 한정적, 값이 다양한 경우

```js

let a = 3, b = 0;
switch (a) {
	case b++ : log('a', b); break;
	case b++ : log('b', b); break;
	case b++ : log('c', b); break;
	case b++ : log('d', b); break;
	default;
}
```

반대의 경우인 값이 한정적이고 조건이 다양한 경우

> EX ) 조건이 다양, 값이 한정적인 경우

```js
let a = 3,
  b = 0;
switch (true) {
  case a > 5:
    log("a", a);
    break;
  case a > 4:
    log("a", a);
    break;
  case a > 3:
    log("a", a);
    break;
  case a > 2:
    log("a", a);
    break;
    defualt;
}
```

일반적으로 switch문의 조건이 case로 떨어져 나올경우 순서관계가 생긴다. 왜냐하면 위에서 아래로 실행되기 때문이다.

때문에 조건이 큰경우부터 위에서 서술해야 한다.

또한 switch문의 조건이 case로 떨어져 나온 경우 독립적인 조건을 나열할땐 괜찮지만

이렇게 연관된 조건을 나열하게 되는 경우라면 에러에 빠지기 쉬워 진리표를 만들지 않는한 사용하지 않는것이 좋다.

> 요약

continue, break -> 반드시 블록안에서만 쓰일 수 있고, 쓰이는 경우는 3가지. -> iteration set, label set, switch set 안에 있을때만 사용한다.

switch 문의 중괄호는 블록이 아니다. switch label section이라고 부르는 녀석이다.

만약 laebl set을 사용하지 않고 단문에 사용한다면 주석으로는 사용이 가능하다.

# IF문

> EX )

```js
a : const c = 3;
```

## 구조

```js
if (식) 옵셔널 // 생략 가능

if (식)
else () 멘데토리 // 필수
```

영단어 뜻 그대로 두 가지로 나뉜다.

> EX )

```js
if (c === 1) {
} else {
  if (c === 2) {
    // 제어문은 그 하나가 단문이다. 이런식으로 else 뒤에 if문의 중괄호 범위로 하나의 if 조건문이 들온 것이라고 봐도 된다.
  } else {
    if (c === 3) {
    } else {
    }
  }
}
```

else if를 else 다음에 if문이 오는 구조로 봐야한다. 추가로 여기서 주의할 점은 else가 후방결합을 한다는 점을 기억해야한다.

> EX )

```js
if (c === 1) {

} else {if (c === 2) { // 제어문은 그 하나가 단문이다. 이런식으로 else 뒤에 if문의 중괄호 범위로 하나의 if 조건문이 들온 것이라고 봐도 된다.

} else {if (c === 3) {

} else {

}
```

else if문의 구조는 esle의 구조와 후방결합을 완전히 이해하지 못한다면 무조건적으로 버그가 일어난다.

때문에 이런 구조는 esle뒤의 if문을 중괄호로 묶어버리면 된다. 앞으로 else if문은 없다고 생각하면 된다.(뒤에 오는 if문을 중괄호로 다 묶어버리면 됨)

else if 자체는 해석 자체가 어려운 구문이고 어려움을 유발하는 구조이다.

만약 내가 평가해야하는 식이 동등한 조건으로 나열된다 -> switch문 사용

하지만 내가 평가해야하는 식이 특정한 경우에 속해있어서 비교해야한다 -> else if문 사용.

if 중첩은 서브 중첩일때만 사용한다.

만약 if else문이 사용된다고하면 else문까지 무조건 `멘데토리`로 사용해야한다. `옵셔널`로 해버리면 경우의수를 나눠서 동작하는지 안하는지까지 체크해야함.

> 공부 조언사항

```
우리가 수정에 대응할 수 있다 -> 코드를 이해하고 있다로 이어짐. 이걸 목표로 공부해야함.

격리 잘시키고, 본인의 의도에 맞게 코드를 잘 짰다면 수정은 자연스레 쉬워질 수 밖에 없음.
```

switch문은 병행조건을 서술하는데 있어서 문제는 반드시 여집합이 생긴다는 부분이다. 이러한 부분은 default를 사용하면 해결할 수 있다.

> 조건문 조언 사항

```
내가 짠 로직을 검증하는 방법 -> 굳이 진리표를 짜서 검증하기 앞서서 멘데토리로 빠지는지 옵셔널로 빠지는지부터 검증하는 것이 좋다.

멘데토리로 시작했으면 멘데토리로 끝나던가 옵셔널로 시작했으면 옵셔널로 끝나던가 해야함. 만약 둘다 섞어 쓴다면 예외처리를 매우 잘해야함.
```

## for문

기본적인 형식

```js
for (ex; ex; ex) {}
```

식은 값으로 떨어진다. var가 들어있는건 식인가 문인가? -> 문이다.

ex)

```js
var a =3 // 이건 문이다. 왜냐하면

var k = var a = 3 // 이러한 형태가 성립이 안되기 때문이다.
```

## for의 예외조항

for는 첫번째 인자로 문(선언 문한정)이나 식이 들어올 수 있다. 두번쨰, 세번째 인자에는 식밖에 못 온다. 공문또한 올 수 있다.

> Falsy 값

'', false, 0 , undefined, null, NaN -> 이 값들을 Falsy 값들이라고 부른다.

> truthy 값

falsy값을 제외한 나머지 모든 값

```js
for (;;) {}
```

가운데 인자(2번째)가 공문이 올경우 원래같으면 없을때 false가 되야 정상으로 보일테지만 for문의 경우에는 true가 된다.

반면 while() {}은 조건식을 비우면 while문 자체가 죽는다.

세번 째 인자(3번쨰)는 for문의 마지막에 실행된다.

do { } while ( truthy ) -> while은 무조건 truthy 값이 와야함.

do ~ while 끝에 ;(세미콜론) 무조건 붙여야함.

    ex ) do a ++; while (a);
