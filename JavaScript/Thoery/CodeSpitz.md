# 코드스피츠73 - ES6+

# 서론

코드의 복잡성이 현업자와 공부하는 학생의 차이. 복잡성을 관리할 수 있는가 아닌가를 목표로 해야함.

> 프로그램이란 무엇인가?

어디서부터 프로그램일까?

컴퓨터 메모리에 적재된 이후에 실행되기 직전 상태부터 프로그램이라고 부른다.

예를 들어 엑셀.exe를 클릭해서 실행될 수 있게 메모리에 적재되있는 상태를 의미한다.

---

> 컴파일 언어

C나 C++ 자바 같은 컴파일 언어는 다음과 같은 과정을 가진다.

1. LANGUAGE CODE - LINT TIME
2. MACHINE LANGUAGE - COMPILE TIME
3. FILE
4. LOAD
5. RUN - RUN TIME
6. TERMINATE

이런 컴파일 언어의 흐름을 보면 우리는 우선 `LANGUAGE CODE`를 짜게된다.

사람에게 보다 친절하고 익숙한 언어를 짠 후 기계적 언어인 `MACHINE LAGNUGAE` 단계로 넘어간다. 사람의 언어 -> 기계의 언어로 변환하는 과정을 `컴파일` 이라고 한다.

이러한 프로그래밍 과정에서 도움을 받는 여러가지 방법이 있다.

`lANGUAGE CODE`를 짤때 나오는 텍스트만 보아도 문제가 있음을 알려주는 것을 `LINTING` or `LINT TIME`이라 부르고 이것을 지원하는 여러가지 툴이 있다.(아마 ESLINT등)

`MACHINE LANGUAGE`단에서 일어나는 `COMPILE ERROR`나 `RUN` 부분에서 일어나는 `RUN TIME ERROR`등 다양한 에러 단계가 있다.

위의 모든 에러 단계에 해당하지 않는 에러를 `컨텍스트 에러`라고 부른다.

실행 자체는 정상적으로 되지만 에러는 검출이 되지 않는다. 그렇기 때문에 `CONTEXT` 즉 사고 자체가 잘못된 에러라고 하여 컨텍스트 에러라고 부른다.

> 런타임 언어

JavaScript가 대표적이며 다음과 같은 과정을 가진다.

1. LANGUAGE CODE - LINT TIME
2. FILE
3. LOAD
4. MACHINE LANGUAGE
5. RUN - RUNTIME
6. TERMINATE

절차는 처음에는 컴파일 언어와 똑같다. 그다음 js파일로 저장되고 브라우저가 이를 로드한다.

브라우저가 로드했을때 js파일은 여전히 LANGUAGE CODE로 되어있는데 자기 스스로 기계적 언어인 MACHINE LANGUAGE로 알아서 변환한다.

이 과정에서 런타임 언어가 자동으로 수행하는 컴파일과 C언어와 같은 컴파일 언어의 컴파일은 큰 차이가 존재한다.

> `런타임 언어`와 `컴파일 언어`의 컴파일 차이

`컴파일 언어`는 COMPILE TIME에 우리가 작성한 모든 LANGUAGE CODE를 하나도 빠짐없이 해석하여 컴파일한다. 왜냐하면 LAGUAGE CODE와 MACHINE LANGUAGE의 전체 결과를 하나의 FILE로 만드려고 하기 때문이다.

그러나 `런타임 언어`는 JS파일을 100개 200개 만들어도 내가 지금 바라보고 있는 파일만을 컴파일한다.
전부 검사하지 않는다. 그러나 하나의 파일에서도 부분 부분만 MACHINE CODE로 바꿔놓고 나머진 해석을 하지 않는다. 그래서 부분부분 잘못된 코드가 있어도 그 코드가 호출되기 전까지 정상동작한다.

대부분의 RUN TIME 에러는 잡을 수 없다. 그래서 이부분을 보완하기 위한 수단들이 필요하다.

그래서 이를 해결하기 위해 컴파일 스타일로 강제하는 플랫폼들이 존재한다.(EX : Typescript)

또는 레이어별로 런타임을 격리시켜 나누는 방식이 있다(ex 격리(isolate)를 활용)

> 격리

격리하는 법을 인식하고 코드를 격리시키면서 짜는것이 굉장히 중요하다.

본인이 코드 하나를 짜더라도 어떤 의미와 어떤 역할을 갖고 어디까지 격리시킬 수 있는지를 인식하는 방향으로 공부하는 것이 중요하다.

# 자바스크립트의 구성요소

자바스크립트 엔진은 텍스트를 만나면 아래와 같은 방식으로 보게된다.

> WHITE SPACE 공백문자

공백을 나타내는 문자가 상당히 많다. 그렇기 때문에 자바스크립트에서 이를 미리 정의해두었다.

> LINE TERMINATORS 개행문자

> COMMENTS 개행문자

주석이 해당된다.

> KEYWORD 키워드

미리 약속되어 있어서 엔진이 이를 만나면 특정 행동을 수행하는 언어를 말 함.

> LITERALS 리터럴

리터럴이란 언어에서 정의한 더 이상 쪼갤 수 없는 값을 의미한다.

예를 들어 자바스크립트에서 37을 표현하려면 3, 7을 나누어서 표현해야한다. 그러나 여기서 3,7에서 더 쪼개어서 37을 표현할 수 없다. 그렇기 때문에 이를 숫자 리터럴이라고 부른다.

다음 예로는 부울린값 true를 들면, t,r,u,e라는 각각의 알파벳으로 쪼개어서 표현한다. 이러한 것들을 리터럴이라고 부른다

객체 리터럴, 함수 리터럴 등등 수 많은 리터럴을 포함한다.

> 공부할 때의 마음가짐

자만심을 버려야한다. 당연히 안다고 생각하고 넘어가는것 금지.

# 자바스크립트의 요소

자바스크립트는 크게 3가지 요소로 나뉜다.

1. STATEMENTS 문

   공문,식문,제어문

2. EXPRESSION 식

   값식, 연산식, 호출식

3. IDENTIFIER 식별자

   기본형, 참조형

식이란 하나의 값에 수용되는 것을 의미한다. 1 + 5 는 덧셈연산 식이데 6으로 수용된다. 즉 식은 값의 확장된 표현이라고 볼 수 있다.

하나의 값은 식이 될 수 있다.(ex: a, b, c ,1 ,2 ,3) 때문에 `값식(value expreesion)`이라고 부른다.

다음은 연산자를 이용한 식이 있다. 1 + 3은 산술 연산자를 사용한 연산식이라고 볼 수 있다. 이러한 연산자가 등장한 경우 `연산식`이라고 부른다.

다음은 함수를 호출하는 것또한 호출식이라고 볼 수 있다.

값식, 연산식, 호출식은 서로 사용할 수 있는 관계를 가지고 있고, 이들의 조합은 언제나 `하나의 값`으로 떨어진다.

그러나 `값`은 우리가 메모리에 저장시키지 않으면 휘발된다.

> 변수란?

1. 메모리 주소의 별명이다.
2. 자바스크립트에는 형(形)이 존재한다. 해당 값(데이터)에 대한 타입(type) 정보를 가지고 있다.

3을 a에 저장했다고 생각해보자

```js
let a = 3;
```

3이란 값은 a에 저장되어있다기 보단 컴퓨터 메모리 어딘가에 저장되어 있다. 우리는 그 복잡한 메모리 주소에 a라는 alias를 붙인 것이다.

그렇기 때문에 a는 그 메모리 주소를 찾아가 3이라는 값을 꺼내오는 것이다.

또한

```js
typeof a;
("number");
```

할 경우 변수는 메모리의 주소일 뿐만 아니라 해당 값에 대한 타입 정보또한 가지고 있다.

이러한 타입 정보를 데이터 타입(자료형)라고도 부른다.

메모리 주소 + 데이터 형을 포함시킨 두가지 의미를 담는 특별한 이름을 지정하는 행위를 `식별자(identifier)`라고 부른다.

식별자는 안에 담는 형태가 2가지가 올 수 있다.

첫번째는 a = 3 과 같은 값이 들어올 수 있다.

두번째는 참조가 들어온다. 참조란 다른 메모리의 주소가 들어오는 것을 의미한다.

그렇기 때문에 변수에 들어가는 것은 크게보면 값과 참조가 들어간다고 볼 수 있다.

그리고 값을 사용할땐 모든 값은 복사가 일어난다.

```js
a;
3;
let b = a; // 이 경우 a라는 메모리 주소를 옮겨준건지 3이라는 값을 옮겨준건지 알아볼 필요가 있다.

b;
3; // 이 경우에는 3이라는 값을 복사시켜줬다고 봐야한다.

a = 7; // 주소를 옮겨준 경우
7;
b; // b가 7이나와야 하지만 3이나왔다. 한마디로 메모리 블록을 2개 쓰는 복사라고 봐야한다.
3;
```

다음은 참조하는 경우이다.

```js
a = [1, 2, 3](3)[(1, 2, 3)];
b = a(3)[(1, 2, 3)];
a[0];
1;
a[0] = 7;
7;
b(3)[(7, 2, 3)];
```

이렇듯 변수에는 참조가 되는 것과 복사가 되는 것 2가지가 있다고 보면 된다.

    * 취업, 공부 이야기
    복잡성을 극복한 사람이라면 개발자로서 사회적 강자의 위치할 수 있다.

    체계적인 공부 하는 양을 전부다 기억해야 한다(그것도 매우 정확하게)

    범위적 공부가 아닌 공학 공부처럼 기초를 기반으로 층을 쌓는 방식으로 공부해야함. -> 결국 기존 전기 공부했던 방식과 동일함. 기초부터 튼튼히

    특히 CS가 더 나은점은 공리가 존재하지 않음. 기존 학문은 공리가 무너지면 근본이 무너지지만 cs는 그런 공리가 없다. 놀라운 부분인듯.

    또한 공부할때 개념을 공부함에 있어서 가급적 영어로 하는것이 좋음.(번역은 일관성이 떨어짐. 산술연산자 같은건 제외)

자바스크립트에서 `기본형(Primitive type)`을 제외한 나머지는 `전부 참조형(Reference Type)`이다. 기억하자.

> 변수

변수는 또 상수와 변수로 나뉜다.

변해야할 이유가 있을때에만 변수로

나머진 불변성(emueterbla)한 상수로 사용하는 것이 좋다.

if, return과 같은 STATEMENTS(문)은 값으로 활용되지 않는 자바스크립트 엔진이 해석하게 하기위한 힌트나 명령이라고 보면 된다. 그러나 다만 다소 절대적인 면이 있어서 힌트라고만 보기는 힘듦.

문에는 4가지 종류가 있다.

1. 공문(아무것도 없다.)

   근대 실사용되진 않음.

2. 식문(하나의 식은 하나의 문이 된다)

   ex) 3 + 5; // 3; 2; 5; 둘다 허용 (JAVA는 Context 에러뜸)

3. 제어문

4. 선언문

5. 단문(문장한개)
6. 중문({} 블록이라고 부름)

## SYNC FLOW

과정은 좌에서 우로 위에서 아래로 진행된다.

컴퓨터는 메모리에 적재되있는걸 우리의 관여와 무관하게 실행해버리는 노이만 머신의 특성을 갖고 있다.

이를 해결하기 위한 방법이 비동기성 방법이고 여러가지가 있다.

그러나 할당(Assignment)만이 우에서 좌로 진행됨. (수학때문임)

---

다음과 같은식은 좋지 못한식이다.

```js
3 + 5 / 2;
5.5;
```

수학의 사칙연산을 기반으로 하기 때문에 코딩에 집중하여 보자면 비 프로그래밍적이고 비 코딩적인 관점이다.

```js
plus(3, div(5, 2));
5.5;
```

다음과 같이 아무런 사전지식(사칙연산 과 같은)이 필요하지 않는 형식으로 짜는것이 좋다. 또한 연산자가 개입되는건 무조건적으로 괄호를 치는것이 좋다.

## SYNC FLOW CONTROL

SUB FLOW는 CLASS나 다른 함수들로 관리함.

ES6는 FLOW 중간에 중단시켰다가 다시 시작할 수 있음

FLOW가 한세트 진행되는걸 `루틴`이라고 부른다.

SUB FLOW는 여러번 진행될 수 있고 SUB FLOW의 루틴을 `서브루틴`이라고 부른다.

유사한 기능을 하는 구문이 여러가지 있는 이유는 인간의 복잡한 사고를 표현하기 위함임.

제어문을 어떻게 쓰고 어떤 문을 이용해서 우리가 알고있는 것을 표현하느냐가 중요함.

공백문자의 특징은 공백이 아무리 많아도 하나의 공백으로 취급함 (IF (조건식) 조건식과 IF 사이의 공백을 의미)

우선순위 연산자 ( `( )` 괄호를 의미)
